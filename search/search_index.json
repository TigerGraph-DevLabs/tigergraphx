{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to TigerGraphX","text":"<p>TigerGraphX is a high-level Python library offering a unified, Python-native interface for graph databases, advanced analytics, and GraphRAG workflows. Combining the simplicity of NetworkX with the advanced capabilities of TigerGraph, including tgCloud, it empowers Python developers to harness the power of graphs without the need to learn query languages like Cypher or GSQL.</p> <p>TigerGraphX is designed for two main audiences, catering to different use cases while maintaining an easy-to-use, developer-friendly experience:</p>"},{"location":"#who-should-use-tigergraphx","title":"Who Should Use TigerGraphX?","text":""},{"location":"#1-python-developers-for-graph-analytics-with-tigergraph","title":"1. Python Developers for Graph Analytics with TigerGraph","text":"<p>If you\u2019re a Python developer interested in performing graph analytics with TigerGraph, TigerGraphX provides:</p> <ul> <li>Python-Native APIs: No need to learn complex query languages like GSQL or Cypher.</li> <li>Seamless Integration: Easily perform CRUD operations, multi-hop queries, and advanced analytics directly from Python.</li> <li>Scalability: Leverage the powerful performance of TigerGraph for large-scale graph processing.</li> </ul> <p>Start here:</p> <ul> <li>Introduction to TigerGraphX: Discover the features and benefits of using TigerGraphX for graph database management and analytics.</li> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>Quick Start Guide: Quickly set up TigerGraphX and build your first graph with this step-by-step guide.</li> </ul>"},{"location":"#2-python-developers-for-graphrag-workflows","title":"2. Python Developers for GraphRAG Workflows","text":"<p>If you\u2019re a Python developer building GraphRAG applications, TigerGraphX enables you to:</p> <ul> <li>Use TigerGraph as a scalable database for storing and retrieving graph and vector data generated by GraphRAG algorithms.</li> <li>Build token-aware LLM workflows for advanced AI applications.</li> <li>Utilize context builders to streamline data preparation for large language models.</li> </ul> <p>Start here:</p> <ul> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>GraphRAG Overview: Explore how TigerGraphX integrates with GraphRAG workflows.</li> <li>Supporting Microsoft\u2019s GraphRAG: An example of using TigerGraphX for GraphRAG workflows.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"introduction/","title":"TigerGraphX: Unified Graph Solutions for Python Developers","text":""},{"location":"introduction/#what-is-tigergraphx","title":"What is TigerGraphX?","text":"<p>TigerGraphX is a high-level Python library offering a unified, Python-native interface for graph databases, advanced analytics, and GraphRAG workflows. Combining the simplicity of NetworkX with the advanced capabilities of TigerGraph, including tgCloud, it empowers Python developers to harness the power of graphs without the need to learn query languages like Cypher or GSQL.</p>"},{"location":"introduction/#core-mission","title":"Core Mission","text":"<p>TigerGraphX seeks to democratize graph technology by providing an intuitive, all-encompassing framework that integrates and provides direct connection to:</p> <ul> <li>TigerGraph Database capabilities</li> <li>TigerGraph Vector Database functionality</li> <li>Large Language Model (LLM) integration</li> <li>TigerGraph\u2019s GraphRAG support for intelligent workflow</li> </ul>"},{"location":"introduction/#key-features","title":"Key Features","text":""},{"location":"introduction/#1-schema-management","title":"1. Schema Management","text":"<ul> <li>Easily create and modify schemas using YAML, JSON, or Python dictionaries.</li> <li>No GSQL knowledge is required.</li> <li>Pythonic tools for designing database structures effortlessly.</li> </ul>"},{"location":"introduction/#2-data-loading","title":"2. Data Loading","text":"<ul> <li>Automated loading jobs for streamlined data imports.</li> <li>High-efficiency workflows with support for Parquet files.</li> <li>Simplified data ingestion processes for faster setup.</li> </ul>"},{"location":"introduction/#3-graph-library-interface","title":"3. Graph Library Interface","text":"<ul> <li>Python-native APIs for CRUD operations.</li> <li>Comprehensive tools for graph reporting and visualization.</li> <li>Built-in graph algorithms including centrality, community detection, and path analysis algorithms</li> </ul>"},{"location":"introduction/#4-graph-query-interface","title":"4. Graph Query Interface","text":"<ul> <li>Simplified advanced querying with intuitive APIs.</li> <li>Seamless integration into analytics workflows via DataFrame outputs.</li> <li>Support for advanced multi-hop query traversal and manipulation</li> </ul>"},{"location":"introduction/#5-vector-search-capabilities","title":"5. Vector Search Capabilities","text":"<ul> <li>AI-driven applications with integrated vector embeddings.</li> <li>Efficient top-K entity retrieval for enhanced intelligence.</li> <li>Ideal for recommendation systems and contextual analysis.</li> </ul>"},{"location":"introduction/#6-llm-integration-and-graphrag-support","title":"6. LLM Integration and GraphRAG support","text":"<ul> <li>Full support for GraphRAG workflows.</li> <li>Flexible, token-aware context builders for advanced applications.</li> <li>Tools for token optimization and seamless LLM integration.</li> </ul>"},{"location":"introduction/#7-machine-learning-ready-planned-feature","title":"7. Machine Learning Ready [Planned Feature]","text":"<ul> <li>Seamless integration with popular ML libraries</li> <li>Graph feature extraction</li> <li>Native support for graph neural networks (GNNs)</li> </ul>"},{"location":"introduction/#why-choose-tigergraphx","title":"Why Choose TigerGraphX?","text":"<p>TigerGraphX redefines graph technology by making advanced and powerful graph operations accessible and intuitive for Python developers. With its unified, user-friendly interface, TigerGraphX bridges the gap between simplicity and scalability, enabling developers to:</p> <ul> <li>Leverage TigerGraph\u2019s unmatched scalability for high-performance graph processing.  </li> <li>Enjoy the familiarity of tools like NetworkX while unlocking enterprise-grade graph capabilities.  </li> <li>Access advanced graph analytics with ease, reducing the learning curve and technical barriers.  </li> <li>Develop intelligent, context-aware GraphRAG applications effortlessly with token-aware workflows and streamlined context builders.</li> </ul> <p>TigerGraphX empowers developers to explore, analyze, and build with graphs like never before\u2014efficiently and effectively.</p>"},{"location":"introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>GraphRAG Overview: Explore how TigerGraphX integrates with GraphRAG workflows.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/installation/","title":"Installation Guide","text":"<p>Follow this guide to install and set up TigerGraphX in your environment.</p>"},{"location":"getting_started/installation/#requirements","title":"Requirements","text":"<p>This project requires Python 3.10, 3.11 or 3.12 and TigerGraph. Ensure you meet the following prerequisites before proceeding:</p>"},{"location":"getting_started/installation/#1-python","title":"1. Python","text":"<ul> <li>Please ensure Python 3.10, 3.11 or 3.12 is installed on your system.</li> <li>You can download and install it from the official Python website.</li> </ul>"},{"location":"getting_started/installation/#2-tigergraph","title":"2. TigerGraph","text":"<p>TigerGraph is required for this project and can be set up in one of the following ways:</p> <ul> <li>TigerGraph DB: Install and configure a local instance of TigerGraph.</li> <li>TigerGraph Cloud: Use a cloud-hosted instance of TigerGraph.</li> <li>TigerGraph Docker: Use a Docker container to run TigerGraph.</li> </ul> <p>It is recommended to use TigerGraph LTS (Long-Term Support) Versions, which can be downloaded from the TigerGraph Downloads page. To enable support for TigerVector and leverage advanced features like hybrid retrieval, ensure you are using TigerGraph 4.2 or above.</p> <p>Refer to the official TigerGraph Documentation for detailed installation and configuration instructions.</p>"},{"location":"getting_started/installation/#installation-steps","title":"Installation Steps","text":""},{"location":"getting_started/installation/#option-1-install-from-pypi","title":"Option 1: Install from PyPI","text":"<p>The simplest way to get started with TigerGraphX is by installing it directly from PyPI. Using a virtual environment is recommended to ensure a clean and isolated setup.</p> <p>To install TigerGraphX, run: <pre><code>pip install tigergraphx\n</code></pre></p> <p>This allows you to quickly start using the library without needing the source code.</p>"},{"location":"getting_started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installing, verify that TigerGraphX is installed correctly by running: <pre><code>python -c 'import tigergraphx; print(\"TigerGraphX installed successfully!\")'\n</code></pre></p> <p>If the installation was successful, you will see: <pre><code>TigerGraphX installed successfully!\n</code></pre></p> <p>This ensures that the library is properly installed and ready for use.</p>"},{"location":"getting_started/installation/#option-2-build-from-source-code","title":"Option 2: Build from Source Code","text":"<p>If you want to modify or explore the source code, you can install TigerGraphX from its GitHub repository. The source code is available here: TigerGraphX on GitHub.</p> <p>This project uses Poetry to manage dependencies. If you don\u2019t have Poetry installed, follow the instructions on the Poetry website.</p> <p>Once Poetry is installed, clone the repository, navigate to the project\u2019s root directory, and use one of the following commands to install dependencies based on your needs:</p>"},{"location":"getting_started/installation/#core-installation","title":"Core Installation","text":"<p>If you need only the core functionality of TigerGraphX (without running application examples like GraphRAG, unit tests, or integration tests), run: <pre><code>poetry install --without dev\n</code></pre></p> <p>This command will:</p> <ul> <li>Install only the dependencies required for the core features of TigerGraphX.</li> </ul>"},{"location":"getting_started/installation/#development-installation","title":"Development Installation","text":"<p>If you\u2019re contributing to the project or want to use advanced features like running the GraphRAG examples or test cases, run: <pre><code>poetry install --with dev\n</code></pre></p> <p>This command will:</p> <ul> <li>Install all core dependencies.</li> <li>Include development dependencies defined under <code>[tool.poetry.group.dev.dependencies]</code> in <code>pyproject.toml</code>.</li> </ul>"},{"location":"getting_started/installation/#verify-your-installation","title":"Verify Your Installation","text":"<p>After installing dependencies, verify your setup by listing the installed packages: <pre><code>poetry show --with dev\n</code></pre></p> <p>This ensures all required dependencies (including optional ones) are successfully installed.</p>"},{"location":"getting_started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>TigerGraphX Quick Start: Learn how to build your first graph with TigerGraphX.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/quick_start_both/","title":"TigerGraphX Quick Start: Using TigerGraph for Graph and Vector Database","text":"<p>Follow this guide to quickly get started with TigerGraph for storing both graph data and vectors. This guide assumes that you have already installed TigerGraphX and its dependencies, as outlined in the Installation Guide.</p> <p>To run this Jupyter Notebook, download the original <code>.ipynb</code> file from quick_start_both.ipynb.</p> <p>In this quick start guide, we will work with the following graph:</p> <p></p>"},{"location":"getting_started/quick_start_both/#create-a-graph","title":"Create a Graph","text":""},{"location":"getting_started/quick_start_both/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration","text":"<p>Since our data is stored in a TigerGraph instance\u2014whether on-premise or in the cloud\u2014we need to configure the connection settings. The recommended approach is to use environment variables, such as setting them with the <code>export</code> command in the shell. Here, to illustrate the demo, we configure them within Python using the <code>os.environ</code> method. You can find more methods for configuring connection settings in Graph.__init__.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ[\"TG_HOST\"] = \"http://127.0.0.1\"\n&gt;&gt;&gt; os.environ[\"TG_USERNAME\"] = \"tigergraph\"\n&gt;&gt;&gt; os.environ[\"TG_PASSWORD\"] = \"tigergraph\"\n</code></pre>"},{"location":"getting_started/quick_start_both/#define-a-graph-schema","title":"Define a Graph Schema","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we create a graph called \"FinancialGraph\" with three node types: \"Account,\" \"City,\" and \"Phone,\" and three edge types: \"transfer,\" \"hasPhone,\" and \"isLocatedIn.\"</p> <ul> <li>Nodes:</li> <li>Account: Primary key <code>name</code>, attributes <code>name</code> (string) and <code>isBlocked</code> (boolean), vector attribute <code>emb1</code> (3).</li> <li>City: Primary key <code>name</code>, attribute <code>name</code> (string).</li> <li> <p>Phone: Primary key <code>number</code>, attributes <code>number</code> (string) and <code>isBlocked</code> (boolean), vector attribute <code>emb1</code> (3).</p> </li> <li> <p>Edges:</p> </li> <li>transfer: Directed multi-edge between \"Account\" nodes, identified by <code>date</code> (datetime) as the unique identifier for each edge between a pair of source and target nodes. The edge has an attribute <code>amount</code> (integer).</li> <li>hasPhone: Undirected edge between \"Account\" and \"Phone\" nodes.</li> <li>isLocatedIn: Directed edge between \"Account\" and \"City\" nodes.</li> </ul> <p>This schema defines the structure of the \"FinancialGraph\" with nodes and edges and their respective attributes.</p> <pre><code>&gt;&gt;&gt; graph_schema = {\n...     \"graph_name\": \"FinancialGraph\",\n...     \"nodes\": {\n...         \"Account\": {\n...             \"primary_key\": \"name\",\n...             \"attributes\": {\n...                 \"name\": \"STRING\",\n...                 \"isBlocked\": \"BOOL\",\n...             },\n...             \"vector_attributes\": {\"emb1\": 3},\n...         },\n...         \"City\": {\n...             \"primary_key\": \"name\",\n...             \"attributes\": {\n...                 \"name\": \"STRING\",\n...             },\n...         },\n...         \"Phone\": {\n...             \"primary_key\": \"number\",\n...             \"attributes\": {\n...                 \"number\": \"STRING\",\n...                 \"isBlocked\": \"BOOL\",\n...             },\n...             \"vector_attributes\": {\"emb1\": 3},\n...         },\n...     },\n...     \"edges\": {\n...         \"transfer\": {\n...             \"is_directed_edge\": True,\n...             \"from_node_type\": \"Account\",\n...             \"to_node_type\": \"Account\",\n...             \"discriminator\": \"date\",\n...             \"attributes\": {\n...                 \"date\": \"DATETIME\",\n...                 \"amount\": \"INT\",\n...             },\n...         },\n...         \"hasPhone\": {\n...             \"is_directed_edge\": False,\n...             \"from_node_type\": \"Account\",\n...             \"to_node_type\": \"Phone\",\n...         },\n...         \"isLocatedIn\": {\n...             \"is_directed_edge\": True,\n...             \"from_node_type\": \"Account\",\n...             \"to_node_type\": \"City\",\n...         },\n...     },\n... }\n</code></pre> <p>TigerGraphX offers several methods to define the schema, including a Python dictionary, YAML file, or JSON file. Above is an example using a Python dictionary. For other methods, please refer to Graph.__init__ for more details.</p>"},{"location":"getting_started/quick_start_both/#create-a-graph_1","title":"Create a Graph","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p> <pre><code>&gt;&gt;&gt; from tigergraphx import Graph\n&gt;&gt;&gt; G = Graph(graph_schema)\n</code></pre> <pre><code>2025-02-28 14:17:12,187 - tigergraphx.core.managers.schema_manager - INFO - Creating schema for graph: FinancialGraph...\n2025-02-28 14:17:15,857 - tigergraphx.core.managers.schema_manager - INFO - Graph schema created successfully.\n2025-02-28 14:17:15,857 - tigergraphx.core.managers.schema_manager - INFO - Adding vector attribute(s) for graph: FinancialGraph...\n2025-02-28 14:18:31,787 - tigergraphx.core.managers.schema_manager - INFO - Vector attribute(s) added successfully.\n</code></pre>"},{"location":"getting_started/quick_start_both/#retrieve-a-graph-and-print-its-schema","title":"Retrieve a Graph and Print Its Schema","text":"<p>Once a graph has been created in TigerGraph, you can retrieve it without manually defining the schema using the <code>Graph.from_db</code> method, which requires only the graph name:</p> <pre><code>&gt;&gt;&gt; G = Graph.from_db(\"FinancialGraph\")\n</code></pre> <p>Now, let's print the schema of the graph in a well-formatted manner:</p> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; schema = G.get_schema()\n&gt;&gt;&gt; print(json.dumps(schema, indent=4, default=str))\n</code></pre> <pre><code>{\n    \"graph_name\": \"FinancialGraph\",\n    \"nodes\": {\n        \"Account\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"isBlocked\": {\n                    \"data_type\": \"DataType.BOOL\",\n                    \"default_value\": null\n                }\n            },\n            \"vector_attributes\": {\n                \"emb1\": {\n                    \"dimension\": 3,\n                    \"index_type\": \"HNSW\",\n                    \"data_type\": \"FLOAT\",\n                    \"metric\": \"COSINE\"\n                }\n            }\n        },\n        \"City\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                }\n            },\n            \"vector_attributes\": {}\n        },\n        \"Phone\": {\n            \"primary_key\": \"number\",\n            \"attributes\": {\n                \"number\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"isBlocked\": {\n                    \"data_type\": \"DataType.BOOL\",\n                    \"default_value\": null\n                }\n            },\n            \"vector_attributes\": {\n                \"emb1\": {\n                    \"dimension\": 3,\n                    \"index_type\": \"HNSW\",\n                    \"data_type\": \"FLOAT\",\n                    \"metric\": \"COSINE\"\n                }\n            }\n        }\n    },\n    \"edges\": {\n        \"transfer\": {\n            \"is_directed_edge\": true,\n            \"from_node_type\": \"Account\",\n            \"to_node_type\": \"Account\",\n            \"discriminator\": \"{'date'}\",\n            \"attributes\": {\n                \"date\": {\n                    \"data_type\": \"DataType.DATETIME\",\n                    \"default_value\": null\n                },\n                \"amount\": {\n                    \"data_type\": \"DataType.INT\",\n                    \"default_value\": null\n                }\n            }\n        },\n        \"hasPhone\": {\n            \"is_directed_edge\": false,\n            \"from_node_type\": \"Account\",\n            \"to_node_type\": \"Phone\",\n            \"discriminator\": \"set()\",\n            \"attributes\": {}\n        },\n        \"isLocatedIn\": {\n            \"is_directed_edge\": true,\n            \"from_node_type\": \"Account\",\n            \"to_node_type\": \"City\",\n            \"discriminator\": \"set()\",\n            \"attributes\": {}\n        }\n    }\n}\n</code></pre>"},{"location":"getting_started/quick_start_both/#add-nodes-and-edges","title":"Add Nodes and Edges","text":""},{"location":"getting_started/quick_start_both/#add-nodes","title":"Add Nodes","text":"<p>The following code adds three types of nodes to the graph:</p> <ul> <li>Account Nodes:   Each account node is identified by a name and includes two attributes:  </li> <li><code>isBlocked</code>: A boolean indicating if the account is blocked.  </li> <li> <p><code>emb1</code>: A three-dimensional embedding vector.</p> </li> <li> <p>Phone Nodes:   Each phone node is identified by a phone number and has the same attributes as account nodes (<code>isBlocked</code> and <code>emb1</code>).</p> </li> <li> <p>City Nodes:   Each city node is identified by its name. No additional attributes are required.</p> </li> </ul> <p>For each node type, the code prints the number of nodes inserted.</p> <pre><code>&gt;&gt;&gt; nodes_for_adding = [\n...     (\"Scott\", {\"isBlocked\": False, \"emb1\": [-0.017733968794345856, -0.01019224338233471, -0.016571875661611557]}),\n...     (\"Jenny\", {\"isBlocked\": False, \"emb1\": [-0.019265105947852135, 0.0004929182468913496, 0.006711316294968128]}),\n...     (\"Steven\", {\"isBlocked\": True, \"emb1\": [-0.01505514420568943, -0.016819344833493233, -0.0221870020031929]}),\n...     (\"Paul\", {\"isBlocked\": False, \"emb1\": [0.0011193430982530117, -0.001038988004438579, -0.017158523201942444]}),\n...     (\"Ed\", {\"isBlocked\": False, \"emb1\": [-0.003692442551255226, 0.010494389571249485, -0.004631792660802603]}),\n... ]\n&gt;&gt;&gt; print(\"Number of Account Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"Account\"))\n\n&gt;&gt;&gt; nodes_for_adding = [\n...     (\"718-245-5888\", {\"isBlocked\": False, \"emb1\": [0.0023173028603196144, 0.018836047500371933, 0.03107452765107155]}),\n...     (\"650-658-9867\", {\"isBlocked\": True, \"emb1\": [0.01969221793115139, 0.018642477691173553, 0.05322211980819702]}),\n...     (\"352-871-8978\", {\"isBlocked\": False, \"emb1\": [-0.003442931454628706, 0.016562696546316147, 0.012876809574663639]}),\n... ]\n&gt;&gt;&gt; print(\"Number of Phone Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"Phone\"))\n\n&gt;&gt;&gt; nodes_for_adding = [\"New York\", \"Gainesville\", \"San Francisco\"]\n&gt;&gt;&gt; print(\"Number of City Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"City\"))\n</code></pre> <pre><code>Number of Account Nodes Inserted: 5\nNumber of Phone Nodes Inserted: 3\nNumber of City Nodes Inserted: 3\n</code></pre>"},{"location":"getting_started/quick_start_both/#add-edges","title":"Add Edges","text":"<p>Next, we add relationships between nodes by creating edges:</p> <ul> <li> <p>hasPhone Edges:   These edges connect account nodes to phone nodes. Each tuple specifies an edge from an account to a phone number.</p> </li> <li> <p>isLocatedIn Edges:   These edges connect account nodes to city nodes. Each tuple specifies an edge from an account to a city.</p> </li> <li> <p>transfer Edges:   These edges connect one account node to another, representing a transfer relationship. Each edge tuple includes additional attributes:  </p> </li> <li><code>date</code>: The date of the transfer.  </li> <li><code>amount</code>: The amount transferred.</li> </ul> <p>For each relationship type, the code prints the number of edges inserted.</p> <pre><code>&gt;&gt;&gt; ebunch_to_add = [\n...     (\"Scott\", \"718-245-5888\"),\n...     (\"Jenny\", \"718-245-5888\"),\n...     (\"Jenny\", \"650-658-9867\"),\n...     (\"Paul\", \"650-658-9867\"),\n...     (\"Ed\", \"352-871-8978\"),\n... ]\n&gt;&gt;&gt; print(\"Number of hasPhone Edges Inserted:\", G.add_edges_from(ebunch_to_add, \"Account\", \"hasPhone\", \"Phone\"))\n\n&gt;&gt;&gt; ebunch_to_add = [\n...     (\"Scott\", \"New York\"),\n...     (\"Jenny\", \"San Francisco\"),\n...     (\"Steven\", \"San Francisco\"),\n...     (\"Paul\", \"Gainesville\"),\n...     (\"Ed\", \"Gainesville\"),\n... ]\n&gt;&gt;&gt; print(\"Number of isLocatedIn Edges Inserted:\", G.add_edges_from(ebunch_to_add, \"Account\", \"isLocatedIn\", \"City\"))\n\n&gt;&gt;&gt; ebunch_to_add = [\n...     (\"Scott\", \"Ed\", {\"date\": \"2024-01-04\", \"amount\": 20000}),\n...     (\"Scott\", \"Ed\", {\"date\": \"2024-02-01\", \"amount\": 800}),\n...     (\"Scott\", \"Ed\", {\"date\": \"2024-02-14\", \"amount\": 500}),\n...     (\"Jenny\", \"Scott\", {\"date\": \"2024-04-04\", \"amount\": 1000}),\n...     (\"Paul\", \"Jenny\", {\"date\": \"2024-02-01\", \"amount\": 653}),\n...     (\"Steven\", \"Jenny\", {\"date\": \"2024-05-01\", \"amount\": 8560}),\n...     (\"Ed\", \"Paul\", {\"date\": \"2024-01-04\", \"amount\": 1500}),\n...     (\"Paul\", \"Steven\", {\"date\": \"2023-05-09\", \"amount\": 20000}),\n... ]\n&gt;&gt;&gt; print(\"Number of transfer Edges Inserted:\", G.add_edges_from(ebunch_to_add, \"Account\", \"transfer\", \"Account\"))\n</code></pre> <pre><code>Number of hasPhone Edges Inserted: 5\nNumber of isLocatedIn Edges Inserted: 5\nNumber of transfer Edges Inserted: 8\n</code></pre> <p>For larger datasets, consider using load_data for more efficient handling of large-scale data.</p>"},{"location":"getting_started/quick_start_both/#exploring-nodes-and-edges-in-the-graph","title":"Exploring Nodes and Edges in the Graph","text":""},{"location":"getting_started/quick_start_both/#display-the-number-of-nodes-and-edges","title":"Display the Number of Nodes and Edges","text":"<p>You can verify that the data has been inserted into the graph by running the following commands. For this example, the graph contains 11 nodes and 18 edges.</p> <pre><code>&gt;&gt;&gt; print(G.number_of_nodes())\n</code></pre> <pre><code>11\n</code></pre> <pre><code>&gt;&gt;&gt; print(G.number_of_edges())\n</code></pre> <pre><code>18\n</code></pre>"},{"location":"getting_started/quick_start_both/#check-if-nodes-and-edges-exist","title":"Check if Nodes and Edges Exist","text":"<p>To confirm the presence of specific nodes and edges, you can use the following checks:</p> <pre><code>&gt;&gt;&gt; print(G.has_node(\"Scott\", \"Account\"))\n</code></pre> <pre><code>True\n</code></pre> <pre><code>&gt;&gt;&gt; print(G.has_node(\"Ed\", \"Account\"))\n</code></pre> <pre><code>True\n</code></pre> <pre><code>&gt;&gt;&gt; print(G.has_edge(\"Scott\", \"Ed\", src_node_type=\"Account\", edge_type=\"transfer\", tgt_node_type=\"Account\"))\n</code></pre> <pre><code>True\n</code></pre>"},{"location":"getting_started/quick_start_both/#display-node-and-edge-attributes","title":"Display Node and Edge Attributes","text":""},{"location":"getting_started/quick_start_both/#node-attributes","title":"Node Attributes","text":"<p>To view all attributes of a specific node, you can use:</p> <pre><code>&gt;&gt;&gt; print(G.nodes[(\"Account\", \"Scott\")])\n</code></pre> <pre><code>{'name': 'Scott', 'isBlocked': False}\n</code></pre> <p>To retrieve a particular attribute, you can run:</p> <pre><code>&gt;&gt;&gt; print(G.nodes[(\"Account\", \"Scott\")][\"isBlocked\"])\n</code></pre> <pre><code>False\n</code></pre>"},{"location":"getting_started/quick_start_both/#edge-attributes","title":"Edge Attributes","text":"<p>You can fetch and display all attributes associated with the source-to-target relationship for a specific edge type. If multiple edges exist between the start node and the target node, the result will be a dictionary where each key represents the edge's discriminator, and each value is a dictionary of attribute name-value pairs. If there is only one edge, the result will be a single dictionary of attribute name-value pairs.</p> <pre><code>&gt;&gt;&gt; edges = G.get_edge_data(\"Scott\", \"Ed\", src_node_type=\"Account\", edge_type=\"transfer\", tgt_node_type=\"Account\")\n&gt;&gt;&gt; for key, value in edges.items():\n...     print(key, value)\n</code></pre> <pre><code>2024-02-14 00:00:00 {'date': '2024-02-14 00:00:00', 'amount': 500}\n2024-01-04 00:00:00 {'date': '2024-01-04 00:00:00', 'amount': 20000}\n2024-02-01 00:00:00 {'date': '2024-02-01 00:00:00', 'amount': 800}\n</code></pre>"},{"location":"getting_started/quick_start_both/#display-nodes-vector-attributes","title":"Display Node's Vector Attributes","text":"<p>To retrieve a vector attribute for a single node:</p> <pre><code>&gt;&gt;&gt; vector = G.fetch_node(\n...     node_id=\"Scott\",\n...     node_type=\"Account\",\n...     vector_attribute_name=\"emb1\",\n... )\n&gt;&gt;&gt; print(vector)\n</code></pre> <pre><code>[-0.01773397, -0.01019224, -0.01657188]\n</code></pre> <p>For multiple nodes:</p> <pre><code>&gt;&gt;&gt; vectors = G.fetch_nodes(\n...     node_ids=[\"Scott\", \"Jenny\"],\n...     node_type=\"Account\",\n...     vector_attribute_name=\"emb1\",\n... )\n&gt;&gt;&gt; for vector in vectors.items():\n...     print(vector)\n</code></pre> <pre><code>('Scott', [-0.01773397, -0.01019224, -0.01657188])\n('Jenny', [-0.01926511, 0.0004929182, 0.006711317])\n</code></pre>"},{"location":"getting_started/quick_start_both/#filter-the-nodes","title":"Filter the Nodes","text":"<p>To retrieve nodes that match a specific condition, return only selected attributes, and limit the results:</p> <pre><code>&gt;&gt;&gt; df = G.get_nodes(\n...     node_type=\"Account\",\n...     node_alias=\"s\", # \"s\" is the default value, so you can remove this line\n...     filter_expression=\"s.isBlocked == False\",\n...     return_attributes=[\"name\", \"isBlocked\"],\n...     limit=2\n... )\n&gt;&gt;&gt; print(df)\n</code></pre> <pre><code>    name  isBlocked\n0   Paul      False\n1  Scott      False\n</code></pre>"},{"location":"getting_started/quick_start_both/#display-the-degree-of-nodes","title":"Display the Degree of Nodes","text":"<p>To check the degree (number of connections) of a specific node:</p> <pre><code>&gt;&gt;&gt; print(G.degree(\"Ed\", \"Account\"))\n</code></pre> <pre><code>6\n</code></pre> <p>To filter by edge type:</p> <pre><code>&gt;&gt;&gt; print(G.degree(\"Ed\", \"Account\", edge_types=\"transfer\"))\n</code></pre> <pre><code>1\n</code></pre> <pre><code>&gt;&gt;&gt; print(G.degree(\"Ed\", \"Account\", edge_types=\"reverse_transfer\"))\n</code></pre> <pre><code>3\n</code></pre> <pre><code>&gt;&gt;&gt; print(G.degree(\"Ed\", \"Account\", edge_types=\"hasPhone\"))\n</code></pre> <pre><code>1\n</code></pre> <pre><code>&gt;&gt;&gt; print(G.degree(\"Ed\", \"Account\", edge_types=\"isLocatedIn\"))\n</code></pre> <pre><code>1\n</code></pre>"},{"location":"getting_started/quick_start_both/#graph-traversal","title":"Graph Traversal","text":""},{"location":"getting_started/quick_start_both/#retrieve-a-nodes-neighbors","title":"Retrieve a Node\u2019s Neighbors","text":"<p>Retrieve the first two \u201cAccount\u201d nodes that Paul has transferred to, applying a filter to edges where the <code>amount</code> is greater than 653. Return the target node\u2019s \u201cname\u201d and \u201cisBlocked\u201d attributes:</p> <pre><code>&gt;&gt;&gt; df = G.get_neighbors(\n...     start_nodes=\"Paul\",\n...     start_node_type=\"Account\",\n...     start_node_alias=\"s\", # \"s\" is the default value, so you can remove this line\n...     edge_types=\"transfer\",\n...     edge_alias=\"e\", # \"e\" is the default value, so you can remove this line\n...     target_node_types=\"Account\",\n...     target_node_alias=\"t\", # \"t\" is the default value, so you can remove this line\n...     filter_expression=\"e.amount &gt; 653\",\n...     return_attributes=[\"name\", \"isBlocked\"],\n...     limit=2,\n... )\n&gt;&gt;&gt; print(df)\n</code></pre> <pre><code>     name  isBlocked\n0  Steven       True\n</code></pre>"},{"location":"getting_started/quick_start_both/#breadth-first-search","title":"Breadth-First Search","text":"<p>Below is an example of multi-hop neighbor traversal:</p> <pre><code>&gt;&gt;&gt; df = G.bfs(\n...     start_nodes=[\"Paul\"], \n...     node_type=\"Account\", \n...     edge_types=[\"transfer\", \"reverse_transfer\"], \n...     max_hops=2\n... )\n&gt;&gt;&gt; print(df)\n</code></pre> <pre><code>    name  isBlocked\n1  Scott      False\n</code></pre>"},{"location":"getting_started/quick_start_both/#perform-vector-search","title":"Perform Vector Search","text":""},{"location":"getting_started/quick_start_both/#top-k-vector-search-on-a-given-vertex-types-vector-attribute","title":"Top-k Vector Search on a Given Vertex Type's Vector Attribute","text":"<p>To find the top 3 most similar accounts to \"Scott\" based on the embedding, we use the following code. As expected, \"Scott\" will appear in the list with a distance of 0.</p> <pre><code>&gt;&gt;&gt; results = G.search(\n...     data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n...     vector_attribute_name=\"emb1\",\n...     node_type=\"Account\",\n...     limit=2\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n</code></pre> <pre><code>{'id': 'Scott', 'distance': 0, 'name': 'Scott', 'isBlocked': False}\n{'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}\n</code></pre>"},{"location":"getting_started/quick_start_both/#top-k-vector-search-on-a-set-of-vertex-types-vector-attributes","title":"Top-k Vector Search on a Set of Vertex Types' Vector Attributes","text":"<p>The code below performs a multi-vector attribute search on \"Account\" and \"Phone\" node types using two vector attributes (emb1). It retrieves the top 5 similar nodes and fetches the isBlocked attribute for each result.</p> <pre><code>&gt;&gt;&gt; results = G.search_multi_vector_attributes(\n...     data=[-0.003442931454628706, 0.016562696546316147, 0.012876809574663639],\n...     vector_attribute_names=[\"emb1\", \"emb1\"],\n...     node_types=[\"Account\", \"Phone\"],\n...     limit=5,\n...     return_attributes_list=[[\"isBlocked\"], [\"isBlocked\"]]\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n</code></pre> <pre><code>{'id': '352-871-8978', 'distance': 1.788139e-07, 'isBlocked': False}\n{'id': '718-245-5888', 'distance': 0.09038806, 'isBlocked': False}\n{'id': '650-658-9867', 'distance': 0.2705743, 'isBlocked': True}\n{'id': 'Ed', 'distance': 0.5047379, 'isBlocked': False}\n{'id': 'Jenny', 'distance': 0.6291004, 'isBlocked': False}\n</code></pre>"},{"location":"getting_started/quick_start_both/#top-k-vector-search-using-a-vertex-embedding-as-the-query-vector","title":"Top-k Vector Search Using a Vertex Embedding as the Query Vector","text":"<p>This code performs a top-k vector search for similar nodes to a specified node \"Scott\". It searches within the \"Account\" node type using the \"emb1\" embedding attribute and retrieves the top 2 similar node.</p> <pre><code>&gt;&gt;&gt; G.search_top_k_similar_nodes(\n...     node_id=\"Scott\",\n...     vector_attribute_name=\"emb1\",\n...     node_type=\"Account\",\n...     limit=2\n... )\n</code></pre> <pre><code>[{'id': 'Paul', 'distance': 0.3933879, 'name': 'Paul', 'isBlocked': False},\n {'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}]\n</code></pre>"},{"location":"getting_started/quick_start_both/#top-k-vector-search-with-specified-candidates","title":"Top-k Vector Search with Specified Candidates","text":"<p>This code performs a top-2 vector search on the \"Account\" node type using the \"emb1\" embedding attribute. It limits the search to the specified candidate nodes: \"Jenny\", \"Steven\", and \"Ed\".</p> <pre><code>&gt;&gt;&gt; results = G.search(\n...     data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n...     vector_attribute_name=\"emb1\",\n...     node_type=\"Account\",\n...     limit=2,\n...     candidate_ids=[\"Jenny\", \"Steven\", \"Ed\"]\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n</code></pre> <pre><code>{'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}\n{'id': 'Jenny', 'distance': 0.5804119, 'name': 'Jenny', 'isBlocked': False}\n</code></pre>"},{"location":"getting_started/quick_start_both/#filtered-vector-search","title":"Filtered Vector Search","text":"<p>Let's first retrieves all \"Account\" nodes where the isBlocked attribute is False and returns their name attributes in a Pandas DataFrame.</p> <pre><code>&gt;&gt;&gt; nodes_df = G.get_nodes(\n...     node_type=\"Account\",\n...     node_alias=\"s\", # The alias \"s\" is used in filter_expression. You can remove this line since the default node alias is \"s\"\n...     filter_expression='s.isBlocked == False AND s.name != \"Ed\"',\n...     return_attributes=[\"name\"],\n... )\n&gt;&gt;&gt; print(nodes_df)\n</code></pre> <pre><code>    name\n0  Scott\n1   Paul\n2  Jenny\n</code></pre> <p>Then convert the name column of the retrieved DataFrame into a set of candidate IDs and performs a top-2 vector search on the \"Account\" node type using the \"emb1\" embedding attribute, restricted to the specified candidate IDs.</p> <pre><code>&gt;&gt;&gt; candidate_ids = set(nodes_df['name'])\n... results = G.search(\n...     data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n...     vector_attribute_name=\"emb1\",\n...     node_type=\"Account\",\n...     limit=2,\n...     candidate_ids=candidate_ids\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n</code></pre> <pre><code>{'id': 'Paul', 'distance': 0.393388, 'name': 'Paul', 'isBlocked': False}\n{'id': 'Scott', 'distance': 0, 'name': 'Scott', 'isBlocked': False}\n</code></pre>"},{"location":"getting_started/quick_start_both/#clear-and-drop-a-graph","title":"Clear and Drop a Graph","text":""},{"location":"getting_started/quick_start_both/#clear-the-graph","title":"Clear the Graph","text":"<p>To clear the data in the graph without dropping it, use the following code:</p> <pre><code>&gt;&gt;&gt; print(G.clear())\n</code></pre> <pre><code>True\n</code></pre> <p>Afterwards, you can confirm that there are no nodes in the graph by checking:</p> <pre><code>&gt;&gt;&gt; print(G.number_of_nodes())\n</code></pre> <pre><code>0\n</code></pre>"},{"location":"getting_started/quick_start_both/#drop-the-graph","title":"Drop the Graph","text":"<p>To clear the data and completely remove the graph\u2014including schema, loading jobs, and queries\u2014use the following code:</p> <pre><code>&gt;&gt;&gt; G.drop_graph()\n</code></pre> <pre><code>2025-02-28 14:22:33,656 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: FinancialGraph...\n2025-02-28 14:22:36,658 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n</code></pre>"},{"location":"getting_started/quick_start_both/#whats-next","title":"What\u2019s Next?","text":"<p>Now that you've learned how to use TigerGraph for storing both graph data and vectors, you can dive into more advanced features of TigerGraphX:</p> <ul> <li>GraphRAG Overview: Learn about integrating graphs with LLMs.</li> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/quick_start_graph/","title":"TigerGraphX Quick Start: Using TigerGraph as Graph Database","text":"<p>Follow this guide to quickly set up TigerGraphX and build your first graph. This guide assumes that you have already installed TigerGraphX and its dependencies as described in the Installation Guide.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from quick_start_graph.ipynb.</p>"},{"location":"getting_started/quick_start_graph/#create-a-graph","title":"Create a Graph","text":""},{"location":"getting_started/quick_start_graph/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration","text":"<p>Since our data is stored in a TigerGraph instance\u2014whether on-premise or in the cloud\u2014we need to configure the connection settings. The recommended approach is to use environment variables, such as setting them with the <code>export</code> command in the shell. Here, to illustrate the demo, we configure them within Python using the <code>os.environ</code> method. You can find more methods for configuring connection settings in Graph.__init__.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ[\"TG_HOST\"] = \"http://127.0.0.1\"\n&gt;&gt;&gt; os.environ[\"TG_USERNAME\"] = \"tigergraph\"\n&gt;&gt;&gt; os.environ[\"TG_PASSWORD\"] = \"tigergraph\"\n</code></pre>"},{"location":"getting_started/quick_start_graph/#define-a-graph-schema","title":"Define a Graph Schema","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we will create a graph named \"Social\" that includes one node type, \"Person,\" and one directed edge type, \"Friendship.\" Note that you must define the primary key for each node type, indicate whether an edge type is directed or undirected, and specify the source and target node types for each edge type.</p> <pre><code>&gt;&gt;&gt; graph_schema = {\n...     \"graph_name\": \"Social\",\n...     \"nodes\": {\n...         \"Person\": {\n...             \"primary_key\": \"name\",\n...             \"attributes\": {\n...                 \"name\": \"STRING\",\n...                 \"age\": \"UINT\",\n...                 \"gender\": \"STRING\",\n...             },\n...         },\n...     },\n...     \"edges\": {\n...         \"Friendship\": {\n...             \"is_directed_edge\": False,\n...             \"from_node_type\": \"Person\",\n...             \"to_node_type\": \"Person\",\n...             \"attributes\": {\n...                 \"closeness\": \"DOUBLE\",\n...             },\n...         },\n...     },\n... }\n</code></pre> <p>TigerGraphX offers several methods to define the schema, including a Python dictionary, YAML file, or JSON file. Above is an example using a Python dictionary. For other methods, please refer to Graph.__init__ for more details.</p>"},{"location":"getting_started/quick_start_graph/#create-a-graph_1","title":"Create a Graph","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p> <pre><code>&gt;&gt;&gt; from tigergraphx import Graph\n&gt;&gt;&gt; G = Graph(graph_schema)\n</code></pre> <pre><code>2025-02-27 17:21:21,632 - tigergraphx.core.managers.schema_manager - INFO - Creating schema for graph: Social...\n2025-02-27 17:21:25,763 - tigergraphx.core.managers.schema_manager - INFO - Graph schema created successfully.\n</code></pre>"},{"location":"getting_started/quick_start_graph/#retrieve-a-graph-and-print-its-schema","title":"Retrieve a Graph and Print Its Schema","text":"<p>Once a graph has been created in TigerGraph, you can retrieve it without manually defining the schema using the <code>Graph.from_db</code> method, which requires only the graph name:</p> <pre><code>&gt;&gt;&gt; G = Graph.from_db(\"Social\")\n</code></pre> <p>Now, let's print the schema of the graph in a well-formatted manner:</p> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; schema = G.get_schema()\n&gt;&gt;&gt; print(json.dumps(schema, indent=4, default=str))\n</code></pre> <pre><code>{\n    \"graph_name\": \"Social\",\n    \"nodes\": {\n        \"Person\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"age\": {\n                    \"data_type\": \"DataType.UINT\",\n                    \"default_value\": null\n                },\n                \"gender\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                }\n            },\n            \"vector_attributes\": {}\n        }\n    },\n    \"edges\": {\n        \"Friendship\": {\n            \"is_directed_edge\": false,\n            \"from_node_type\": \"Person\",\n            \"to_node_type\": \"Person\",\n            \"discriminator\": \"set()\",\n            \"attributes\": {\n                \"closeness\": {\n                    \"data_type\": \"DataType.DOUBLE\",\n                    \"default_value\": null\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"getting_started/quick_start_graph/#nodes-and-edges","title":"Nodes and Edges","text":""},{"location":"getting_started/quick_start_graph/#adding-nodes-and-edges","title":"Adding Nodes and Edges","text":"<p>TigerGraphX provides NetworkX-like methods for node operations, edge operations, and statistical analysis. You can find the full API reference in the Graph class reference.</p> <p>To add nodes or edges individually, use the following code:</p> <pre><code>&gt;&gt;&gt; G.add_node(\"Emily\", age=25, gender=\"Female\")\n&gt;&gt;&gt; G.add_node(\"John\", age=28, gender=\"Male\")\n&gt;&gt;&gt; G.add_edge(\"Emily\", \"John\", closeness=0.98)\n</code></pre> <p>While this method is simple, it adds nodes and edges one by one. Alternatively, you can use <code>add_nodes_from</code> and <code>add_edges_from</code> to add them in small batches. The following example demonstrates how to add multiple nodes at once:</p> <pre><code>&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Michael\", {\"age\": 29}),\n...    (\"Victor\", {\"age\": 31, \"gender\": \"Male\"}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding)\n</code></pre> <pre><code>3\n</code></pre> <p>Next, let's add edges with individual attributes using tuples in the format <code>(source ID, target ID, attribute_dict)</code>.</p> <pre><code>&gt;&gt;&gt; ebunch_to_add = [\n...    (\"Alice\", \"Michael\"),\n...    (\"Alice\", \"John\", {\"closeness\": 2.5}),\n...    (\"Emily\", \"Victor\", {\"closeness\": 1.5}),\n... ]\n&gt;&gt;&gt; G.add_edges_from(ebunch_to_add)\n</code></pre> <pre><code>3\n</code></pre> <p>For larger datasets, consider using load_data for efficient handling of large-scale data.</p>"},{"location":"getting_started/quick_start_graph/#check-if-nodes-and-edges-exist","title":"Check if Nodes and Edges Exist","text":"<pre><code>&gt;&gt;&gt; print(G.has_node(\"Alice\"))\n</code></pre> <pre><code>True\n</code></pre> <pre><code>&gt;&gt;&gt; print(G.has_node(\"Michael\"))\n</code></pre> <pre><code>True\n</code></pre> <p>Since the 'Friendship' edge is undirected, both 'Alice -&gt; Michael' and 'Michael -&gt; Alice' are valid and accessible.</p> <pre><code>&gt;&gt;&gt; print(G.has_edge(\"Alice\", \"Michael\"))\n</code></pre> <pre><code>True\n</code></pre> <pre><code>&gt;&gt;&gt; print(G.has_edge(\"Michael\", \"Alice\"))\n</code></pre> <pre><code>True\n</code></pre>"},{"location":"getting_started/quick_start_graph/#display-node-and-edge-attributes","title":"Display Node and Edge Attributes","text":""},{"location":"getting_started/quick_start_graph/#display-node-attributes","title":"Display Node Attributes","text":"<p>To display all attributes of a given node, use the following command:</p> <pre><code>&gt;&gt;&gt; print(G.nodes[\"Alice\"])\n</code></pre> <pre><code>{'name': 'Alice', 'age': 30, 'gender': 'Female'}\n</code></pre> <p>To display a specific attribute, use the command below:</p> <pre><code>&gt;&gt;&gt; print(G.nodes[\"Michael\"][\"age\"])\n</code></pre> <pre><code>29\n</code></pre>"},{"location":"getting_started/quick_start_graph/#display-edge-attributes","title":"Display Edge Attributes","text":"<pre><code>&gt;&gt;&gt; print(G.get_edge_data(\"Alice\", \"John\"))\n</code></pre> <pre><code>{'closeness': 2.5}\n</code></pre>"},{"location":"getting_started/quick_start_graph/#display-the-degree-of-nodes","title":"Display the Degree of Nodes","text":"<p>To display the degree of a given node, use the following command:</p> <pre><code>&gt;&gt;&gt; print(G.degree(\"Alice\"))\n</code></pre> <pre><code>2\n</code></pre>"},{"location":"getting_started/quick_start_graph/#query-operations","title":"Query Operations","text":""},{"location":"getting_started/quick_start_graph/#retrieve-nodes","title":"Retrieve Nodes","text":"<p>Retrieve \"Person\" nodes that match a specific filter expression, use a custom alias, request only selected attributes, and limit the results:</p> <pre><code>&gt;&gt;&gt; df = G.get_nodes(\n...     node_type=\"Person\",\n...     node_alias=\"s\", # \"s\" is the default value, so you can remove this line\n...     filter_expression=\"s.age &gt;= 29\",\n...     return_attributes=[\"name\", \"age\"],\n...     limit=1\n... )\n&gt;&gt;&gt; print(df)\n</code></pre> <pre><code>     name  age\n0  Victor   31\n</code></pre>"},{"location":"getting_started/quick_start_graph/#retrieve-a-nodes-neighbors","title":"Retrieve a Node's Neighbors","text":"<p>Retrieve the first \"Person\" node that is a friend of Alice, filtering edges where closeness &gt; 1 and returning the target node's \"name\" and \"gender\" attributes:</p> <pre><code>&gt;&gt;&gt; df = G.get_neighbors(\n...     start_nodes=\"Alice\",\n...     start_node_type=\"Person\",\n...     edge_types=\"Friendship\",\n...     target_node_types=\"Person\",\n...     filter_expression=\"e.closeness &gt; 1\",\n...     return_attributes=[\"name\", \"gender\"],\n...     limit=1,\n... )\n&gt;&gt;&gt; print(df)\n</code></pre> <pre><code>   name gender\n0  John   Male\n</code></pre> <p>Note that the result of <code>get_neighbors</code> is a Pandas DataFrame.</p> <pre><code>&gt;&gt;&gt; print(type(df))\n</code></pre> <pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;\n</code></pre>"},{"location":"getting_started/quick_start_graph/#breadth-first-search","title":"Breadth First Search","text":"<p>Below is an example of multi-hop neighbor traversal:</p> <pre><code>&gt;&gt;&gt; # First hop: Retrieve neighbors of \"Alice\" of type \"Person\"\n&gt;&gt;&gt; visited = set([\"Alice\"])  # Track visited nodes\n&gt;&gt;&gt; df = G.get_neighbors(start_nodes=\"Alice\", start_node_type=\"Person\")\n&gt;&gt;&gt; primary_ids = set(df['name']) - visited  # Exclude already visited nodes\n&gt;&gt;&gt; print(primary_ids)\n</code></pre> <pre><code>{'John', 'Michael'}\n</code></pre> <pre><code>&gt;&gt;&gt; # Second hop: Retrieve neighbors of the nodes identified in the first hop\n&gt;&gt;&gt; visited.update(primary_ids)  # Mark these nodes as visited\n&gt;&gt;&gt; df = G.get_neighbors(start_nodes=primary_ids, start_node_type=\"Person\")\n&gt;&gt;&gt; primary_ids = set(df['name']) - visited  # Exclude visited nodes\n&gt;&gt;&gt; print(primary_ids)\n</code></pre> <pre><code>{'Emily'}\n</code></pre> <pre><code>&gt;&gt;&gt; # Third hop: Retrieve neighbors of the nodes identified in the second hop\n&gt;&gt;&gt; visited.update(primary_ids)  # Mark these nodes as visited\n&gt;&gt;&gt; df = G.get_neighbors(start_nodes=primary_ids, start_node_type=\"Person\")\n&gt;&gt;&gt; df = df[~df['name'].isin(visited)]  # Remove visited nodes from the final result\n&gt;&gt;&gt; print(df)\n</code></pre> <pre><code>  gender    name  age\n0   Male  Victor   31\n</code></pre> <p>Alternatively, you can also use the built-in <code>bfs</code> method.</p> <pre><code>&gt;&gt;&gt; df = G.bfs(start_nodes=[\"Alice\"], node_type=\"Person\", max_hops=3)\n&gt;&gt;&gt; print(df)\n</code></pre> <pre><code>  gender    name  age\n0   Male  Victor   31\n</code></pre>"},{"location":"getting_started/quick_start_graph/#graph-statistics","title":"Graph Statistics","text":""},{"location":"getting_started/quick_start_graph/#display-the-number-of-nodes","title":"Display the Number of Nodes","text":"<pre><code>&gt;&gt;&gt; print(G.number_of_nodes())\n</code></pre> <pre><code>5\n</code></pre>"},{"location":"getting_started/quick_start_graph/#display-the-number-of-edges","title":"Display the Number of Edges","text":"<pre><code>&gt;&gt;&gt; print(G.number_of_edges())\n</code></pre> <pre><code>4\n</code></pre>"},{"location":"getting_started/quick_start_graph/#clear-and-drop-a-graph","title":"Clear and Drop a Graph","text":""},{"location":"getting_started/quick_start_graph/#clear-the-graph","title":"Clear the Graph","text":"<p>To clear the data in the graph without dropping it, use the following code:</p> <pre><code>&gt;&gt;&gt; print(G.clear())\n</code></pre> <pre><code>True\n</code></pre> <p>Afterwards, you can confirm that there are no nodes in the graph by checking:</p> <pre><code>&gt;&gt;&gt; print(G.number_of_nodes())\n</code></pre> <pre><code>0\n</code></pre>"},{"location":"getting_started/quick_start_graph/#drop-the-graph","title":"Drop the Graph","text":"<p>To clear the data and completely remove the graph\u2014including schema, loading jobs, and queries\u2014use the following code:</p> <pre><code>&gt;&gt;&gt; G.drop_graph()\n</code></pre> <pre><code>2025-02-27 17:21:57,607 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: Social...\n2025-02-27 17:22:00,482 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n</code></pre>"},{"location":"getting_started/quick_start_graph/#whats-next","title":"What\u2019s Next?","text":"<p>Now that you've set up your graph storage and performed basic operations, you can explore more advanced features of TigerGraphX:</p> <ul> <li>TigerGraph Quick Start Guide for Vector Storage: Quickly get started with TigerGraph for storing vector data.</li> <li>API Reference: Dive deeper into TigerGraphX APIs to understand its full capabilities.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/quick_start_vector/","title":"TigerGraphX Quick Start: Using TigerGraph as Vector Database","text":"<p>TigerGraph has supported vector storage since version 4.2. In this guide, we will demonstrate how to use TigerGraph as a pure vector database, without storing edges. This setup can be useful when you want to leverage TigerGraph solely as a vector database. However, to fully unlock the potential of TigerGraph, you can also use it as both a graph and vector storage solution. For more details, refer to the next guide.</p> <p>This guide assumes that you have already installed TigerGraphX and its dependencies, as outlined in the Installation Guide.</p> <p>To run this Jupyter Notebook, download the original <code>.ipynb</code> file from quick_start_vector.ipynb.</p>"},{"location":"getting_started/quick_start_vector/#create-a-graph","title":"Create a Graph","text":""},{"location":"getting_started/quick_start_vector/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration","text":"<p>Since our data is stored in a TigerGraph instance\u2014whether on-premise or in the cloud\u2014we need to configure the connection settings. The recommended approach is to use environment variables, such as setting them with the <code>export</code> command in the shell. Here, to illustrate the demo, we configure them within Python using the <code>os.environ</code> method. You can find more methods for configuring connection settings in Graph.__init__.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ[\"TG_HOST\"] = \"http://127.0.0.1\"\n&gt;&gt;&gt; os.environ[\"TG_USERNAME\"] = \"tigergraph\"\n&gt;&gt;&gt; os.environ[\"TG_PASSWORD\"] = \"tigergraph\"\n</code></pre>"},{"location":"getting_started/quick_start_vector/#define-a-graph-schema","title":"Define a Graph Schema","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. A typical schema includes the graph name, nodes (vertices), edges (relationships), and their respective attributes. However, when using TigerGraph as a pure vector database, you only need to define the graph name, the node (vertex) type, and its attributes, including vector attributes.</p> <p>In this example, we create a graph called \"FinancialGraph\" with one node type: \"Account.\" This node type has a primary key <code>name</code>, attributes <code>name</code> (string) and <code>isBlocked</code> (boolean), and a vector attribute <code>emb1</code> (3-dimensional).</p> <pre><code>&gt;&gt;&gt; graph_schema = {\n...     \"graph_name\": \"FinancialGraph\",\n...     \"nodes\": {\n...         \"Account\": {\n...             \"primary_key\": \"name\",\n...             \"attributes\": {\n...                 \"name\": \"STRING\",\n...                 \"isBlocked\": \"BOOL\",\n...             },\n...             \"vector_attributes\": {\"emb1\": 3},\n...         },\n...     },\n...     \"edges\": {}\n... }\n</code></pre> <p>TigerGraphX offers several methods to define the schema, including a Python dictionary, YAML file, or JSON file. Above is an example using a Python dictionary. For other methods, please refer to Graph.__init__ for more details.</p>"},{"location":"getting_started/quick_start_vector/#create-a-graph_1","title":"Create a Graph","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p> <pre><code>&gt;&gt;&gt; from tigergraphx import Graph\n&gt;&gt;&gt; G = Graph(graph_schema)\n</code></pre> <pre><code>2025-02-27 17:35:49,124 - tigergraphx.core.managers.schema_manager - INFO - Creating schema for graph: FinancialGraph...\n2025-02-27 17:35:52,641 - tigergraphx.core.managers.schema_manager - INFO - Graph schema created successfully.\n2025-02-27 17:35:52,642 - tigergraphx.core.managers.schema_manager - INFO - Adding vector attribute(s) for graph: FinancialGraph...\n2025-02-27 17:36:52,825 - tigergraphx.core.managers.schema_manager - INFO - Vector attribute(s) added successfully.\n</code></pre>"},{"location":"getting_started/quick_start_vector/#retrieve-a-graph-and-print-its-schema","title":"Retrieve a Graph and Print Its Schema","text":"<p>Once a graph has been created in TigerGraph, you can retrieve it without manually defining the schema using the <code>Graph.from_db</code> method, which requires only the graph name:</p> <pre><code>&gt;&gt;&gt; G = Graph.from_db(\"FinancialGraph\")\n</code></pre> <p>Now, let's print the schema of the graph in a well-formatted manner:</p> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; schema = G.get_schema()\n&gt;&gt;&gt; print(json.dumps(schema, indent=4, default=str))\n</code></pre> <pre><code>{\n    \"graph_name\": \"FinancialGraph\",\n    \"nodes\": {\n        \"Account\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"isBlocked\": {\n                    \"data_type\": \"DataType.BOOL\",\n                    \"default_value\": null\n                }\n            },\n            \"vector_attributes\": {\n                \"emb1\": {\n                    \"dimension\": 3,\n                    \"index_type\": \"HNSW\",\n                    \"data_type\": \"FLOAT\",\n                    \"metric\": \"COSINE\"\n                }\n            }\n        }\n    },\n    \"edges\": {}\n}\n</code></pre>"},{"location":"getting_started/quick_start_vector/#add-nodes","title":"Add Nodes","text":"<p>In this example, we add multiple nodes representing accounts to the graph. Each node is uniquely identified by a name and comes with two attributes:</p> <ul> <li>isBlocked: A Boolean indicating whether the account is blocked.</li> <li>emb1: A three-dimensional embedding vector.</li> </ul> <pre><code>&gt;&gt;&gt; nodes_for_adding = [\n...     (\"Scott\", {\"isBlocked\": False, \"emb1\": [-0.017733968794345856, -0.01019224338233471, -0.016571875661611557]}),\n...     (\"Jenny\", {\"isBlocked\": False, \"emb1\": [-0.019265105947852135, 0.0004929182468913496, 0.006711316294968128]}),\n...     (\"Steven\", {\"isBlocked\": True, \"emb1\": [-0.01505514420568943, -0.016819344833493233, -0.0221870020031929]}),\n...     (\"Paul\", {\"isBlocked\": False, \"emb1\": [0.0011193430982530117, -0.001038988004438579, -0.017158523201942444]}),\n...     (\"Ed\", {\"isBlocked\": False, \"emb1\": [-0.003692442551255226, 0.010494389571249485, -0.004631792660802603]}),\n... ]\n&gt;&gt;&gt; print(\"Number of Account Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"Account\"))\n</code></pre> <pre><code>Number of Account Nodes Inserted: 5\n</code></pre> <p>For larger datasets, consider using load_data for efficient handling of large-scale data.</p>"},{"location":"getting_started/quick_start_vector/#exploring-nodes-in-the-graph","title":"Exploring Nodes in the Graph","text":""},{"location":"getting_started/quick_start_vector/#display-the-number-of-nodes","title":"Display the Number of Nodes","text":"<p>Next, let's verify that the data has been inserted into the graph by using the following command. As expected, the number of nodes is 5.</p> <pre><code>&gt;&gt;&gt; print(G.number_of_nodes())\n</code></pre> <pre><code>5\n</code></pre>"},{"location":"getting_started/quick_start_vector/#check-if-nodes-exist","title":"Check if Nodes Exist","text":"<p>Use the following commands to check whether specific nodes are present in the graph:</p> <pre><code>&gt;&gt;&gt; print(G.has_node(\"Scott\"))\n</code></pre> <pre><code>True\n</code></pre> <pre><code>&gt;&gt;&gt; print(G.has_node(\"Jenny\"))\n</code></pre> <pre><code>True\n</code></pre>"},{"location":"getting_started/quick_start_vector/#display-node-attributes","title":"Display Node Attributes","text":"<p>To display all attributes of a given node, use the following command:</p> <pre><code>&gt;&gt;&gt; print(G.nodes[\"Scott\"])\n</code></pre> <pre><code>{'name': 'Scott', 'isBlocked': False}\n</code></pre> <p>To display a specific attribute, use the command below:</p> <pre><code>&gt;&gt;&gt; print(G.nodes[\"Scott\"][\"isBlocked\"])\n</code></pre> <pre><code>False\n</code></pre>"},{"location":"getting_started/quick_start_vector/#filter-the-nodes","title":"Filter the Nodes","text":"<p>Retrieve \"Account\" nodes that match a specific filter expression, request only selected attributes, and limit the results:</p> <pre><code>&gt;&gt;&gt; df = G.get_nodes(\n...     node_type=\"Account\",\n...     node_alias=\"s\", # \"s\" is the default value, so you can remove this line\n...     filter_expression=\"s.isBlocked == False\",\n...     return_attributes=[\"name\", \"isBlocked\"],\n...     limit=2\n... )\n&gt;&gt;&gt; print(df)\n</code></pre> <pre><code>    name  isBlocked\n0   Paul      False\n1  Scott      False\n</code></pre>"},{"location":"getting_started/quick_start_vector/#display-nodes-vector-attributes","title":"Display Node's Vector Attributes","text":"<p>Retrieve the vector attribute of a specific node:</p> <pre><code>&gt;&gt;&gt; vector = G.fetch_node(\n...     node_id=\"Scott\",\n...     vector_attribute_name=\"emb1\",\n... )\n&gt;&gt;&gt; print(vector)\n</code></pre> <pre><code>[-0.01773397, -0.01019224, -0.01657188]\n</code></pre> <p>Retrieve vector attributes for multiple nodes:</p> <pre><code>&gt;&gt;&gt; vectors = G.fetch_nodes(\n...     node_ids=[\"Scott\", \"Jenny\"],\n...     vector_attribute_name=\"emb1\",\n... )\n&gt;&gt;&gt; for vector in vectors.items():\n...     print(vector)\n</code></pre> <pre><code>('Scott', [-0.01773397, -0.01019224, -0.01657188])\n('Jenny', [-0.01926511, 0.0004929182, 0.006711317])\n</code></pre>"},{"location":"getting_started/quick_start_vector/#perform-vector-search","title":"Perform Vector Search","text":""},{"location":"getting_started/quick_start_vector/#top-k-vector-search-on-a-given-vertex-types-vector-attribute","title":"Top-k Vector Search on a Given Vertex Type's Vector Attribute","text":"<p>To find the top 2 most similar accounts to \"Scott\" based on the embedding, we use the following code. As expected, \"Scott\" will appear in the list with a distance of 0.</p> <pre><code>&gt;&gt;&gt; results = G.search(\n...    data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n...    vector_attribute_name=\"emb1\",\n...    node_type=\"Account\",\n...    limit=2\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n</code></pre> <pre><code>{'id': 'Scott', 'distance': 0, 'name': 'Scott', 'isBlocked': False}\n{'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}\n</code></pre>"},{"location":"getting_started/quick_start_vector/#top-k-vector-search-using-a-vertex-embedding-as-the-query-vector","title":"Top-k Vector Search Using a Vertex Embedding as the Query Vector","text":"<p>This code performs a top-k vector search for similar nodes to a specified node \"Scott\". It searches within the \"Account\" node type using the \"emb1\" embedding attribute and retrieves the top 2 similar node.</p> <pre><code>&gt;&gt;&gt; results = G.search_top_k_similar_nodes(\n...     node_id=\"Scott\",\n...     vector_attribute_name=\"emb1\",\n...     node_type=\"Account\",\n...     limit=2\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n</code></pre> <pre><code>{'id': 'Paul', 'distance': 0.3933879, 'name': 'Paul', 'isBlocked': False}\n{'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}\n</code></pre>"},{"location":"getting_started/quick_start_vector/#top-k-vector-search-with-specified-candidates","title":"Top-k Vector Search with Specified Candidates","text":"<p>This code performs a top-2 vector search on the \"Account\" node type using the \"emb1\" embedding attribute. It limits the search to the specified candidate nodes: \"Jenny\", \"Steven\", and \"Ed\".</p> <pre><code>&gt;&gt;&gt; results = G.search(\n...     data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n...     vector_attribute_name=\"emb1\",\n...     node_type=\"Account\",\n...     limit=2,\n...     candidate_ids=[\"Jenny\", \"Steven\", \"Ed\"]\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n</code></pre> <pre><code>{'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}\n{'id': 'Jenny', 'distance': 0.5804119, 'name': 'Jenny', 'isBlocked': False}\n</code></pre>"},{"location":"getting_started/quick_start_vector/#filtered-vector-search","title":"Filtered Vector Search","text":"<p>Let's first retrieves all \"Account\" nodes where the isBlocked attribute is False and returns their name attributes in a Pandas DataFrame.</p> <pre><code>&gt;&gt;&gt; nodes_df = G.get_nodes(\n...     node_type=\"Account\",\n...     node_alias=\"s\", # The alias \"s\" is used in filter_expression. You can remove this line since the default node alias is \"s\"\n...     filter_expression='s.isBlocked == False AND s.name != \"Ed\"',\n...     return_attributes=[\"name\"],\n... )\n&gt;&gt;&gt; print(nodes_df)\n</code></pre> <pre><code>    name\n0   Paul\n1  Scott\n2  Jenny\n</code></pre> <p>Then convert the name column of the retrieved DataFrame into a set of candidate IDs and performs a top-2 vector search on the \"Account\" node type using the \"emb1\" embedding attribute, restricted to the specified candidate IDs.</p> <pre><code>&gt;&gt;&gt; candidate_ids = set(nodes_df['name'])\n... results = G.search(\n...     data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n...     vector_attribute_name=\"emb1\",\n...     node_type=\"Account\",\n...     limit=2,\n...     candidate_ids=candidate_ids\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n</code></pre> <pre><code>{'id': 'Paul', 'distance': 0.393388, 'name': 'Paul', 'isBlocked': False}\n{'id': 'Scott', 'distance': 0, 'name': 'Scott', 'isBlocked': False}\n</code></pre>"},{"location":"getting_started/quick_start_vector/#clear-and-drop-a-graph","title":"Clear and Drop a Graph","text":""},{"location":"getting_started/quick_start_vector/#clear-the-graph","title":"Clear the Graph","text":"<p>To clear the data in the graph without dropping it, use the following code:</p> <pre><code>&gt;&gt;&gt; print(G.clear())\n</code></pre> <pre><code>True\n</code></pre> <p>Afterwards, you can confirm that there are no nodes in the graph by checking:</p> <pre><code>&gt;&gt;&gt; print(G.number_of_nodes())\n</code></pre> <pre><code>0\n</code></pre>"},{"location":"getting_started/quick_start_vector/#drop-the-graph","title":"Drop the Graph","text":"<p>To clear the data and completely remove the graph\u2014including schema, loading jobs, and queries\u2014use the following code:</p> <pre><code>&gt;&gt;&gt; G.drop_graph()\n</code></pre> <pre><code>2025-02-27 17:38:44,545 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: FinancialGraph...\n2025-02-27 17:38:47,882 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n</code></pre>"},{"location":"getting_started/quick_start_vector/#whats-next","title":"What\u2019s Next?","text":"<p>Now that you've learned how to use TigerGraph for storing both graph data and vectors, you can dive into more advanced features of TigerGraphX:</p> <ul> <li>GraphRAG Overview: Learn about integrating graphs with LLMs.</li> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"graphrag/graphrag_overview/","title":"TigerGraph: Unlocking the Potential of GraphRAG","text":""},{"location":"graphrag/graphrag_overview/#overview","title":"Overview","text":"<p>TigerGraph is a highly scalable and efficient graph database, making it the ideal foundation for advanced GraphRAG workflows. It excels in handling both graph and vector data, enabling seamless integration and performance at scale. With built-in support for complex queries, multi-hop traversals, and real-time analytics, TigerGraph ensures fast and reliable results. Its versatility and performance make it the ideal choice for powering data-intensive workflows, while TigerGraphX simplifies access with a Python-native interface.</p> <p></p>"},{"location":"graphrag/graphrag_overview/#why-tigergraph-for-graphrag","title":"Why TigerGraph for GraphRAG?","text":""},{"location":"graphrag/graphrag_overview/#1-scalability-and-performance","title":"1. Scalability and Performance","text":"<p>TigerGraph excels in handling massive datasets with high-speed multi-hop queries and vector search capabilities. It is ideal for real-world GraphRAG applications that demand extensive and efficient data processing.</p>"},{"location":"graphrag/graphrag_overview/#2-unified-graph-and-vector-data-support","title":"2. Unified Graph and Vector Data Support","text":"<p>With native support for schema-defined nodes, edges, and vectors, TigerGraph streamlines data integration. Its advanced query optimization enables efficient graph traversal and vector-based retrieval, which is perfectly suited for LLM workflows.</p>"},{"location":"graphrag/graphrag_overview/#3-cost-effectiveness","title":"3. Cost-Effectiveness","text":"<p>TigerGraph reduces computational overhead through optimized queries and highly efficient storage, significantly cutting infrastructure costs while maintaining top-tier performance.</p>"},{"location":"graphrag/graphrag_overview/#4-flexibility-and-hybrid-integration","title":"4. Flexibility and Hybrid Integration","text":"<p>Seamlessly combines structured, semantic, and vector-based retrieval methods in one unified platform. Its compatibility with vector search and LLMs enables advanced hybrid retrieval strategies, unlocking new possibilities for GraphRAG workflows.</p>"},{"location":"graphrag/graphrag_overview/#graphrag-workflow-with-tigergraph","title":"GraphRAG Workflow with TigerGraph","text":""},{"location":"graphrag/graphrag_overview/#1-schema-design","title":"1. Schema Design","text":"<p>Define the graph schema with nodes, edges, and attributes tailored to your application, leveraging TigerGraph\u2019s native support for structured graph data.</p>"},{"location":"graphrag/graphrag_overview/#2-data-preparation-and-loading","title":"2. Data Preparation and Loading","text":"<p>Transform raw data into TigerGraph-compatible formats, including graph structures and embeddings, and load it efficiently into TigerGraph using TigerGraphX.</p>"},{"location":"graphrag/graphrag_overview/#3-knowledge-graph-management-and-analysis","title":"3. Knowledge Graph Management and Analysis","text":"<p>Maintain and enhance the knowledge graph to ensure data quality, relevance, and scalability. Perform in-depth analysis to uncover patterns, infer insights, and optimize data retrieval strategies; ensure the knowledge graph remains a dynamic, accurate, and actionable source of information, enriching context for LLMs while supporting explainability and scalability in the GraphRAG workflow.</p>"},{"location":"graphrag/graphrag_overview/#4-hybrid-retrieval","title":"4. Hybrid Retrieval","text":"<p>Combine structured queries, semantic search, and vector-based methods to fetch relevant data and embeddings from TigerGraph for context construction.</p>"},{"location":"graphrag/graphrag_overview/#5-context-building","title":"5. Context Building","text":"<p>Use TigerGraphX to process retrieved data, making it token-aware and formatted to meet the requirements of LLMs.</p>"},{"location":"graphrag/graphrag_overview/#6-llm-integration","title":"6. LLM Integration","text":"<p>Pass the context to an LLM to generate responses, enabling advanced GraphRAG workflows with seamless data flow and high efficiency.</p>"},{"location":"graphrag/graphrag_overview/#three-options-for-implementing-graphrag-with-tigergraph","title":"Three Options for Implementing GraphRAG with TigerGraph","text":"<p>There are three approaches to implementing GraphRAG with TigerGraph.</p>"},{"location":"graphrag/graphrag_overview/#1-tigergraph-as-a-storage-and-retrieval-engine","title":"1. TigerGraph as a Storage and Retrieval Engine","text":"<p>The first approach primarily utilizes TigerGraph for storing and retrieving graph/vector data. TigerGraphX provides interfaces similar to NetworkX, allowing seamless integration with GraphRAG applications. This approach is recommended for GraphRAG solutions like LightRAG and Nano-GraphRAG, which abstract their storage layers (e.g., graph storage, key-value storage, and vector storage). Here, you only need to implement these layers in a way that aligns with TigerGraph.</p>"},{"location":"graphrag/graphrag_overview/#2-tigergraph-for-storage-and-retrieval-tigergraphx-for-llm-tasks","title":"2. TigerGraph for Storage and Retrieval; TigerGraphX for LLM Tasks","text":"<p>The second approach extends beyond storage and retrieval by leveraging TigerGraphX for tasks related to large language models (LLMs), such as chat or embedding generation. This approach is suitable for complex projects like Microsoft's GraphRAG. As of December 2024, Microsoft's GraphRAG has not yet abstracted its storage layer, making it challenging to replace the indexing process. However, TigerGraphX can be used to convert the results of the indexing process (e.g., Parquet files) into a format supported by TigerGraph. These results can then be imported into TigerGraph, and TigerGraphX can handle the querying process without relying on Microsoft\u2019s GraphRAG.</p>"},{"location":"graphrag/graphrag_overview/#3-fully-integrated-tigergraphx-solution-for-graphrag","title":"3. Fully Integrated TigerGraphX Solution for GraphRAG","text":"<p>The third approach eliminates dependencies on external GraphRAG frameworks by fully utilizing TigerGraphX for both retrieval and LLM-related tasks. Instead of relying on solutions like LightRAG or Microsoft's GraphRAG, this method directly integrates TigerGraphX as an interface for LLMs. This approach simplifies deployment, reduces integration complexity, and ensures full compatibility with TigerGraph\u2019s ecosystem. By leveraging TigerGraphX for both vector storage and LLM interactions, users can build a streamlined, end-to-end GraphRAG pipeline within a single framework.</p>"},{"location":"graphrag/graphrag_overview/#demonstrations","title":"Demonstrations","text":"<p>All three methods are demonstrated on the following pages, each with a real-world project:</p> <ul> <li>LightRAG: Refer to LightRAG for the first approach.</li> <li>Microsoft's GraphRAG: Refer to Microsoft GraphRAG: Part 1 for the second approach.</li> <li>Fully Integrated TigerGraphX Solution: Refer to Simple GraphRAG: Part 1 for the second approach.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/lightrag/","title":"Supporting LightRAG","text":"<p>LightRAG is an open-source RAG system that enhances LLMs by integrating graph-based structures into text indexing and retrieval. It overcomes the limitations of traditional RAG systems, such as fragmented answers and weak contextual awareness, by enabling dual-level retrieval for more comprehensive knowledge discovery. With support for incremental data updates, LightRAG ensures timely integration of new information while delivering improved retrieval accuracy and efficiency.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from lightrag.ipynb.</p>"},{"location":"graphrag/lightrag/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Before proceeding, complete the installation and setup steps outlined in the Installation Guide, including:</p> </li> <li> <p>Setting up Python and TigerGraph. See the Requirements section for details.</p> </li> <li>Installing TigerGraphX and its development dependencies. See the Development Installation section.</li> <li>Setting the required environment variables:  </li> </ul> <pre><code>export TG_HOST=https://127.0.0.1\nexport TG_USERNAME=tigergraph\nexport TG_PASSWORD=tigergraph\nexport OPENAI_API_KEY=&lt;Your OpenAI API Key&gt;\n</code></pre> <p>These variables configure the connection to the TigerGraph server and OpenAI.</p>"},{"location":"graphrag/lightrag/#implementing-graph-and-vector-storage-with-tigergraph","title":"Implementing Graph and Vector Storage with TigerGraph","text":"<p>LightRAG abstracts storage into components such as graph storage, key-value storage, and vector storage. You can explore the base classes BaseGraphStorage, BaseVectorStorage, and BaseKVStorage in the source code.</p> <p>This section demonstrates how to use TigerGraphX to implement: 1. <code>BaseGraphStorage</code> for storing and retrieving graph data in TigerGraph. 2. <code>BaseVectorStorage</code> for storing vector data and performing vector searches using TigerGraph's TigerVector feature.</p>"},{"location":"graphrag/lightrag/#implementing-graph-storage-with-tigergraph","title":"Implementing Graph Storage with TigerGraph","text":"<p>The following code defines the <code>TigerGraphStorage</code> class, which interfaces with TigerGraphX to manage graph data in TigerGraph.</p> <pre><code>from dataclasses import dataclass\nfrom typing import Any, Dict\nimport numpy as np\n\nfrom lightrag.base import BaseGraphStorage\nfrom lightrag.utils import logger\n\nfrom tigergraphx import Graph\n\n\n@dataclass\nclass TigerGraphStorage(BaseGraphStorage):\n    def __post_init__(self):\n        try:\n            # Define the graph schema\n            graph_schema = {\n                \"graph_name\": \"LightRAG\",\n                \"nodes\": {\n                    \"Entity\": {\n                        \"primary_key\": \"id\",\n                        \"attributes\": {\n                            \"id\": \"STRING\",\n                            \"entity_type\": \"STRING\",\n                            \"description\": \"STRING\",\n                            \"source_id\": \"STRING\",\n                        },\n                    }\n                },\n                \"edges\": {\n                    \"relationship\": {\n                        \"is_directed_edge\": False,\n                        \"from_node_type\": \"Entity\",\n                        \"to_node_type\": \"Entity\",\n                        \"attributes\": {\n                            \"weight\": \"DOUBLE\",\n                            \"description\": \"STRING\",\n                            \"keywords\": \"STRING\",\n                            \"source_id\": \"STRING\",\n                        },\n                    }\n                },\n            }\n\n            # Initialize the graph\n            self._graph = Graph(graph_schema)\n        except Exception as e:\n            logger.error(f\"An error occurred during initialization: {e}\")\n            raise\n\n    @staticmethod\n    def clean_quotes(value: str) -&gt; str:\n        \"\"\"Remove leading and trailing &amp;quot; from a string if present.\"\"\"\n        if value.startswith('\"') and value.endswith('\"'):\n            return value[1:-1]\n        return value\n\n    async def has_node(self, node_id: str) -&gt; bool:\n        return self._graph.has_node(self.clean_quotes(node_id))\n\n    async def has_edge(self, source_node_id: str, target_node_id: str) -&gt; bool:\n        return self._graph.has_edge(\n            self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)\n        )\n\n    async def node_degree(self, node_id: str) -&gt; int:\n        result = self._graph.degree(self.clean_quotes(node_id))\n        return result\n\n    async def edge_degree(self, src_id: str, tgt_id: str) -&gt; int:\n        return self._graph.degree(self.clean_quotes(src_id)) + self._graph.degree(\n            self.clean_quotes(tgt_id)\n        )\n\n    async def get_node(self, node_id: str) -&gt; dict | None:\n        result = self._graph.get_node_data(self.clean_quotes(node_id))\n        return result\n\n    async def get_edge(self, source_node_id: str, target_node_id: str) -&gt; dict | None:\n        result = self._graph.get_edge_data(\n            self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)\n        )\n        return result\n\n    async def get_node_edges(self, source_node_id: str) -&gt; list[tuple[str, str]] | None:\n        source_node_id = self.clean_quotes(source_node_id)\n        if self._graph.has_node(source_node_id):\n            edges = self._graph.get_node_edges(source_node_id)\n            return list(edges)\n        return None\n\n    async def upsert_node(self, node_id: str, node_data: Dict[str, Any]):\n        node_id = self.clean_quotes(node_id)\n        self._graph.add_node(node_id, **node_data)\n\n    async def upsert_edge(\n        self, source_node_id: str, target_node_id: str, edge_data: Dict[str, Any]\n    ):\n        source_node_id = self.clean_quotes(source_node_id)\n        target_node_id = self.clean_quotes(target_node_id)\n        self._graph.add_edge(source_node_id, target_node_id, **edge_data)\n\n    async def delete_node(self, node_id: str):\n        if self._graph.has_node(node_id):\n            self._graph.remove_node(node_id)\n            logger.info(f\"Node {node_id} deleted from the graph.\")\n        else:\n            logger.warning(f\"Node {node_id} not found in the graph for deletion.\")\n\n    async def embed_nodes(self, algorithm: str) -&gt; tuple[np.ndarray, list[str]]:\n        return np.array([]), []\n</code></pre>"},{"location":"graphrag/lightrag/#key-features","title":"Key Features:","text":"<ol> <li>Graph Schema </li> <li>Defines a node type <code>\"Entity\"</code> with attributes: <code>id</code>, <code>entity_type</code>, <code>description</code>, and <code>source_id</code>.</li> <li> <p>Defines an edge type <code>\"relationship\"</code> with attributes: <code>weight</code>, <code>description</code>, and <code>source_id</code>.</p> </li> <li> <p>Graph Initialization </p> </li> <li> <p>Initializes the graph schema using TigerGraphX.</p> </li> <li> <p>Node and Edge Operations </p> </li> <li>Node Operations:<ul> <li><code>has_node</code>: Checks if a node exists.</li> <li><code>get_node</code>: Retrieves node data.</li> <li><code>upsert_node</code>: Adds or updates a node.</li> <li><code>delete_node</code>: Removes a node.</li> </ul> </li> <li> <p>Edge Operations:</p> <ul> <li><code>has_edge</code>: Checks if an edge exists.</li> <li><code>get_edge</code>: Retrieves edge data.</li> <li><code>upsert_edge</code>: Adds or updates an edge.</li> </ul> </li> <li> <p>Graph Metrics </p> </li> <li><code>node_degree</code>: Returns a node\u2019s connection count.</li> <li> <p><code>edge_degree</code>: Computes the combined degrees of two nodes.</p> </li> <li> <p>Utility Functions </p> </li> <li><code>clean_quotes</code>: Removes surrounding quotes from strings.</li> <li><code>drop_graph</code>: Deletes the entire graph.</li> </ol>"},{"location":"graphrag/lightrag/#conclusion","title":"Conclusion:","text":"<p>The <code>TigerGraphStorage</code> class provides an efficient way to manage graph data in TigerGraph, offering straightforward methods for storing, retrieving, and handling nodes, edges, and graph metrics.</p>"},{"location":"graphrag/lightrag/#implement-vector-storage-with-tigergraph","title":"Implement Vector Storage with TigerGraph","text":"<p>The following code defines the <code>TigerVectorStorage</code> class, which enables storing and querying vector data (such as embeddings) in a TigerGraph database using TigerGraphX.</p> <pre><code>from dataclasses import dataclass\nimport numpy as np\nfrom tqdm.asyncio import tqdm as tqdm_async\nimport asyncio\n\nfrom lightrag.base import BaseVectorStorage\nfrom lightrag.utils import logger\n\nfrom tigergraphx import Graph\n\n\n@dataclass\nclass TigerVectorStorage(BaseVectorStorage):\n    def __post_init__(self):\n        try:\n            # Define the graph schema\n            graph_schema = {\n                \"graph_name\": f\"Vector_{self.namespace}\",\n                \"nodes\": {\n                    \"Table\": {\n                        \"primary_key\": \"id\",\n                        \"attributes\": {\n                            \"id\": \"STRING\",\n                            **{field: \"STRING\" for field in self.meta_fields},\n                        },\n                        \"vector_attributes\": {\n                            \"vector_attribute\": self.embedding_func.embedding_dim,\n                        },\n                    }\n                },\n                \"edges\": {},\n            }\n\n            # Initialize the graph\n            self._graph = Graph(graph_schema)\n            self._max_batch_size = self.global_config[\"embedding_batch_num\"]\n        except Exception as e:\n            logger.error(f\"An error occurred during initialization: {e}\")\n            raise\n\n    async def upsert(self, data: dict[str, dict]):\n        \"\"\"\n        Insert or update data in the TigerGraph vector storage.\n        \"\"\"\n        logger.info(f\"Inserting {len(data)} vectors to {self.namespace}\")\n        if not len(data):\n            logger.warning(\"No data to insert into the vector DB.\")\n            return []\n\n        # Preparing the data for insertion\n        list_data = [\n            {\n                \"id\": k,\n                **{k1: v1 for k1, v1 in v.items() if k1 in self.meta_fields},\n            }\n            for k, v in data.items()\n        ]\n\n        contents = [v[\"content\"] for v in data.values()]\n\n        # Batch the data for embedding\n        batches = [\n            contents[i : i + self._max_batch_size]\n            for i in range(0, len(contents), self._max_batch_size)\n        ]\n\n        async def wrapped_task(batch):\n            result = await self.embedding_func(batch)\n            pbar.update(1)\n            return result\n\n        embedding_tasks = [wrapped_task(batch) for batch in batches]\n        pbar = tqdm_async(\n            total=len(embedding_tasks), desc=\"Generating embeddings\", unit=\"batch\"\n        )\n        embeddings_list = await asyncio.gather(*embedding_tasks)\n\n        embeddings = np.concatenate(embeddings_list)\n        if len(embeddings) == len(list_data):\n            for i, d in enumerate(list_data):\n                d[\"vector_attribute\"] = embeddings[i].tolist()\n            results = self._graph.upsert(data=list_data, node_type=\"Table\")\n            return results\n        else:\n            # sometimes the embedding is not returned correctly. just log it.\n            logger.error(\n                f\"embedding is not 1-1 with data, {len(embeddings)} != {len(list_data)}\"\n            )\n\n    async def query(self, query: str, top_k=5):\n        \"\"\"\n        Perform a vector search to find the most similar nodes based on the query vector.\n        \"\"\"\n        embedding = await self.embedding_func([query])\n        embedding = embedding[0].tolist()\n        results = self._graph.search(\n            data=embedding,\n            vector_attribute_name=\"vector_attribute\",\n            node_type=\"Table\",  # Specify the node type\n            limit=top_k,  # Retrieve the top_k closest nodes\n        )\n        return results\n</code></pre>"},{"location":"graphrag/lightrag/#key-features_1","title":"Key Features:","text":"<ol> <li>Graph Schema </li> <li>Defines a node type <code>\"Table\"</code> with attributes including an <code>id</code> and a vector field for storing embeddings.  </li> <li> <p>The vector attribute's dimension is determined by the <code>embedding_func</code>.</p> </li> <li> <p>Upsert Method </p> </li> <li>Inserts or updates vector data in the TigerGraph database.  </li> <li> <p>Batches the data and asynchronously generates embeddings using <code>embedding_func</code>, then stores them in the graph.</p> </li> <li> <p>Query Method </p> </li> <li>Performs vector search in the TigerGraph database to find the most similar nodes based on a query vector.  </li> <li>Uses <code>embedding_func</code> to generate the query vector and retrieves the closest nodes.</li> </ol>"},{"location":"graphrag/lightrag/#conclusion_1","title":"Conclusion:","text":"<p><code>TigerVectorStorage</code> facilitates efficient storage and retrieval of vector embeddings in TigerGraph, enabling seamless integration of vector search capabilities.</p>"},{"location":"graphrag/lightrag/#integrating-custom-graph-and-vector-storage-with-lightrag","title":"Integrating Custom Graph and Vector Storage with LightRAG","text":"<p>Once the <code>TigerGraphStorage</code> and <code>TigerVectorStorage</code> classes are defined, they can be integrated into LightRAG. By subclassing LightRAG and extending its storage mapping, you can seamlessly replace or enhance the default storage backends with custom implementations.</p> <p>Although modifying the LightRAG source code is an option, this example demonstrates how to achieve integration without altering the original code.</p> <p>Below is the implementation of <code>CustomLightRAG</code>, which incorporates <code>TigerGraphStorage</code> and <code>TigerVectorStorage</code> into its storage mapping:</p> <pre><code>from lightrag import LightRAG\nfrom lightrag.lightrag import lazy_external_import\n\n\nclass CustomLightRAG(LightRAG):\n    def _get_storage_class(self, storage_name: str) -&gt; dict:\n        \"\"\"Override storage retrieval to use a custom storage mapping.\"\"\"\n\n        custom_storages = {\n            \"TigerGraphStorage\": \"__main__\",\n            \"TigerVectorStorage\": \"__main__\",\n        }\n\n        if storage_name in custom_storages:\n            import_path = custom_storages[storage_name]\n            return lazy_external_import(import_path, storage_name\n\n        # Call the parent class's method to prevent infinite recursion\n        return super()._get_storage_class(storage_name)\n</code></pre>"},{"location":"graphrag/lightrag/#indexing","title":"Indexing","text":""},{"location":"graphrag/lightrag/#data-preparation","title":"Data Preparation","text":"<p>For this demo, we will use <code>applications/lightrag/data</code> as the working directory.</p> <p>The input dataset, <code>input/clapnq_dev_answerable_orig.jsonl.10.txt</code>, is located in the working directory. It consists of the first ten records from the original dataset.</p> <p>Additionally, we have another dataset, <code>clapnq_dev_answerable.jsonl.10</code>, for evaluation, stored in <code>applications/resources</code>. This dataset contains ten questions from the annotated dataset, each with corresponding context from the original dataset.</p>"},{"location":"graphrag/lightrag/#indexing_1","title":"Indexing","text":"<p>The following code sets up the working directory and demonstrates how to index a document using LightRAG:</p> <pre><code>import logging\nfrom lightrag.llm.openai import gpt_4o_mini_complete, openai_embed\n\nimport nest_asyncio\n# Allow nested event loops in Jupyter Notebook without conflicts\nnest_asyncio.apply()\n\n\nworking_dir = \"../../applications/lightrag/data\"\n\ncustom_rag = CustomLightRAG(\n    working_dir=working_dir,\n    embedding_func=openai_embed,\n    llm_model_func=gpt_4o_mini_complete,\n    graph_storage=\"TigerGraphStorage\",\n    vector_storage=\"TigerVectorStorage\",\n    kv_storage=\"JsonKVStorage\",\n)\n\nwith open(working_dir + \"/input/clapnq_dev_answerable_orig.jsonl.10.txt\") as f:\n    custom_rag.insert(f.read())\n</code></pre> <p>Note: The output has been cleared due to its length, as most of it consists of logs.</p> <p>Additionally, TigerVector is supported only in TigerGraph v4.2.0 and later.</p>"},{"location":"graphrag/lightrag/#querying","title":"Querying","text":"<p>The following code demonstrates how to perform a query in LightRAG using the TigerGraph graph storage implementation.</p> <pre><code>from lightrag import QueryParam\n\nquery = \"where is the world's largest man made lake\"\n\nresult = custom_rag.query(query=query, param=QueryParam(mode=\"hybrid\"))\n\nprint(\"------------------- Query Result:  -------------------\")\nprint(result)\n</code></pre> <pre><code>2025-02-28 20:21:58,215 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:23:21,681 - lightrag - INFO - Global query uses 70 entites, 60 relations, 3 text units\n2025-02-28 20:23:21,683 - lightrag - INFO - Local query uses 60 entites, 32 relations, 3 text units\n------------------- Query Result:  -------------------\n### World's Largest Man-Made Lake\n\nThe world's largest man-made lake is **Lake Kariba**, which is located on the Zambezi River, straddling the border between **Zambia** and **Zimbabwe**. The lake was created by the construction of the **Kariba Dam**, which significantly impacted the surrounding environment and local communities when it was completed between 1958 and 1963.\n\n### Key Features\n\n- **Size**: Lake Kariba has a surface area of approximately **5,580 square kilometers** and is known for its rich biodiversity, supporting various fish species and wildlife.\n- **Biodiversity**: The lake is home to numerous species, including **kapenta**, a fish introduced to enhance its ecological dynamics and commercial value.\n- **Economical Importance**: The lake plays a critical role in supporting the **tourism industry** for both Zambia and Zimbabwe, attracting visitors with its natural beauty and wildlife.\n\nLake Kariba not only serves as a significant geographical landmark but also as a crucial resource for the economies of the surrounding nations.\n</code></pre>"},{"location":"graphrag/lightrag/#evaluation","title":"Evaluation","text":"<p>To evaluate the performance of LightRAG, we use TigerGraphX's <code>RagasEvaluator</code> class, which leverages Ragas for evaluation.</p> <p>In the code below, we define the <code>prepare_evaluation_data</code> function to construct the evaluation dataset. This function processes <code>ragas_data</code> by extracting questions and ground-truth answers, then queries <code>custom_rag</code> to retrieve both context passages and generated responses. The extracted data is then structured into evaluation samples, where each sample includes the question, retrieved contexts, generated answer, and ground-truth answers from the <code>clapnq_dev_answerable.jsonl.10</code> dataset stored in <code>applications/resources</code>.</p> <pre><code>from typing import Literal, cast\n\nfrom tigergraphx.graphrag import RagasEvaluator\n\ndef query_light_rag(\n    custom_rag,\n    query,\n    mode: Literal[\"naive\", \"hybrid\"] = \"hybrid\",\n    only_context=False,\n):\n    \"\"\"Query LightRAG to retrieve context or generated responses.\"\"\"\n    param = QueryParam(mode=mode, only_need_context=only_context)\n    result = custom_rag.query(query=query, param=param)\n    return result\n\n\ndef prepare_evaluation_data(\n    custom_rag,\n    ragas_data,\n    mode: Literal[\"naive\", \"hybrid\"] = \"hybrid\",\n):\n    \"\"\"Prepare evaluation dataset using queries from ragas_data.\"\"\"\n    eval_samples = []\n\n    for row in ragas_data:\n        question = row[\"input\"]  # Adjust to match dataset structure\n        ground_truths = [\n            ans[\"answer\"] for ans in row[\"output\"]\n        ]  # Extract ground truth answers\n\n        # Extract passages from the dataset (context retrieval)\n        retrieved_contexts = query_light_rag(\n            custom_rag, question, mode, only_context=True\n        )\n\n        # Extract generated response from LightRAG\n        response = query_light_rag(custom_rag, question, mode, only_context=False)\n\n        eval_samples.append(\n            {\n                \"question\": question,\n                \"contexts\": retrieved_contexts\n                if isinstance(retrieved_contexts, list)\n                else [retrieved_contexts],\n                \"answer\": response,\n                \"ground_truth\": ground_truths,\n            }\n        )\n    return eval_samples\n</code></pre> <p>Next, we load the evaluation dataset from <code>clapnq_dev_answerable.jsonl.10</code>, which contains queries and ground-truth answers. We then use the <code>prepare_evaluation_data</code> function to generate evaluation samples by retrieving context passages and responses from <code>custom_rag</code>.</p> <p>Once the evaluation dataset is prepared, we initialize the <code>RagasEvaluator</code> with the <code>gpt-4o</code> model and run the evaluation to assess LightRAG's performance.</p> <pre><code>from datasets import Dataset, load_dataset\n# Load datasets\ndataset = load_dataset(\n    \"json\",\n    data_files=\"../../applications/resources/clapnq_dev_answerable.jsonl.10\",\n    split=\"train\",\n)\ndataset = cast(Dataset, dataset)\n\n# Prepare evaluation dataset\neval_samples = prepare_evaluation_data(custom_rag, dataset, \"hybrid\")\n\n# Evaluate LightRAG\nevaluator = RagasEvaluator(model=\"gpt-4o\")\n\n# Run evaluation\nresults = evaluator.evaluate_dataset(eval_samples)\n</code></pre> <pre><code>2025-02-28 20:31:01,776 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:32:24,563 - lightrag - INFO - Global query uses 53 entites, 60 relations, 3 text units\n2025-02-28 20:32:24,565 - lightrag - INFO - Local query uses 60 entites, 24 relations, 3 text units\n2025-02-28 20:32:24,647 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:32:34,144 - lightrag - INFO - Global query uses 53 entites, 60 relations, 3 text units\n2025-02-28 20:32:34,146 - lightrag - INFO - Local query uses 60 entites, 24 relations, 3 text units\n2025-02-28 20:32:41,812 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:33:44,706 - lightrag - INFO - Global query uses 76 entites, 60 relations, 3 text units\n2025-02-28 20:33:47,394 - lightrag - INFO - Local query uses 60 entites, 40 relations, 3 text units\n2025-02-28 20:33:47,425 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:33:55,750 - lightrag - INFO - Global query uses 76 entites, 60 relations, 3 text units\n2025-02-28 20:33:57,289 - lightrag - INFO - Local query uses 60 entites, 40 relations, 3 text units\n2025-02-28 20:34:03,817 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:35:07,504 - lightrag - INFO - Global query uses 59 entites, 60 relations, 3 text units\n2025-02-28 20:35:10,693 - lightrag - INFO - Local query uses 60 entites, 39 relations, 3 text units\n2025-02-28 20:35:10,724 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:35:19,992 - lightrag - INFO - Global query uses 59 entites, 60 relations, 3 text units\n2025-02-28 20:35:21,489 - lightrag - INFO - Local query uses 60 entites, 39 relations, 3 text units\n2025-02-28 20:35:26,577 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:35:47,741 - lightrag - WARNING - Some nodes are missing, maybe the storage is damaged\n2025-02-28 20:36:22,940 - lightrag - INFO - Global query uses 71 entites, 60 relations, 3 text units\n2025-02-28 20:36:22,943 - lightrag - INFO - Local query uses 58 entites, 37 relations, 3 text units\n2025-02-28 20:36:22,982 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:36:28,583 - lightrag - WARNING - Some nodes are missing, maybe the storage is damaged\n2025-02-28 20:36:30,848 - lightrag - INFO - Global query uses 71 entites, 60 relations, 3 text units\n2025-02-28 20:36:32,222 - lightrag - INFO - Local query uses 58 entites, 37 relations, 3 text units\n2025-02-28 20:36:36,151 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:37:35,089 - lightrag - INFO - Global query uses 59 entites, 60 relations, 3 text units\n2025-02-28 20:38:01,468 - lightrag - INFO - Local query uses 60 entites, 125 relations, 3 text units\n2025-02-28 20:38:01,517 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:38:10,021 - lightrag - INFO - Global query uses 59 entites, 60 relations, 3 text units\n2025-02-28 20:38:16,022 - lightrag - INFO - Local query uses 60 entites, 125 relations, 3 text units\n2025-02-28 20:38:21,065 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:39:28,932 - lightrag - INFO - Global query uses 61 entites, 60 relations, 3 text units\n2025-02-28 20:39:28,935 - lightrag - INFO - Local query uses 60 entites, 95 relations, 3 text units\n2025-02-28 20:39:28,977 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:39:40,160 - lightrag - INFO - Global query uses 61 entites, 60 relations, 3 text units\n2025-02-28 20:39:40,162 - lightrag - INFO - Local query uses 60 entites, 95 relations, 3 text units\n2025-02-28 20:39:51,972 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:39:52,129 - openai._base_client - INFO - Retrying request to /embeddings in 0.436530 seconds\n2025-02-28 20:40:52,287 - lightrag - INFO - Global query uses 68 entites, 60 relations, 3 text units\n2025-02-28 20:40:52,290 - lightrag - INFO - Local query uses 60 entites, 36 relations, 3 text units\n2025-02-28 20:40:52,339 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:41:01,041 - lightrag - INFO - Global query uses 68 entites, 60 relations, 3 text units\n2025-02-28 20:41:02,383 - lightrag - INFO - Local query uses 60 entites, 36 relations, 3 text units\n2025-02-28 20:41:10,024 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:41:31,041 - lightrag - WARNING - Some nodes are missing, maybe the storage is damaged\n2025-02-28 20:42:11,316 - lightrag - INFO - Global query uses 81 entites, 60 relations, 3 text units\n2025-02-28 20:42:11,319 - lightrag - INFO - Local query uses 57 entites, 43 relations, 3 text units\n2025-02-28 20:42:11,351 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:42:17,018 - lightrag - WARNING - Some nodes are missing, maybe the storage is damaged\n2025-02-28 20:42:19,114 - lightrag - INFO - Global query uses 81 entites, 60 relations, 3 text units\n2025-02-28 20:42:20,809 - lightrag - INFO - Local query uses 57 entites, 43 relations, 3 text units\n2025-02-28 20:42:30,206 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:42:30,375 - openai._base_client - INFO - Retrying request to /embeddings in 0.428693 seconds\n2025-02-28 20:43:28,485 - lightrag - INFO - Global query uses 56 entites, 60 relations, 3 text units\n2025-02-28 20:43:43,044 - lightrag - INFO - Local query uses 60 entites, 109 relations, 3 text units\n2025-02-28 20:43:43,080 - lightrag - INFO - Using hybrid mode for query processing\n2025-02-28 20:43:47,577 - lightrag - INFO - Global query uses 56 entites, 60 relations, 3 text units\n2025-02-28 20:43:48,136 - openai._base_client - INFO - Retrying request to /embeddings in 0.396963 seconds\n2025-02-28 20:43:58,277 - lightrag - INFO - Local query uses 60 entites, 109 relations, 3 text units\n\n\n\nEvaluating:   0%|          | 0/40 [00:00&lt;?, ?it/s]\n\n\n2025-02-28 20:44:08,812 - openai._base_client - INFO - Retrying request to /chat/completions in 0.480058 seconds\n2025-02-28 20:44:08,814 - openai._base_client - INFO - Retrying request to /chat/completions in 0.397422 seconds\n2025-02-28 20:47:02,781 - ragas.executor - ERROR - Exception raised in Job[3]: TimeoutError()\n2025-02-28 20:47:02,788 - ragas.executor - ERROR - Exception raised in Job[2]: TimeoutError()\n2025-02-28 20:47:03,337 - tigergraphx.graphrag.evaluation.ragas_evaluator - INFO - Evaluation results: {'answer_relevancy': 0.8976, 'faithfulness': 0.6659, 'llm_context_precision_with_reference': 0.5556, 'context_recall': 0.4444}\n</code></pre> <p>The final line displays the evaluation results:</p> <p><code>Evaluation results: {'answer_relevancy': 0.8976, 'faithfulness': 0.6659, 'llm_context_precision_with_reference': 0.5556, 'context_recall': 0.4444}</code></p>"},{"location":"graphrag/lightrag/#reset","title":"Reset","text":"<p>After completing the evaluation, it is recommended to clean up the environment by removing the previously created graphs. The following code iterates through a list of graph names and attempts to drop each graph from the TigerGraph database. If a graph does not exist or an error occurs during deletion, the error message is printed.</p> <pre><code>from tigergraphx import Graph\n\ngraphs_to_drop = [\n    \"LightRAG\",\n    \"Vector_chunks\",\n    \"Vector_entities\",\n    \"Vector_relationships\",\n]\nfor graph_name in graphs_to_drop:\n    try:\n        G = Graph.from_db(graph_name)\n        G.drop_graph()\n    except Exception as e:\n        print(f\"Error message: {str(e)}\")\n</code></pre> <pre><code>2025-02-28 20:50:07,250 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: LightRAG...\n2025-02-28 20:50:10,802 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n2025-02-28 20:50:10,840 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: Vector_chunks...\n2025-02-28 20:50:14,019 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n2025-02-28 20:50:14,050 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: Vector_entities...\n2025-02-28 20:50:17,205 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n2025-02-28 20:50:17,268 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: Vector_relationships...\n2025-02-28 20:50:20,638 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n</code></pre>"},{"location":"graphrag/lightrag/#next-steps","title":"Next Steps","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 1: Demonstrates how to integrate TigerGraph with Microsoft's GraphRAG.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_1/","title":"Supporting Microsoft\u2019s GraphRAG: Part 1 - Setup and Data Preparation","text":"<p>Microsoft's GraphRAG is a method for creating structured knowledge graphs from raw text, enhancing Retrieval Augmented Generation (RAG) tasks. By organizing information hierarchically, it enables more efficient data retrieval and summarization.</p>"},{"location":"graphrag/msft_graphrag_1/#what-youll-learn-in-this-guide","title":"What You\u2019ll Learn in This Guide","text":"<ul> <li>Indexing: Utilize Microsoft's GraphRAG to convert unstructured documents into Parquet files.</li> <li>Data Preprocessing: Learn how to use utility methods provided by TigerGraphX to transform Parquet files into CSV files compatible with TigerGraph.</li> </ul>"},{"location":"graphrag/msft_graphrag_1/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you\u2019ve completed the installation and setup steps outlined in the Installation Guide, including:</p> <ul> <li>Setting up Python and TigerGraph. For more details, refer to the Requirements section.</li> <li>Install TigerGraphX along with its development dependencies. For more details, refer to the Development Installation section.</li> </ul>"},{"location":"graphrag/msft_graphrag_1/#utilize-microsoft-graphrag-for-indexing","title":"Utilize Microsoft GraphRAG for Indexing","text":"<p>The indexing process transforms raw documents into structured data using Microsoft\u2019s GraphRAG. Follow these steps to prepare your data:</p>"},{"location":"graphrag/msft_graphrag_1/#data-preparation","title":"Data Preparation","text":"<p>For this demo, we will use <code>applications/msft_graphrag/data</code> as the working directory.</p> <p>The input dataset, <code>input/clapnq_dev_answerable_orig.jsonl.10.txt</code>, is located in the working directory. It consists of the first ten records from the original dataset.</p> <p>Additionally, we have another dataset, <code>clapnq_dev_answerable.jsonl.10</code>, for evaluation, stored in <code>applications/resources</code>. This dataset contains ten questions from the annotated dataset, each with corresponding context from the original dataset.</p>"},{"location":"graphrag/msft_graphrag_1/#initialization","title":"Initialization","text":"<p>Initialize the indexing system in the <code>data</code> directory.</p> <pre><code>python3 -m graphrag init --root data\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#set-up-openai-api-key","title":"Set Up OpenAI API Key","text":"<p>GraphRAG requires an OpenAI API key. To configure it:</p> <ol> <li>Open the <code>.env</code> file in the <code>data</code> directory:    <pre><code>vi data/.env\n</code></pre></li> <li>Add your API key:    <pre><code>GRAPHRAG_API_KEY=&lt;Your OpenAI API Key&gt;\n</code></pre></li> </ol>"},{"location":"graphrag/msft_graphrag_1/#optional-switch-to-a-cost-effective-model","title":"Optional: Switch to a Cost-Effective Model","text":"<p>GraphRAG uses the <code>gpt-4-turbo-preview</code> model by default. To reduce costs, switch to the <code>gpt-4o-mini</code> model by editing the <code>settings.yaml</code> file in the <code>data</code> directory:</p> <pre><code>llm:\n  api_key: ${GRAPHRAG_API_KEY}\n  type: openai_chat # or azure_openai_chat\n  model: gpt-4o-mini # Use a cost-effective model\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#indexing","title":"Indexing","text":"<p>Run the indexing process to convert documents into structured data. This step uses LLMs and may take several minutes depending on the dataset size and hardware.</p> <pre><code>python3 -m graphrag index --no-cache --root data\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#utilize-tigergraphx-for-data-preprocessing","title":"Utilize TigerGraphX for Data Preprocessing","text":"<p>Transform the structured Parquet files generated by GraphRAG into CSV files that TigerGraph can import.</p>"},{"location":"graphrag/msft_graphrag_1/#convert-parquet-to-csv","title":"Convert Parquet to CSV","text":"<p>Run the script below to convert Parquet files into TigerGraph-compatible CSV files. You can find the Python script here.</p> <pre><code>python3 data_import/convert_parquet_to_tg_csv.py \\\n--input_dir data/output \\\n--output_dir data/tg_csv\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#export-data-from-lancedb-to-csv","title":"Export Data from LanceDB to CSV","text":"<p>Use the script below to export data from LanceDB into CSV files that are compatible with TigerGraph. You can access the Python script here.</p> <pre><code>python3 data_import/export_lancedb_to_csv.py \\\n--input_dir data/output/lancedb \\\n--output_dir data/tg_csv\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#transfer-csv-files-to-tigergraph-server","title":"Transfer CSV Files to TigerGraph Server","text":"<p>Transfer the generated CSV files to your TigerGraph server. Use the following command, replacing <code>username</code> and <code>tigergraph-server</code> with your server credentials:</p> <pre><code>scp data/tg_csv/* username@tigergraph-server:/home/tigergraph/data/graphrag\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#next-steps","title":"Next Steps","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 2: Use Jupyter Notebook to create the schema and load data into TigerGraph.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_2/","title":"Supporting Microsoft\u2019s GraphRAG: Part 2 - Graph Creation and Data Loading","text":"<p>In the previous section, we used Microsoft's GraphRAG to convert unstructured documents into Parquet files, and then used TigerGraphX to transform these files into CSV format.</p> <p>Now, let\u2019s use Jupyter Notebook to create the schema and load the CSV files into TigerGraph.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_2.ipynb.</p>"},{"location":"graphrag/msft_graphrag_2/#create-a-graph","title":"Create a Graph","text":""},{"location":"graphrag/msft_graphrag_2/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration","text":"<p>Since our data is stored in a TigerGraph instance\u2014whether on-premise or in the cloud\u2014we need to configure the connection settings. The recommended approach is to use environment variables, such as setting them with the <code>export</code> command in the shell. Here, to illustrate the demo, we configure them within Python using the <code>os.environ</code> method. You can find more methods for configuring connection settings in Graph.__init__.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ[\"TG_HOST\"] = \"http://127.0.0.1\"\n&gt;&gt;&gt; os.environ[\"TG_USERNAME\"] = \"tigergraph\"\n&gt;&gt;&gt; os.environ[\"TG_PASSWORD\"] = \"tigergraph\"\n</code></pre>"},{"location":"graphrag/msft_graphrag_2/#define-a-graph-schema","title":"Define a Graph Schema","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we will initialize a graph using a schema defined in a YAML file. The schema structure is represented visually in the following image.</p> <p></p> <pre><code>&gt;&gt;&gt; from tigergraphx import Graph\n&gt;&gt;&gt; resource_dir = \"../../applications/msft_graphrag/query/resources/\"\n&gt;&gt;&gt; graph_schema = resource_dir + \"graph_schema.yaml\"\n</code></pre> <p>TigerGraphX offers several methods to define the schema, including a Python dictionary, YAML file, or JSON file. Above is an example using a YAML file. For other methods, please refer to Graph.__init__ for more details.</p>"},{"location":"graphrag/msft_graphrag_2/#create-a-graph_1","title":"Create a Graph","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p> <pre><code>&gt;&gt;&gt; from tigergraphx import Graph\n&gt;&gt;&gt; G = Graph(graph_schema)\n</code></pre> <pre><code>2025-02-28 21:48:49,181 - tigergraphx.core.managers.schema_manager - INFO - Creating schema for graph: GraphRAG...\n2025-02-28 21:48:52,805 - tigergraphx.core.managers.schema_manager - INFO - Graph schema created successfully.\n2025-02-28 21:48:52,806 - tigergraphx.core.managers.schema_manager - INFO - Adding vector attribute(s) for graph: GraphRAG...\n2025-02-28 21:49:58,529 - tigergraphx.core.managers.schema_manager - INFO - Vector attribute(s) added successfully.\n</code></pre>"},{"location":"graphrag/msft_graphrag_2/#load-data","title":"Load Data","text":"<p>First, let's check the total number of nodes in the graph. As anticipated, the graph is currently empty.</p> <pre><code>print(G.number_of_nodes())\n</code></pre> <pre><code>0\n</code></pre> <p>After that, we will load data into the graph using a pre-defined loading job configuration. The configuration is stored in a YAML file. Note that loading the data may take several seconds.</p> <pre><code>loading_job_config = resource_dir + \"loading_job_config.yaml\"\nG.load_data(loading_job_config)\n</code></pre> <pre><code>2025-02-28 21:52:18,639 - tigergraphx.core.managers.data_manager - INFO - Initiating data load for job: loading_job_GraphRAG...\n2025-02-28 21:52:26,261 - tigergraphx.core.managers.data_manager - INFO - Data load completed successfully.\n</code></pre> <p>Now, let's check the total number of nodes in the graph again. We should observe that some nodes have been successfully loaded into the graph.</p> <pre><code>print(G.number_of_nodes())\n</code></pre> <pre><code>2883\n</code></pre>"},{"location":"graphrag/msft_graphrag_2/#next-steps","title":"Next Steps","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 3: Use Jupyter Notebook to explore graph data and perform Graph Analysis.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_3/","title":"Supporting Microsoft\u2019s GraphRAG: Part 3 - Graph Analysis","text":"<p>In the previous section, we have created a graph in TigerGraph, and loaded the CSV data into it.</p> <p>Now, let\u2019s use Jupyter Notebook to explore the graph data and perform graph analysis.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_3.ipynb.</p>"},{"location":"graphrag/msft_graphrag_3/#retrieving-the-graph-from-tigergraph","title":"Retrieving the Graph from TigerGraph","text":"<p>Since the graph has already been created in TigerGraph, redefining its schema is unnecessary. Instead, you can provide the graph name to retrieve it. TigerGraphX will verify if the graph exists in TigerGraph and, if it does, will return the corresponding graph.</p>"},{"location":"graphrag/msft_graphrag_3/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration","text":"<p>Before retrieving the graph schema, you need to configure the TigerGraph connection settings.  </p> <p>The recommended approach is to use environment variables, such as setting them with the <code>export</code> command in the shell. Here, to illustrate the demo, we configure them within Python using the <code>os.environ</code> method. You can find more methods for configuring connection settings in Graph.__init__.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ[\"TG_HOST\"] = \"http://127.0.0.1\"\n&gt;&gt;&gt; os.environ[\"TG_USERNAME\"] = \"tigergraph\"\n&gt;&gt;&gt; os.environ[\"TG_PASSWORD\"] = \"tigergraph\"\n</code></pre>"},{"location":"graphrag/msft_graphrag_3/#retrieve-a-graph-and-print-its-schema","title":"Retrieve a Graph and Print Its Schema","text":"<p>Once the graph has been created in TigerGraph, you can retrieve it without manually defining the schema using the <code>Graph.from_db</code> method, which requires only the graph name:</p> <pre><code>&gt;&gt;&gt; from tigergraphx import Graph\n&gt;&gt;&gt; G = Graph.from_db(\"GraphRAG\")\n</code></pre>"},{"location":"graphrag/msft_graphrag_3/#display-the-graph-schema","title":"Display the Graph Schema","text":"<p>Now, let's print the schema of the graph in a well-formatted manner:</p> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; schema = G.get_schema()\n&gt;&gt;&gt; print(json.dumps(schema, indent=4, default=str))\n</code></pre> <pre><code>{\n    \"graph_name\": \"GraphRAG\",\n    \"nodes\": {\n        \"Document\": {\n            \"primary_key\": \"id\",\n            \"attributes\": {\n                \"id\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"title\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                }\n            },\n            \"vector_attributes\": {}\n        },\n        \"TextUnit\": {\n            \"primary_key\": \"id\",\n            \"attributes\": {\n                \"id\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"text\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"n_tokens\": {\n                    \"data_type\": \"DataType.UINT\",\n                    \"default_value\": null\n                }\n            },\n            \"vector_attributes\": {}\n        },\n        \"Entity\": {\n            \"primary_key\": \"id\",\n            \"attributes\": {\n                \"id\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"human_readable_id\": {\n                    \"data_type\": \"DataType.UINT\",\n                    \"default_value\": null\n                },\n                \"name\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"entity_type\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"description\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                }\n            },\n            \"vector_attributes\": {\n                \"emb_description\": {\n                    \"dimension\": 1536,\n                    \"index_type\": \"HNSW\",\n                    \"data_type\": \"FLOAT\",\n                    \"metric\": \"COSINE\"\n                }\n            }\n        },\n        \"Relationship\": {\n            \"primary_key\": \"id\",\n            \"attributes\": {\n                \"id\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"human_readable_id\": {\n                    \"data_type\": \"DataType.UINT\",\n                    \"default_value\": null\n                },\n                \"rank\": {\n                    \"data_type\": \"DataType.UINT\",\n                    \"default_value\": null\n                },\n                \"weight\": {\n                    \"data_type\": \"DataType.DOUBLE\",\n                    \"default_value\": null\n                },\n                \"description\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                }\n            },\n            \"vector_attributes\": {}\n        },\n        \"Community\": {\n            \"primary_key\": \"id\",\n            \"attributes\": {\n                \"id\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"level\": {\n                    \"data_type\": \"DataType.UINT\",\n                    \"default_value\": null\n                },\n                \"rank\": {\n                    \"data_type\": \"DataType.DOUBLE\",\n                    \"default_value\": null\n                },\n                \"rank_explanation\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"title\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"full_content\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                },\n                \"summary\": {\n                    \"data_type\": \"DataType.STRING\",\n                    \"default_value\": null\n                }\n            },\n            \"vector_attributes\": {}\n        }\n    },\n    \"edges\": {\n        \"document_contains_text_unit\": {\n            \"is_directed_edge\": false,\n            \"from_node_type\": \"Document\",\n            \"to_node_type\": \"TextUnit\",\n            \"discriminator\": \"set()\",\n            \"attributes\": {}\n        },\n        \"text_unit_contains_entity\": {\n            \"is_directed_edge\": false,\n            \"from_node_type\": \"TextUnit\",\n            \"to_node_type\": \"Entity\",\n            \"discriminator\": \"set()\",\n            \"attributes\": {}\n        },\n        \"text_unit_contains_relationship\": {\n            \"is_directed_edge\": false,\n            \"from_node_type\": \"TextUnit\",\n            \"to_node_type\": \"Relationship\",\n            \"discriminator\": \"set()\",\n            \"attributes\": {}\n        },\n        \"relationship_source\": {\n            \"is_directed_edge\": false,\n            \"from_node_type\": \"Relationship\",\n            \"to_node_type\": \"Entity\",\n            \"discriminator\": \"set()\",\n            \"attributes\": {}\n        },\n        \"relationship_target\": {\n            \"is_directed_edge\": false,\n            \"from_node_type\": \"Relationship\",\n            \"to_node_type\": \"Entity\",\n            \"discriminator\": \"set()\",\n            \"attributes\": {}\n        },\n        \"community_contains_entity\": {\n            \"is_directed_edge\": false,\n            \"from_node_type\": \"Community\",\n            \"to_node_type\": \"Entity\",\n            \"discriminator\": \"set()\",\n            \"attributes\": {}\n        },\n        \"community_contains_relationship\": {\n            \"is_directed_edge\": false,\n            \"from_node_type\": \"Community\",\n            \"to_node_type\": \"Relationship\",\n            \"discriminator\": \"set()\",\n            \"attributes\": {}\n        }\n    }\n}\n</code></pre>"},{"location":"graphrag/msft_graphrag_3/#display-node-and-edge-counts","title":"Display Node and Edge Counts","text":"<p>Gain deeper insights into the graph by exploring details such as the total number of nodes and the count of nodes for each node type.</p>"},{"location":"graphrag/msft_graphrag_3/#display-the-total-number-of-nodes","title":"Display the Total Number of Nodes","text":"<pre><code>&gt;&gt;&gt; G.number_of_nodes()\n</code></pre> <pre><code>2883\n</code></pre>"},{"location":"graphrag/msft_graphrag_3/#display-the-count-of-nodes-for-each-node-type","title":"Display the Count of Nodes for Each Node Type","text":"<pre><code>&gt;&gt;&gt; for node_type in schema[\"nodes\"]:\n...     print(f\"{node_type}: {G.number_of_nodes(node_type)}\")\n</code></pre> <pre><code>Document: 1\nTextUnit: 104\nEntity: 1577\nRelationship: 1092\nCommunity: 109\n</code></pre>"},{"location":"graphrag/msft_graphrag_3/#display-the-total-number-of-edges","title":"Display the Total Number of Edges","text":"<pre><code>&gt;&gt;&gt; G.number_of_edges()\n</code></pre> <pre><code>10313\n</code></pre>"},{"location":"graphrag/msft_graphrag_3/#display-the-count-of-edges-for-each-edge-type","title":"Display the Count of Edges for Each Edge Type","text":"<pre><code>&gt;&gt;&gt; for edge_type in schema[\"edges\"]:\n...     print(f\"{edge_type}: {G.number_of_edges(edge_type)}\")\n</code></pre> <pre><code>document_contains_text_unit: 104\ntext_unit_contains_entity: 2095\ntext_unit_contains_relationship: 1282\nrelationship_source: 1092\nrelationship_target: 1092\ncommunity_contains_entity: 1956\ncommunity_contains_relationship: 2692\n</code></pre>"},{"location":"graphrag/msft_graphrag_3/#retrieving-sample-nodes","title":"Retrieving Sample Nodes","text":"<p>Retrieve Sample <code>Entity</code> Nodes.</p> <pre><code>&gt;&gt;&gt; print(G.get_nodes(node_type=\"Entity\", limit=2))\n</code></pre> <pre><code>                               v_id  v_type  human_readable_id entity_type  \\\n0  c0803923646246c5a203810faa4e4464  Entity                825         GEO   \n1  6069e8895f924b659534f74d6736e69d  Entity                830         GEO\n\n            name                                        description  \\\n0  VALLEY STREAM  Valley Stream is a location in New York where ...   \n1          CHINA  China is a country in East Asia where Walmart ...\n\n                                 id  \n0  c0803923646246c5a203810faa4e4464  \n1  6069e8895f924b659534f74d6736e69d\n</code></pre> <p>Retrieve Sample <code>Relationship</code> Nodes</p> <pre><code>&gt;&gt;&gt; print(G.get_nodes(node_type=\"Relationship\", limit=2))\n</code></pre> <pre><code>                               v_id        v_type  human_readable_id  rank  \\\n0  5e7864d8153f4aa8936b253792f0b636  Relationship               1066    32   \n1  1db19aed7ed54b44b4e8f71b7588e0dd  Relationship               1058    16\n\n   weight                                        description  \\\n0       8  Animax is a channel owned by Sony Pictures Tel...   \n1       7  Guerrilla Cambridge developed games for the Pl...\n\n                                 id  \n0  5e7864d8153f4aa8936b253792f0b636  \n1  1db19aed7ed54b44b4e8f71b7588e0dd\n</code></pre> <p>Retrieve Sample <code>Community</code> Nodes</p> <pre><code>&gt;&gt;&gt; print(G.get_nodes(node_type=\"Community\", limit=2))\n</code></pre> <pre><code>  v_id     v_type                                            summary  level  \\\n0   49  Community  This community encompasses various command-lin...      1   \n1   61  Community  The community centers around the Battles of Ma...      1\n\n                                        full_content  rank  id  \\\n0  # DOS and Command-Line Operating Systems Commu...   7.5  49   \n1  # Battles of Manassas and Civil War Historians...   6.5  61\n\n                                    rank_explanation         title  \n0  The impact severity rating is high due to the ...  Community 49  \n1  The impact severity rating is moderate to high...  Community 61\n</code></pre>"},{"location":"graphrag/msft_graphrag_3/#whats-next","title":"What\u2019s Next?","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 4: Perform queries using GSQL and Python-native TigerGraphX, with global and local context builders.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_4/","title":"Supporting Microsoft\u2019s GraphRAG: Part 4 - Hybrid Retrieval and Integration with LLM","text":"<p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_4.ipynb.</p>"},{"location":"graphrag/msft_graphrag_4/#get-the-graph-from-tigergraph","title":"Get the Graph from TigerGraph","text":"<p>Since the graph has already been created in TigerGraph, redefining its schema is unnecessary. Instead, you can provide the graph name to retrieve it. TigerGraphX will verify if the graph exists in TigerGraph and, if it does, will return the corresponding graph.</p>"},{"location":"graphrag/msft_graphrag_4/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration","text":"<p>Before retrive the graph schema from TigerGraph, you shoulddefine the  TigerGraph Connection Configuration first. The recommended approach is to use environment variables, such as setting them with the <code>export</code> command in the shell. Here, to illustrate the demo, we configure them within Python using the <code>os.environ</code> method. You can find more methods for configuring connection settings in Graph.__init__.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ[\"TG_HOST\"] = \"http://127.0.0.1\"\n&gt;&gt;&gt; os.environ[\"TG_USERNAME\"] = \"tigergraph\"\n&gt;&gt;&gt; os.environ[\"TG_PASSWORD\"] = \"tigergraph\"\n</code></pre>"},{"location":"graphrag/msft_graphrag_4/#retrieve-the-graph","title":"Retrieve the Graph","text":"<p>Once a graph has been created in TigerGraph, you can retrieve it without manually defining the schema using the <code>Graph.from_db</code> method, which requires only the graph name:</p> <pre><code>&gt;&gt;&gt; from tigergraphx import Graph\n&gt;&gt;&gt; G = Graph.from_db(\"GraphRAG\")\n</code></pre>"},{"location":"graphrag/msft_graphrag_4/#hybrid-retrieval","title":"Hybrid Retrieval","text":"<p>TigerGraph offers two flexible ways to perform hybrid retrieval, allowing you to extract relevant graph and vector data efficiently for GraphRAG workflows.</p>"},{"location":"graphrag/msft_graphrag_4/#using-tigergraphx","title":"Using TigerGraphX","text":"<p>TigerGraphX offers an intuitive, Python-native interface for hybrid retrieval, ideal for developers seeking simplicity and ease of use. </p> <p>Key Advantage: Minimal learning curve with high-level Python APIs, seamlessly integrated with existing workflows.</p> <p>Below are some illustrative examples.</p>"},{"location":"graphrag/msft_graphrag_4/#retrieve-nodes-with-specific-attributes","title":"Retrieve Nodes with Specific Attributes","text":"<p>You can use the following code to fetch up to two nodes of type \"Entity\" and display their \"id,\" \"entity_type,\" and \"description\" attributes.</p> <pre><code>&gt;&gt;&gt; print(G.get_nodes(\n...     node_type=\"Entity\",\n...     return_attributes=[\"id\", \"name\", \"entity_type\", \"description\"],\n...     limit=2,\n... ))\n</code></pre> <pre><code>                                 id           name entity_type  \\\n0  c0803923646246c5a203810faa4e4464  VALLEY STREAM         GEO   \n1  6069e8895f924b659534f74d6736e69d          CHINA         GEO\n\n                                         description  \n0  Valley Stream is a location in New York where ...  \n1  China is a country in East Asia where Walmart ...\n</code></pre>"},{"location":"graphrag/msft_graphrag_4/#retrieve-neighbors-with-specific-attributes","title":"Retrieve Neighbors with Specific Attributes","text":"<p>The following code demonstrates how to fetch neighbors of specific nodes. In this example, the query retrieves neighbors connected to the given <code>start_nodes</code> of type <code>\"Entity\"</code> through the edge type <code>\"community_contains_entity\"</code>. The attributes <code>\"id\"</code>, <code>\"title\"</code>, and <code>\"full_content\"</code> of the neighbors are returned.</p> <pre><code>&gt;&gt;&gt; start_nodes = [\"2268d4506af346a3a308a2145cd19734\", \"38515ccf6ce14852a0c0fabee67b7c42\"]\n&gt;&gt;&gt; print(G.get_neighbors(\n...     start_nodes=start_nodes,\n...     start_node_type=\"Entity\",\n...     edge_types=\"community_contains_entity\",\n...     return_attributes=[\"id\", \"title\", \"full_content\"],\n... ))\n</code></pre> <pre><code>   id         title                                       full_content\n0   4   Community 4  # Bull Run Battles Community\\n\\nThe Bull Run B...\n1  64  Community 64  # Walmart and Global Retail Expansion\\n\\nThe c...\n2  31  Community 31  # Bull Run and the American Civil War\\n\\nThe c...\n3  80  Community 80  # Bull Run and Its Historical Significance\\n\\n...\n4  20  Community 20  # Walmart and Its Global Impact\\n\\nThe communi...\n</code></pre>"},{"location":"graphrag/msft_graphrag_4/#retrieve-top-k-using-tigervectors-vector-search-capability","title":"Retrieve Top-K Using TigerVector's Vector Search Capability","text":"<p>The following code generates a random query vector of 1536 float values and uses it to perform a vector search on a TigerGraph instance. The search finds the most similar \"Entity\" nodes based on the \"emb_description\" vector attribute and returns the top result.</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; random_floats: list[float] = [random.random() for _ in range(1536)]\n&gt;&gt;&gt; results = G.search(\n...     data=random_floats,\n...     vector_attribute_name=\"emb_description\",\n...     node_type=\"Entity\",\n...     limit=1,\n... )\n&gt;&gt;&gt; print(results)\n</code></pre> <pre><code>[{'id': '98d96d2568b9413b8aafc4e982f676c0', 'distance': 0.9290141, 'human_readable_id': 511, 'name': 'WASHINGTON DULLES INTERNATIONAL AIRPORT', 'entity_type': 'GEO', 'description': 'Washington Dulles International Airport is a major airport serving the Washington, D.C. metropolitan area, facilitating both domestic and international travel.'}]\n</code></pre>"},{"location":"graphrag/msft_graphrag_4/#using-gsql","title":"Using GSQL","text":"<p>For developers seeking fine-grained control or complex retrieval logic, GSQL offers unmatched flexibility. As TigerGraph's built-in query language, GSQL empowers you to perform advanced graph data analysis. For more details, see the official documentation.</p> <p>Key Advantage: Supports complex logic, customization, and direct interaction with TigerGraph\u2019s powerful query engine.</p> <ol> <li>Use an LLM to convert the query into an embedding.  </li> <li>Write a GSQL query to retrieve the top-K similar objects and their neighbors, combining structured and vector-based retrieval:</li> </ol> <pre><code>CREATE OR REPLACE QUERY my_query (\n    LIST&lt;float&gt; query_vector,\n    int k\n) SYNTAX v3 {\n  Nodes = vectorSearch({Entity.emb_description}, query_vector, k);\n  PRINT Nodes;\n\n  Neighbors =\n    SELECT t\n    FROM (s:Nodes)-[e:community_contains_entity]-&gt;(t:Community);\n\n  print Neighbors[Neighbors.id, Neighbors.title, Neighbors.full_content];\n}\n</code></pre>"},{"location":"graphrag/msft_graphrag_4/#context-building-writing-custom-context-builders","title":"Context Building: Writing Custom Context Builders","text":"<p>Context builders play a vital role in graph-powered RAG workflows. They transform retrieved graph data into structured, meaningful contexts for tasks such as interactions with LLMs).</p> <p>TigerGraphX simplifies this process by offering the flexible <code>BaseContextBuilder</code> class, which allows developers to define custom logic for context building.</p>"},{"location":"graphrag/msft_graphrag_4/#key-features-of-basecontextbuilder","title":"Key Features of <code>BaseContextBuilder</code>","text":"<p>The <code>BaseContextBuilder</code> class in TigerGraphX provides a strong foundation for creating custom context builders, offering:</p> <ul> <li>Core Abstraction: A reusable framework for building context logic.</li> <li>Customizable Design: Extensibility for implementing both global and query-specific context generation.</li> </ul>"},{"location":"graphrag/msft_graphrag_4/#key-components","title":"Key Components","text":"<ol> <li>Abstract Method - <code>build_context</code>:    Subclasses must implement this method to define the logic for constructing context.</li> </ol> <pre><code>@abstractmethod\nasync def build_context(self, *args, **kwargs) -&gt; str | List[str]:\n    \"\"\"Abstract method to build context.\"\"\"\n    pass\n</code></pre> <ol> <li>Batching and Retrieval Methods:</li> <li><code>batch_and_convert_to_text</code>: Formats graph data into token-aware text.</li> <li><code>retrieve_top_k_objects</code>: Efficiently retrieves top-K objects for query-based context.</li> </ol>"},{"location":"graphrag/msft_graphrag_4/#example-global-context-builder","title":"Example: Global Context Builder","text":"<pre><code>import tiktoken\nfrom typing import Optional, List\nfrom tigergraphx.graphrag import BaseContextBuilder\nfrom tigergraphx.core import Graph\nclass GlobalContextBuilder(BaseContextBuilder):\n    def __init__(\n        self,\n        graph: Graph,\n        token_encoder: Optional[tiktoken.Encoding] = None,\n    ):\n        \"\"\"Initialize LocalContextBuilder with graph config and token encoder.\"\"\"\n        super().__init__(\n            graph=graph,\n            single_batch=False,\n            token_encoder=token_encoder,\n        )\n    async def build_context(self) -&gt; str | List[str]:\n        \"\"\"Build local context.\"\"\"\n        context: List[str] = []\n        config = {\n            \"max_tokens\": 12000,\n            \"section_name\": \"Communities\",\n            \"return_attributes\": [\"id\", \"rank\", \"title\", \"full_content\"],\n            \"limit\": 1000,\n        }\n        df = self.graph.get_nodes(\n            node_type=\"Community\",\n            return_attributes=config[\"return_attributes\"],\n            limit=config[\"limit\"],\n        )\n        if df is not None:\n            text_context = self.batch_and_convert_to_text(\n                graph_data=df,\n                max_tokens=config[\"max_tokens\"],\n                single_batch=self.single_batch,\n                section_name=config[\"section_name\"],\n            )\n            context.extend(\n                text_context if isinstance(text_context, list) else [text_context]\n            )\n        return context\n</code></pre> <pre><code>2025-02-28 22:22:44,129 - datasets - INFO - PyTorch version 2.6.0 available.\n</code></pre> <p>Here\u2019s how you can utilize the custom global context builder:</p> <pre><code>&gt;&gt;&gt; global_context_builder = GlobalContextBuilder(G)\n&gt;&gt;&gt; context_list = await global_context_builder.build_context()\n&gt;&gt;&gt; # Print the first 1000 characters for easier visualization of long text\n&gt;&gt;&gt; print(context_list[0][:1000])\n</code></pre> <pre><code>-----Communities-----\nid|rank|title|full_content\n77|7.5|Community 77|# PlayStation Network and Its Ecosystem\\n\\nThe community centers around the PlayStation Network, a vital online service for PlayStation consoles, and its associated entities, including various gaming consoles and key figures in Sony. The relationships among these entities highlight the interconnectedness of gaming hardware, online services, and leadership within Sony, which collectively shape the gaming experience for users.\\n\\n## PlayStation Network as a central hub\\n\\nThe PlayStation Network serves as the core online service for various PlayStation consoles, including the PS3, PS4, and PS5. This network enables online gaming, digital media access, and social interactions among users, making it a crucial component of the PlayStation ecosystem. Its establishment marked a significant shift in how users engage with gaming, allowing for multiplayer experiences and a wide array of digital content. The network's importance\n</code></pre>"},{"location":"graphrag/msft_graphrag_4/#example-local-context-builder","title":"Example: Local Context Builder","text":"<p>To understand the functionality of the <code>LocalContextBuilder</code> class, let's review the key code from its <code>build_context</code> method.</p> <p></p> <pre><code># Retrieve top-k objects\ntop_k_objects: List[str] = await self.retrieve_top_k_objects(query, k=k)\n...\n# Iterate over different neighbor types\nfor neighbor in neighbor_types:\n    df = self.graph.get_neighbors(...)\n    if df is not None:\n        text_context = self.batch_and_convert_to_text(...)\n        context.extend(\n            text_context if isinstance(text_context, list) else [text_context]\n        )\nreturn \"\\n\\n\".join(context)\n</code></pre> <p>For full implementations of different context builders, refer to the following links:</p> <ul> <li>LocalContextBuilder Code</li> </ul> <p>Here\u2019s how you can utilize the custom local context builder:</p> <pre><code>local_builder = LocalContextBuilder(graph=graph, search_engine=search_engine)\nlocal_context = await local_builder.build_context(query=\"What are the main topics discussed in the article?\")\n</code></pre>"},{"location":"graphrag/msft_graphrag_4/#integrate-with-llm","title":"Integrate with LLM","text":"<p>After successfully building context from TigerGraph, the final step is integrating it with LLMs, including chat models and embedding models.</p> <p>We have provided an example implementation, which you can find here: Example Code.</p>"},{"location":"graphrag/msft_graphrag_4/#workflow-overview","title":"Workflow Overview","text":"<p>The integration process follows the workflow illustrated below:</p> <p></p>"},{"location":"graphrag/msft_graphrag_4/#whats-next","title":"What\u2019s Next?","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 5: Query Microsoft\u2019s GraphRAG and assess its performance.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_5/","title":"Supporting Microsoft\u2019s GraphRAG: Part 5 - Query and Evaluation","text":"<p>In the previous section, we introduct how to perform retrieve and build context, also integegration with LLM. Since there are a lot of code, we will not show them in Jupyter Notework. Instead, we put all the code under  folder. And you can run them directly using shell command.</p>"},{"location":"graphrag/msft_graphrag_5/#query","title":"Query","text":"<p>We define a POE task named <code>graphrag_query</code> as <code>python -m applications.msft_graphrag.query.main</code>. By running the command below, you can query GraphRAG. The mode can be either local or global.</p> <pre><code>!poe graphrag_query --mode local --query \"where is the world's largest man made lake\"\n</code></pre> <pre><code>\u001b[37mPoe =&gt;\u001b[0m \u001b[94mpython -m applications.msft_graphrag.query.main --mode local --query 'where is the world'\"'\"'s largest man made lake'\u001b[0m\n2025-02-28 22:42:43,708 - datasets - INFO - PyTorch version 2.6.0 available.\n2025-02-28 22:42:43,919 - applications.msft_graphrag.query.graphrag - INFO - Initializing GraphRAG with schema_path: applications/msft_graphrag/query/resources/graph_schema.yaml, loading_job_path: applications/msft_graphrag/query/resources/loading_job_config.yaml, settings_path: applications/msft_graphrag/query/resources/settings.yaml\n2025-02-28 22:42:44,157 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:42:44,158 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:42:44,158 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:42:44,158 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:42:46,028 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:42:47,809 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:42:52,001 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n------------------- Query Result:  -------------------\n## Overview of the World's Largest Man-Made Lake\n\nThe world's largest man-made lake is Lake Kariba, located on the border between Zambia and Zimbabwe. Created in the 1950s by the construction of the Kariba Dam on the Zambezi River, Lake Kariba spans an impressive surface area of approximately 5,400 square kilometers (2,080 square miles) and holds a massive volume of water. The lake was formed to provide hydroelectric power and is critical for electricity generation in the region.\n\n## Significance and Features\n\nLake Kariba is not only significant for its size but also for its ecological and economic importance. The lake supports a diverse range of wildlife and aquatic species, which contributes to local fisheries and tourism. It is a vital resource for both Zambia and Zimbabwe, impacting local communities and economies through fishing, tourism, and hydroelectricity. Furthermore, it serves as a recreational area, attracting visitors for activities such as boating, fishing, and wildlife viewing.\n\n## Historical Context\n\nThe creation of Lake Kariba had profound implications for the area, displacing communities and affecting local ecosystems. The dam construction required substantial engineering efforts and investment, which reflected the ambitions of both nations to enhance their energy capacities and economic development. Today, Lake Kariba continues to be a focal point in regional discussions about resource management and sustainable development.\n\nIn summary, Lake Kariba stands out as a remarkable feat of engineering and a crucial environmental asset, reflecting both the triumphs and challenges of human intervention in natural landscapes.\n</code></pre>"},{"location":"graphrag/msft_graphrag_5/#evaluation","title":"Evaluation","text":"<p>We define a POE task named <code>graphrag_evaluation</code> as <code>python -m applications.msft_graphrag.query.evaluation</code>. Run the command below to evaluate GraphRAG.</p> <pre><code>!poe graphrag_evaluation --mode local\n</code></pre> <pre><code>\u001b[37mPoe =&gt;\u001b[0m \u001b[94mpython -m applications.msft_graphrag.query.evaluation --mode local\u001b[0m\n2025-02-28 22:43:27,683 - applications.msft_graphrag.query.graphrag - INFO - Initializing GraphRAG with schema_path: applications/msft_graphrag/query/resources/graph_schema.yaml, loading_job_path: applications/msft_graphrag/query/resources/loading_job_config.yaml, settings_path: applications/msft_graphrag/query/resources/settings.yaml\n2025-02-28 22:43:27,882 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=True, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:43:27,882 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:43:27,882 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:43:27,882 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:43:28,629 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:43:30,423 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:43:30,423 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:43:30,423 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:43:30,423 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:43:30,779 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:43:32,210 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:43:37,740 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:43:37,750 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=True, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:43:37,750 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:43:37,750 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:43:37,750 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:43:38,458 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:43:39,940 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:43:39,940 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:43:39,940 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:43:39,940 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:43:40,711 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:43:42,074 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:43:49,618 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:43:49,621 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=True, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:43:49,621 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:43:49,621 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:43:49,621 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:43:50,029 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:43:51,468 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:43:51,468 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:43:51,468 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:43:51,468 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:43:52,074 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:43:53,478 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:43:56,219 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:43:56,221 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=True, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:43:56,221 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:43:56,221 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:43:56,221 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:43:56,685 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:43:58,223 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:43:58,223 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:43:58,224 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:43:58,224 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:43:58,938 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:00,406 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:44:06,219 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:06,222 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=True, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:06,223 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:06,223 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:06,223 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:06,924 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:08,399 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:08,399 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:08,399 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:08,399 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:09,484 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:10,911 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:44:14,399 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:14,402 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=True, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:14,402 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:14,402 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:14,402 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:15,117 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:16,606 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:16,606 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:16,606 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:16,606 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:17,673 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:19,097 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:44:23,102 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:23,105 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=True, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:23,105 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:23,105 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:23,105 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:23,412 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:24,914 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:24,915 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:24,915 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:24,915 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:25,358 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:26,721 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:44:33,752 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:33,754 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=True, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:33,754 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:33,754 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:33,755 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:34,163 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:35,493 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:35,494 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:35,494 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:35,494 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:36,132 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:37,525 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:44:42,253 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:42,258 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=True, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:42,258 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:42,258 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:42,258 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:42,970 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:44,329 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:44,329 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:44,329 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:44,329 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:44,754 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:46,112 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:44:51,878 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:51,881 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=True, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:51,882 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:51,882 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:51,882 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:52,596 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:54,463 - applications.msft_graphrag.query.graphrag - INFO - Executing query with parameters: QueryParam(mode='local', only_need_context=False, response_type='Multiple Paragraphs', top_k=20)\n2025-02-28 22:44:54,463 - applications.msft_graphrag.query.graphrag - INFO - Retrieving existing event loop.\n2025-02-28 22:44:54,463 - applications.msft_graphrag.query.graphrag - INFO - Starting asynchronous query execution.\n2025-02-28 22:44:54,463 - applications.msft_graphrag.query.graphrag - INFO - Performing local query with top_k: 20\n2025-02-28 22:44:54,952 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:44:56,477 - applications.msft_graphrag.query.graphrag - INFO - Executing final query with OpenAIChat.\n2025-02-28 22:45:03,859 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:06,727 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:06,728 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:06,746 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:06,750 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:06,805 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:06,865 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:07,240 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:07,242 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:07,855 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:08,263 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nEvaluating:   2%|\u258a                               | 1/40 [00:03&lt;02:24,  3.71s/it]2025-02-28 22:45:08,287 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:08,288 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:08,289 - openai._base_client - INFO - Retrying request to /chat/completions in 0.459660 seconds\n2025-02-28 22:45:08,290 - openai._base_client - INFO - Retrying request to /chat/completions in 0.388346 seconds\n2025-02-28 22:45:08,290 - openai._base_client - INFO - Retrying request to /chat/completions in 0.448891 seconds\n2025-02-28 22:45:08,687 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:09,167 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:09,564 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:09,732 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:09,761 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:10,156 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:10,516 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:10,902 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nEvaluating:  18%|\u2588\u2588\u2588\u2588\u2588\u258c                          | 7/40 [00:06&lt;00:27,  1.19it/s]2025-02-28 22:45:10,945 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:10,946 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:10,948 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:10,949 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:10,950 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:10,968 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:11,438 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:12,156 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nEvaluating:  20%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d                         | 8/40 [00:07&lt;00:30,  1.05it/s]2025-02-28 22:45:12,170 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:12,171 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:12,183 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:12,197 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:12,973 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:13,382 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nEvaluating:  25%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a                       | 10/40 [00:08&lt;00:23,  1.25it/s]2025-02-28 22:45:13,392 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:13,394 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:13,751 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:14,050 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nEvaluating:  32%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                     | 13/40 [00:09&lt;00:13,  1.94it/s]2025-02-28 22:45:14,065 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:14,065 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:14,468 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:14,920 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nEvaluating:  38%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b                   | 15/40 [00:10&lt;00:12,  2.05it/s]2025-02-28 22:45:14,930 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:14,932 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:14,989 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:15,691 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:15,984 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:16,213 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:16,232 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:16,438 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:16,531 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:16,541 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:16,687 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:17,172 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:17,670 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nEvaluating:  45%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589                 | 18/40 [00:13&lt;00:14,  1.51it/s]2025-02-28 22:45:17,677 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:17,679 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:17,680 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:17,843 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:18,300 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:18,673 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nEvaluating:  52%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e              | 21/40 [00:14&lt;00:10,  1.84it/s]2025-02-28 22:45:18,683 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:18,843 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:20,041 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:20,042 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:20,257 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:20,398 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:20,741 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:21,167 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nEvaluating:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d           | 25/40 [00:16&lt;00:09,  1.54it/s]2025-02-28 22:45:21,171 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:21,171 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:21,678 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:22,227 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nEvaluating:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f          | 26/40 [00:17&lt;00:10,  1.34it/s]2025-02-28 22:45:22,293 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:22,905 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:23,653 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:24,195 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:25,160 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:27,874 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:28,438 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:29,971 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:43,271 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:46,457 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:46,546 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:51,377 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:52,397 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:56,874 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:45:57,277 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:46:04,407 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-02-28 22:46:05,299 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\nEvaluating: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 40/40 [01:00&lt;00:00,  1.52s/it]\n2025-02-28 22:46:06,104 - tigergraphx.graphrag.evaluation.ragas_evaluator - INFO - Evaluation results: {'answer_relevancy': 0.8074, 'faithfulness': 0.4920, 'llm_context_precision_with_reference': 0.4000, 'context_recall': 0.3000}\n</code></pre> <p>The final line displays the evaluation results:</p> <p><code>Evaluation results: {'answer_relevancy': 0.8074, 'faithfulness': 0.4920, 'llm_context_precision_with_reference': 0.4000, 'context_recall': 0.3000}</code></p>"},{"location":"graphrag/msft_graphrag_5/#reset","title":"Reset","text":"<p>After completing the evaluation, it is recommended to clean up the environment by removing the previously created graphs.</p> <pre><code>!poe graphrag_reset\n</code></pre> <pre><code>\u001b[37mPoe =&gt;\u001b[0m \u001b[94mpython -m applications.msft_graphrag.query.reset\u001b[0m\n2025-02-28 22:49:46,395 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: GraphRAG...\n2025-02-28 22:49:50,405 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n</code></pre>"},{"location":"graphrag/msft_graphrag_5/#next-steps","title":"Next Steps","text":"<ul> <li>Supporting Simple GraphRAG: Part 1: Explore an alternative approach to implementing GraphRAG from scratch.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/simple_graphrag_1/","title":"Supporting Simple GraphRAG: Part 1 - Graph Construction and Graph Store","text":""},{"location":"graphrag/simple_graphrag_1/#introduction","title":"Introduction","text":"<p>We have introduced how to integrate TigerGraph with LightRAG and Microsoft's GraphRAG. However, both solutions have some drawbacks.  </p> <p>First, regarding the integration with LightRAG: we found that querying takes some time because it calls Graph methods like <code>get_node</code>, <code>get_node_edges</code>, etc., for individual nodes in parallel rather than in batch, which is inefficient for graph operations. Another issue is its lack of flexibility\u2014since all indexing and querying operations are predefined in LightRAG, customization is limited. For example, LightRAG uses a homogeneous graph, whereas heterogeneous graphs are widely used in real-world applications.  </p> <p>Second, regarding the integration with Microsoft's GraphRAG: we found its source code to be complex and difficult to customize. Additionally, it does not abstract the storage layer for the graph, meaning the output of the indexing process cannot be stored directly in TigerGraph. Instead, we need to convert Parquet files into a format that TigerGraph supports.  </p> <p>In this solution, we aim to create a simple, customizable approach inspired by the blog Build GraphRAG applications using Spanner Graph and LangChain. We will use the same dataset from the blog for demonstration purposes. However, when implementing LangChain's <code>LLMGraphTransformer</code>\u2014which is responsible for generating graph nodes, edges, and properties\u2014we encountered several issues. First, the schema is not expressive enough. While it allows specifying node types and edge types, it does not allow defining which node types an edge connects. Additionally, it does not allow specifying which properties belong to which nodes or edges. When reviewing the source code of the blog, we noticed extensive post-processing code to remove unwanted relationships, fix edge directions, etc. The second issue is performance\u2014this solution takes three times longer to generate the graph topology compared to ours.</p> <p>To address these limitations, we will call the LLM directly for better performance and data quality. TigerGraphX already integrates with OpenAI's chat and embedding functionality, so we will leverage these capabilities for generating the graph and embeddings during the indexing step, as well as for generating query embeddings and answers during the querying step.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from simple_graphrag_1.ipynb.</p>"},{"location":"graphrag/simple_graphrag_1/#raw-dataset","title":"Raw Dataset","text":"<p>The raw dataset focuses on retail products. Here is an example of a document:</p> <pre><code>Product: SkyHawk Zephyr Drone\nPrice: $129.99\nWeight: 220g (7.8 oz)\nThe SkyHawk Zephyr is the perfect drone for beginners. It's built for effortless flying, offering a smooth and enjoyable experience from the moment you unpack it.\n\nFeatures:\n- Simple Controls: Beginner friendly and intuitive controls, plus automatic takeoff and landing.\n- Tough Build: Designed to handle rookie mistakes, thanks to its robust construction.\n- Capture Memories: Record crisp HD photos and videos from above.\n- Extended Fun: Enjoy up to 15 minutes of flight time per charge.\n- Worry-Free Flying: Free Fly mode lets you fly without directional concerns.\n\nTake your first flight with the SkyHawk Zephyr and discover the joy of aerial views!\n\nCategory: Drone\nSegment: ['Home']\nTags: ['Photography', 'Videography']\n</code></pre> <p>As you can see, each document represents a product, with properties such as price, weight, etc., and relationships to its category, segment, tags, and more.</p>"},{"location":"graphrag/simple_graphrag_1/#create-a-graph","title":"Create a Graph","text":""},{"location":"graphrag/simple_graphrag_1/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration","text":"<p>Since our data is stored in a TigerGraph instance\u2014whether on-premise or in the cloud\u2014we need to configure the connection settings. The recommended approach is to use environment variables, such as setting them with the <code>export</code> command in the shell. Here, to illustrate the demo, we configure them within Python using the <code>os.environ</code> method. You can find more methods for configuring connection settings in Graph.__init__.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ[\"TG_HOST\"] = \"http://127.0.0.1\"\n&gt;&gt;&gt; os.environ[\"TG_USERNAME\"] = \"tigergraph\"\n&gt;&gt;&gt; os.environ[\"TG_PASSWORD\"] = \"tigergraph\"\n</code></pre>"},{"location":"graphrag/simple_graphrag_1/#define-a-graph-schema","title":"Define a Graph Schema","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>We can define a graph schema based on the raw dataset, and the schema structure is visually represented in the following image.</p> <p>.</p> <p>In this example, we will initialize a graph using the schema defined in the following Python dictionary, <code>graph_schema</code>.</p> <pre><code>&gt;&gt;&gt; from tigergraphx import Graph\n&gt;&gt;&gt; graph_schema = {\n...     \"graph_name\": \"RetailGraph\",\n...     \"nodes\": {\n...         \"Product\": {\n...             \"primary_key\": \"name\",\n...             \"attributes\": {\n...                 \"name\": \"STRING\",\n...                 \"price\": \"DOUBLE\",\n...                 \"weight\": \"DOUBLE\",\n...                 \"features\": \"STRING\",\n...             },\n...             \"vector_attributes\": {\"emb_features\": 1536},\n...         },\n...         \"Tag\": {\n...             \"primary_key\": \"name\",\n...             \"attributes\": {\n...                 \"name\": \"STRING\",\n...             },\n...         },\n...         \"Category\": {\n...             \"primary_key\": \"name\",\n...             \"attributes\": {\n...                 \"name\": \"STRING\",\n...             },\n...         },\n...         \"Segment\": {\n...             \"primary_key\": \"name\",\n...             \"attributes\": {\n...                 \"name\": \"STRING\",\n...             },\n...         },\n...         \"Bundle\": {\n...             \"primary_key\": \"name\",\n...             \"attributes\": {\n...                 \"name\": \"STRING\",\n...             },\n...         },\n...         \"Deal\": {\n...             \"primary_key\": \"name\",\n...             \"attributes\": {\n...                 \"name\": \"STRING\",\n...                 \"deal_end_date\": \"DATETIME\",\n...             },\n...         },\n...     },\n...     \"edges\": {\n...         \"In_Category\": {\n...             \"is_directed_edge\": False,\n...             \"from_node_type\": \"Product\",\n...             \"to_node_type\": \"Category\",\n...         },\n...         \"Tagged_With\": {\n...             \"is_directed_edge\": False,\n...             \"from_node_type\": \"Product\",\n...             \"to_node_type\": \"Tag\",\n...         },\n...         \"In_Segment\": {\n...             \"is_directed_edge\": False,\n...             \"from_node_type\": \"Product\",\n...             \"to_node_type\": \"Segment\",\n...         },\n...         \"In_Bundle\": {\n...             \"is_directed_edge\": False,\n...             \"from_node_type\": \"Product\",\n...             \"to_node_type\": \"Bundle\",\n...         },\n...         \"Is_Accessory_Of\": {\n...             \"is_directed_edge\": True,\n...             \"from_node_type\": \"Product\",\n...             \"to_node_type\": \"Product\",\n...         },\n...         \"Is_Upgrade_Of\": {\n...             \"is_directed_edge\": True,\n...             \"from_node_type\": \"Product\",\n...             \"to_node_type\": \"Product\",\n...         },\n...         \"Has_Deal\": {\n...             \"is_directed_edge\": False,\n...             \"from_node_type\": \"Product\",\n...             \"to_node_type\": \"Deal\",\n...         },\n...     },\n... }\n</code></pre> <p>TigerGraphX offers several methods to define the schema, including a Python dictionary, YAML file, or JSON file. Above is an example using a Python dictionary. For other methods, please refer to Graph.__init__ for more details.</p>"},{"location":"graphrag/simple_graphrag_1/#create-a-graph_1","title":"Create a Graph","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p> <pre><code>&gt;&gt;&gt; from tigergraphx import Graph\n&gt;&gt;&gt; G = Graph(graph_schema)\n</code></pre> <pre><code>2025-03-28 12:58:41,809 - tigergraphx.core.managers.schema_manager - INFO - Creating schema for graph: RetailGraph...\n2025-03-28 12:58:44,789 - tigergraphx.core.managers.schema_manager - INFO - Graph schema created successfully.\n2025-03-28 12:58:44,790 - tigergraphx.core.managers.schema_manager - INFO - Adding vector attribute(s) for graph: RetailGraph...\n2025-03-28 12:59:44,226 - tigergraphx.core.managers.schema_manager - INFO - Vector attribute(s) added successfully.\n</code></pre>"},{"location":"graphrag/simple_graphrag_1/#construct-the-graph-and-generate-the-embeddings","title":"Construct the Graph and Generate the Embeddings","text":""},{"location":"graphrag/simple_graphrag_1/#load-documents","title":"Load Documents","text":"<p>To construct the graph using LLM, we first need to load the raw dataset. The raw dataset has already been downloaded under the \"../../applications/simple_graphrag/data/retaildata\" directory, where all the documents are in \".txt\" format. We define a method called <code>load_documents</code> to load all the documents from a specified path.</p> <pre><code>&gt;&gt;&gt; import os\n... def load_documents(path):\n...     \"\"\"Load text documents from subdirectories.\"\"\"\n...     documents = []\n...     for root, _, files in os.walk(path):\n...         for file in files:\n...             if file.endswith(\".txt\"):  # Only process text files\n...                 with open(os.path.join(root, file), \"r\", encoding=\"utf-8\") as f:\n...                     documents.append(f.read())\n...     return documents\n\n&gt;&gt;&gt; document_lists = load_documents(\"../../applications/simple_graphrag/data/retaildata\")\n&gt;&gt;&gt; print(len(document_lists))\n</code></pre> <pre><code>68\n</code></pre>"},{"location":"graphrag/simple_graphrag_1/#define-the-llm-prompts","title":"Define the LLM Prompts","text":"<p>The key to enabling LLM to construct a high-quality graph is the prompt. The prompt consists of the following components:</p> <ul> <li>The graph schema we previously defined for the TigerGraph graph. It is crucial to ensure that LLM strictly adheres to this schema.</li> <li>Extraction rules, which are essential for improving data quality. During our tests, we added more rules to align the generated results with our expectations.</li> <li>Example document and expected output: This helps guide the LLM in generating the desired output.</li> <li>The document to be processed is also provided.</li> </ul> <pre><code>&gt;&gt;&gt; def generate_prompt(document):\n...     \"\"\"Generate a structured prompt for OpenAI based on document content.\"\"\"\n...     return f\"\"\"\n... You are an AI that extracts structured graph data from a given document, strictly following this schema:\n... \n... {str(graph_schema)}\n... \n... ### **Extraction Rules:**\n... - Extract the exact `name` of each entity as it appears in the document. **Do not modify, expand, or infer names.**\n... - The `Segment` can only be one of: `\"Home\"`, `\"Office\"`, or `\"Fitness\"`. If a `Segment` is not explicitly mentioned, **do not assign one**.\n... - Every `Product` must have:\n...   - A `features` property describing key characteristics.\n...   - A `price` (as a numeric value, not a string).\n...   - A `weight` (as a numeric value, not a string).\n... - Do not infer missing information. Only extract what is explicitly stated in the document.\n... - **Do not create relationships with `null` targets.** If a valid target is not available, omit the relationship from the output.\n... - If a `Category` is not mentioned explicitly, **do not generate it**.\n... - If a `Bundle` is not mentioned explicitly, **do not generate it**.\n... - If a `Deal` is not mentioned explicitly, **do not generate it**.\n... - Maintain consistent formatting for all properties.\n... - **Do not add comments to the JSON output**.\n... - If a field is missing or the value is unknown, set it as `\"\"`. \n... \n... ---\n... \n... ### **Example Document &amp; Expected Output:**\n... \n... #### **Document:**\n... ```\n... Product: SkyHawk Zephyr Drone\n... Price: $129.99\n... Weight: 220g (7.8 oz)\n... The SkyHawk Zephyr is the perfect drone for beginners. It's built for effortless flying, offering a smooth and enjoyable experience from the moment you unpack it.\n... \n... Features:\n... - Simple Controls: Beginner friendly and intuitive controls, plus automatic takeoff and landing.\n... - Tough Build: Designed to handle rookie mistakes, thanks to its robust construction.\n... - Capture Memories: Record crisp HD photos and videos from above.\n... - Extended Fun: Enjoy up to 15 minutes of flight time per charge.\n... - Worry-Free Flying: Free Fly mode lets you fly without directional concerns.\n... \n... Take your first flight with the SkyHawk Zephyr and discover the joy of aerial views!\n... \n... Category: Drone\n... Segment: ['Home']\n... Tags: ['Photography', 'Videography']\n... ```\n... \n... #### **Expected Output (JSON format):**\n... ```json\n... {{\n...   \"nodes\": [\n...     {{\"id\": \"SkyHawk Zephyr Drone\", \"type\": \"Product\", \"properties\": {{\"name\": \"SkyHawk Zephyr Drone\", \"price\": 129.99, \"weight\": 220, \"features\": \"Simple Controls: Beginner friendly and intuitive controls, plus automatic takeoff and landing. Tough Build: Designed to handle rookie mistakes, thanks to its robust construction. Capture Memories: Record crisp HD photos and videos from above. Extended Fun: Enjoy up to 15 minutes of flight time per charge. Worry-Free Flying: Free Fly mode lets you fly without directional concerns.\"}}}},\n...     {{\"id\": \"Drone\", \"type\": \"Category\", \"properties\": {{\"name\": \"Drone\"}}}},\n...     {{\"id\": \"Photography\", \"type\": \"Tag\", \"properties\": {{\"name\": \"Photography\"}}}},\n...     {{\"id\": \"Videography\", \"type\": \"Tag\", \"properties\": {{\"name\": \"Videography\"}}}},\n...     {{\"id\": \"Home\", \"type\": \"Segment\", \"properties\": {{\"name\": \"Home\"}}}}\n...   ],\n...   \"relationships\": [\n...     {{\"source\": \"SkyHawk Zephyr Drone\", \"target\": \"Drone\", \"type\": \"In_Category\"}},\n...     {{\"source\": \"SkyHawk Zephyr Drone\", \"target\": \"Photography\", \"type\": \"Tagged_With\"}},\n...     {{\"source\": \"SkyHawk Zephyr Drone\", \"target\": \"Videography\", \"type\": \"Tagged_With\"}},\n...     {{\"source\": \"SkyHawk Zephyr Drone\", \"target\": \"Home\", \"type\": \"In_Segment\"}}\n...   ]\n... }}\n... ```\n... \n... ---\n... \n... ### **Now process the following document:**\n... {document}\n... \n... **Follow the exact JSON structure as shown above.**\n... \"\"\"\n</code></pre>"},{"location":"graphrag/simple_graphrag_1/#graph-construction-and-embedding-generation","title":"Graph Construction and Embedding Generation","text":"<p>In this section, we define an asynchronous pipeline for processing documents with an LLM and structuring the extracted information into a graph format. The key components of this process are:</p> <ul> <li>Processing Individual Documents: Each document is processed using <code>process_document()</code>, which sends a request to the LLM and retrieves a structured response based on the defined prompt.</li> <li>Writing Graph Data to CSV: The <code>write_csv()</code> function saves extracted nodes and relationships into separate CSV files, enabling efficient storage and retrieval.</li> <li>Handling Multiple Documents: <code>process_all_documents()</code> processes multiple documents in parallel, extracts structured graph data, and writes it to output files.</li> <li>Generating Embeddings: If a node contains features, an embedding representation is generated using OpenAI's embedding model and stored as a node property.</li> </ul> <pre><code>&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; import aiofiles\n&gt;&gt;&gt; import json\n\n&gt;&gt;&gt; from tigergraphx.llm import OpenAIManager, OpenAIChat\n&gt;&gt;&gt; from tigergraphx.vector_search import OpenAIEmbedding\n\n&gt;&gt;&gt; async def process_document(openai_chat, document):\n...     \"\"\"Process a single document asynchronously and return structured data.\"\"\"\n...     response = await openai_chat.chat(\n...         [\n...             {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n...             {\"role\": \"user\", \"content\": generate_prompt(document)},\n...         ]\n...     )\n...     return response\n\n\n&gt;&gt;&gt; async def write_csv(filename, data_list, data_type):\n...     \"\"\"Write nodes or relationships to a CSV file asynchronously.\"\"\"\n...     async with aiofiles.open(filename, \"w\", newline=\"\") as f:\n...         if data_type == \"node\":\n...             all_keys = sorted(\n...                 {key for node in data_list for key in node[\"properties\"].keys()}\n...             )\n...             await f.write(\",\".join([\"id\", \"type\"] + all_keys) + \"\\n\")\n... \n...             for node in data_list:\n...                 row = [node[\"id\"], node[\"type\"]] + [\n...                     f'\"{str(node[\"properties\"].get(key, \"\"))}\"'\n...                     if \",\" in str(node[\"properties\"].get(key, \"\"))\n...                     else str(node[\"properties\"].get(key, \"\"))\n...                     for key in all_keys\n...                 ]\n...                 await f.write(\",\".join(row) + \"\\n\")\n... \n...         elif data_type == \"relationship\":\n...             await f.write(\"source,target\\n\")\n...             for rel in data_list:\n...                 await f.write(f\"{rel['source']},{rel['target']}\\n\")\n\n\n&gt;&gt;&gt; async def process_all_documents(\n...     openai_chat: OpenAIChat,\n...     openai_embedding: OpenAIEmbedding,\n...     document_lists,\n...     output_dir,\n... ):\n...     \"\"\"Process all documents asynchronously and write results to CSV.\"\"\"\n...     os.makedirs(output_dir, exist_ok=True)\n... \n...     tasks = [\n...         asyncio.create_task(process_document(openai_chat, doc))\n...         for doc in document_lists\n...     ]\n...     responses = await asyncio.gather(*tasks)\n... \n...     # Flatten responses and parse JSON\n...     graph_documents = []\n...     for response in responses:\n...         cleaned_response = response.strip(\"`\").replace(\n...             \"json\\n\", \"\"\n...         )  # Remove backticks and json tag\n...         try:\n...             parsed_data = json.loads(cleaned_response)\n...             graph_documents.append(parsed_data)\n...         except json.JSONDecodeError:\n...             print(f\"Error parsing JSON: {cleaned_response}\")  # Debugging\n...             continue  # Skip invalid JSON\n... \n...     # Organize nodes and relationships\n...     nodes, relationships = {}, {}\n... \n...     for doc in graph_documents:\n...         for node in doc.get(\"nodes\", []):\n...             node_type = node[\"type\"]\n...             nodes.setdefault(node_type, []).append(node)\n... \n...         for rel in doc.get(\"relationships\", []):\n...             rel_type = rel[\"type\"]\n...             relationships.setdefault(rel_type, []).append(rel)\n... \n...     # Add embeddings to the graph documents for Product nodes\n...     for node in nodes.get(\"Product\", []):\n...         if \"features\" in node.get(\"properties\", {}):\n...             embedding = await openai_embedding.generate_embedding(\n...                 node[\"properties\"][\"features\"]\n...             )\n...             node[\"properties\"][\"embedding\"] = \" \".join(map(str, embedding))\n... \n...     # Write CSV files\n...     await asyncio.gather(\n...         *[\n...             asyncio.create_task(\n...                 write_csv(\n...                     os.path.join(output_dir, f\"nodes_{node_type.lower()}.csv\"),\n...                     node_list,\n...                     \"node\",\n...                 )\n...             )\n...             for node_type, node_list in nodes.items()\n...         ],\n...         *[\n...             asyncio.create_task(\n...                 write_csv(\n...                     os.path.join(output_dir, f\"edges_{rel_type.lower()}.csv\"),\n...                     rel_list,\n...                     \"relationship\",\n...                 )\n...             )\n...             for rel_type, rel_list in relationships.items()\n...         ],\n...     )\n</code></pre> <p>After defining the functions, we configure the LLM and embedding models and execute the document processing pipeline. The steps include:</p> <ul> <li>Setting Up Logging: Minimizes unnecessary warnings from HTTP requests.</li> <li>Initializing OpenAI Components: <code>OpenAIManager</code>, <code>OpenAIChat</code>, and <code>OpenAIEmbedding</code> are initialized for LLM interaction and embedding generation.</li> <li>Defining the Output Directory: Specifies the location for storing processed CSV files.</li> <li>Running the Processing Pipeline: Executes <code>process_all_documents()</code> asynchronously to process and structure the dataset into a graph format.</li> </ul> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; logger = logging.getLogger(\"httpx\")\n&gt;&gt;&gt; logger.setLevel(logging.WARNING)\n\n&gt;&gt;&gt; openai = OpenAIManager(config={})\n&gt;&gt;&gt; openai_chat = OpenAIChat(openai, config={\"model\": \"gpt-4o-mini\"})\n&gt;&gt;&gt; openai_embedding = OpenAIEmbedding(\n...     openai, config={\"model\": \"text-embedding-3-small\"}\n... )\n\n&gt;&gt;&gt; output_dir = \"../../applications/simple_graphrag/data/output\"\n\n&gt;&gt;&gt; print(\"Starting document processing...\")\n&gt;&gt;&gt; await process_all_documents(openai_chat, openai_embedding, document_lists, output_dir)\n&gt;&gt;&gt; print(\"Document processing completed successfully!\")\n</code></pre> <pre><code>Starting document processing...\n2025-03-28 12:59:56,462 - openai._base_client - INFO - Retrying request to /chat/completions in 0.388280 seconds\n2025-03-28 12:59:56,473 - openai._base_client - INFO - Retrying request to /chat/completions in 0.444269 seconds\nDocument processing completed successfully!\n</code></pre>"},{"location":"graphrag/simple_graphrag_1/#transfer-csv-files-to-tigergraph-server","title":"Transfer CSV Files to TigerGraph Server","text":"<p>To transfer the generated CSV files to your TigerGraph server, you need to use the <code>scp</code> command. Before running the command, make sure to replace \"d\" with the correct server alias or hostname that you have configured in your <code>~/.ssh/config</code> file. For example, if your <code>~/.ssh/config</code> contains an entry like this:</p> <pre><code># Docker\nHost d\n  Hostname localhost\n  Port 14222\n  User tigergraph\n  IdentityFile ~/.ssh/tigergraph_rsa\n</code></pre> <p>You would replace \"d\" in the command with the alias <code>d</code> or the corresponding hostname you\u2019ve set up. Here's the command you need to run:</p> <pre><code>&gt;&gt;&gt; !scp ../../applications/simple_graphrag/data/output/*.csv d:/home/tigergraph/data/simple_graphrag\n</code></pre> <pre><code>/opt/homebrew/Cellar/python@3.12/3.12.6/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pty.py:95: DeprecationWarning: This process (pid=57331) is multi-threaded, use of forkpty() may lead to deadlocks in the child.\n  pid, fd = os.forkpty()\n\n\nedges_ tagged_with.csv                        100%   40    33.6KB/s   00:00    \nedges_in_bundle.csv                           100%  493   745.3KB/s   00:00    \nedges_in_category.csv                         100% 1374     2.0MB/s   00:00    \nedges_in_segment.csv                          100% 1891     3.4MB/s   00:00    \nedges_is_accessory_of.csv                     100%  478   885.8KB/s   00:00    \nedges_is_upgrade_of.csv                       100%   94   201.3KB/s   00:00    \nedges_tagged_with.csv                         100% 2746     3.6MB/s   00:00    \nnodes_bundle.csv                              100%  854     1.4MB/s   00:00    \nnodes_category.csv                            100% 1182     2.6MB/s   00:00    \nnodes_product.csv                             100% 2074KB 105.0MB/s   00:00    \nnodes_segment.csv                             100% 1265     3.1MB/s   00:00    \nnodes_tag.csv                                 100% 1791     4.1MB/s   00:00\n</code></pre>"},{"location":"graphrag/simple_graphrag_1/#load-data","title":"Load Data","text":"<p>First, let's check the total number of nodes in the graph. As anticipated, the graph is currently empty.</p> <pre><code>&gt;&gt;&gt; print(G.number_of_nodes())\n</code></pre> <pre><code>0\n</code></pre> <p>After that, we will load data into the graph using a pre-defined loading job configuration. Note that loading the data may take several seconds.</p> <pre><code>&gt;&gt;&gt; loading_job = {\n...     \"loading_job_name\": \"loading_job_retail\",\n...     \"files\": [\n...         {\n...             \"file_alias\": \"f_nodes_product\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/nodes_product.csv\",\n...             \"csv_parsing_options\": {\n...                 \"separator\": \",\",\n...                 \"header\": True,\n...                 \"EOL\": \"\\\\n\",\n...                 \"quote\": \"DOUBLE\",\n...             },\n...             \"node_mappings\": [\n...                 {\n...                     \"target_name\": \"Product\",\n...                     \"attribute_column_mappings\": {\n...                         \"name\": \"name\",\n...                         \"price\": \"price\",\n...                         \"weight\": \"weight\",\n...                         \"features\": \"features\",\n...                         \"emb_features\": 'SPLIT($\"embedding\", \" \")',\n...                     },\n...                 }\n...             ],\n...         },\n...         {\n...             \"file_alias\": \"f_nodes_tag\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/nodes_tag.csv\",\n...             \"csv_parsing_options\": {\n...                 \"separator\": \",\",\n...                 \"header\": True,\n...                 \"EOL\": \"\\\\n\",\n...                 \"quote\": \"DOUBLE\",\n...             },\n...             \"node_mappings\": [\n...                 {\n...                     \"target_name\": \"Tag\",\n...                     \"attribute_column_mappings\": {\"name\": \"name\"},\n...                 }\n...             ],\n...         },\n...         {\n...             \"file_alias\": \"f_nodes_category\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/nodes_category.csv\",\n...             \"csv_parsing_options\": {\n...                 \"separator\": \",\",\n...                 \"header\": True,\n...                 \"EOL\": \"\\\\n\",\n...                 \"quote\": \"DOUBLE\",\n...             },\n...             \"node_mappings\": [\n...                 {\n...                     \"target_name\": \"Category\",\n...                     \"attribute_column_mappings\": {\"name\": \"name\"},\n...                 }\n...             ],\n...         },\n...         {\n...             \"file_alias\": \"f_nodes_segment\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/nodes_segment.csv\",\n...             \"csv_parsing_options\": {\n...                 \"separator\": \",\",\n...                 \"header\": True,\n...                 \"EOL\": \"\\\\n\",\n...                 \"quote\": \"DOUBLE\",\n...             },\n...             \"node_mappings\": [\n...                 {\n...                     \"target_name\": \"Segment\",\n...                     \"attribute_column_mappings\": {\"name\": \"name\"},\n...                 }\n...             ],\n...         },\n...         {\n...             \"file_alias\": \"f_nodes_bundle\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/nodes_bundle.csv\",\n...             \"csv_parsing_options\": {\n...                 \"separator\": \",\",\n...                 \"header\": True,\n...                 \"EOL\": \"\\\\n\",\n...                 \"quote\": \"DOUBLE\",\n...             },\n...             \"node_mappings\": [\n...                 {\n...                     \"target_name\": \"Bundle\",\n...                     \"attribute_column_mappings\": {\"name\": \"name\"},\n...                 }\n...             ],\n...         },\n...         {\n...             \"file_alias\": \"f_edges_in_category\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/edges_in_category.csv\",\n...             \"edge_mappings\": [\n...                 {\n...                     \"target_name\": \"In_Category\",\n...                     \"source_node_column\": \"source\",\n...                     \"target_node_column\": \"target\",\n...                 }\n...             ],\n...         },\n...         {\n...             \"file_alias\": \"f_edges_tagged_with\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/edges_tagged_with.csv\",\n...             \"edge_mappings\": [\n...                 {\n...                     \"target_name\": \"Tagged_With\",\n...                     \"source_node_column\": \"source\",\n...                     \"target_node_column\": \"target\",\n...                 }\n...             ],\n...         },\n...         {\n...             \"file_alias\": \"f_edges_in_segment\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/edges_in_segment.csv\",\n...             \"edge_mappings\": [\n...                 {\n...                     \"target_name\": \"In_Segment\",\n...                     \"source_node_column\": \"source\",\n...                     \"target_node_column\": \"target\",\n...                 }\n...             ],\n...         },\n...         {\n...             \"file_alias\": \"f_edges_in_bundle\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/edges_in_bundle.csv\",\n...             \"edge_mappings\": [\n...                 {\n...                     \"target_name\": \"In_Bundle\",\n...                     \"source_node_column\": \"source\",\n...                     \"target_node_column\": \"target\",\n...                 }\n...             ],\n...         },\n...         {\n...             \"file_alias\": \"f_edges_is_accessory_of\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/edges_is_accessory_of.csv\",\n...             \"edge_mappings\": [\n...                 {\n...                     \"target_name\": \"Is_Accessory_Of\",\n...                     \"source_node_column\": \"source\",\n...                     \"target_node_column\": \"target\",\n...                 }\n...             ],\n...         },\n...         {\n...             \"file_alias\": \"f_edges_is_upgrade_of\",\n...             \"file_path\": \"/home/tigergraph/data/simple_graphrag/edges_is_upgrade_of.csv\",\n...             \"edge_mappings\": [\n...                 {\n...                     \"target_name\": \"Is_Upgrade_Of\",\n...                     \"source_node_column\": \"source\",\n...                     \"target_node_column\": \"target\",\n...                 }\n...             ],\n...         },\n...     ],\n... }\n&gt;&gt;&gt; G.load_data(loading_job)\n</code></pre> <pre><code>2025-03-28 13:01:07,369 - tigergraphx.core.managers.data_manager - INFO - Initiating data load for job: loading_job_retail...\n2025-03-28 13:01:14,751 - tigergraphx.core.managers.data_manager - INFO - Data load completed successfully.\n</code></pre> <p>Now, let's check the total number of nodes in the graph again. We should observe that some nodes have been successfully loaded into the graph.</p> <pre><code>&gt;&gt;&gt; print(G.number_of_nodes())\n</code></pre> <pre><code>102\n</code></pre>"},{"location":"graphrag/simple_graphrag_1/#next-steps","title":"Next Steps","text":"<ul> <li>Supporting Simple GraphRAG: Part 2: Learn how to retrieve context and generate answers for user queries.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/simple_graphrag_2/","title":"Supporting Simple GraphRAG: Part 2 - Context Retrieval and Answer Generation","text":"<p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from simple_graphrag_2.ipynb.</p>"},{"location":"graphrag/simple_graphrag_2/#workflow-overview","title":"Workflow Overview","text":"<p>The query process of GraphRAG follows this workflow. TigerGraphX serves as the key interface, facilitating interaction with the embedding model to generate embeddings for user queries, retrieving context from TigerGraph, and communicating with the LLM chat model to generate answers.</p> <p></p>"},{"location":"graphrag/simple_graphrag_2/#get-the-graph-from-tigergraph","title":"Get the Graph from TigerGraph","text":"<p>Since the graph has already been created in TigerGraph, redefining its schema is unnecessary. Instead, you can provide the graph name to retrieve it. TigerGraphX will verify if the graph exists in TigerGraph and, if it does, will return the corresponding graph.</p>"},{"location":"graphrag/simple_graphrag_2/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration","text":"<p>Before retrive the graph schema from TigerGraph, you shoulddefine the  TigerGraph Connection Configuration first. The recommended approach is to use environment variables, such as setting them with the <code>export</code> command in the shell. Here, to illustrate the demo, we configure them within Python using the <code>os.environ</code> method. You can find more methods for configuring connection settings in Graph.__init__.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ[\"TG_HOST\"] = \"http://127.0.0.1\"\n&gt;&gt;&gt; os.environ[\"TG_USERNAME\"] = \"tigergraph\"\n&gt;&gt;&gt; os.environ[\"TG_PASSWORD\"] = \"tigergraph\"\n</code></pre>"},{"location":"graphrag/simple_graphrag_2/#retrieve-the-graph","title":"Retrieve the Graph","text":"<p>Once a graph has been created in TigerGraph, you can retrieve it without manually defining the schema using the <code>Graph.from_db</code> method, which requires only the graph name:</p> <pre><code>&gt;&gt;&gt; from tigergraphx import Graph\n&gt;&gt;&gt; G = Graph.from_db(\"RetailGraph\")\n</code></pre>"},{"location":"graphrag/simple_graphrag_2/#context-building-writing-custom-context-builders","title":"Context Building: Writing Custom Context Builders","text":"<p>Context builders play a vital role in graph-powered RAG workflows. They transform retrieved graph data into structured, meaningful contexts for tasks such as interactions with LLMs.</p> <p>TigerGraphX simplifies this process by offering the flexible <code>BaseContextBuilder</code> class, which allows developers to define custom logic for context building. You can find the source code in this link.</p> <p>In this example, we create a simple <code>ContextBuilder</code> by implementing the <code>build_context</code> method to define how the context is constructed. The process involves:  </p> <ul> <li>Retrieving the top k relevant objects (products) using TigerGraph's vector search.  </li> <li>For each retrieved product, fetching its properties and edges.  </li> <li>Concatenating all the gathered information into a structured context and returning it.  </li> </ul> <pre><code>&gt;&gt;&gt; from typing import List\n&gt;&gt;&gt; from tigergraphx.graphrag import BaseContextBuilder\n\n&gt;&gt;&gt; class ContextBuilder(BaseContextBuilder):\n...     async def build_context(self, query: str, k: int = 10) -&gt; str | List[str]:\n...         \"\"\"Build local context.\"\"\"\n...         context: List[str] = []\n... \n...         # Retrieve top-k objects\n...         top_k_objects: List[str] = await self.retrieve_top_k_objects(\n...             query, k=k, oversample_scaler=1\n...         )\n...         if not top_k_objects:\n...             return \"\"  # Return early if no objects are retrieved\n... \n...         # Iterate over all products\n...         for product in top_k_objects:\n...             node_data = self.graph.get_node_data(product, \"Product\")\n...             edges = self.graph.get_node_edges(product, \"Product\")\n...             context.append(f\"Node Data for {product}: {node_data}\")\n...             context.append(f\"Edges for {product}: {edges}\")\n... \n...         return \"\\n\\n\".join(context)\n</code></pre> <pre><code>2025-03-28 15:15:41,490 - datasets - INFO - PyTorch version 2.6.0 available.\n</code></pre> <p>Here\u2019s how you can utilize the custom context builder to integrate it with TigerGraphX and OpenAI components:  </p> <ul> <li>Configure Vector Search: The <code>vector_db</code> settings specify that the search engine will use TigerVector to retrieve relevant Product nodes based on their <code>emb_features</code> attribute.  </li> <li>Set Up OpenAI Components: The configuration defines models for LLM, embedding, and chat, ensuring that API keys are securely managed via environment variables.  </li> <li>Initialize OpenAI and Search Engine: The <code>create_openai_components</code> function instantiates the OpenAI chat model and the vector-based search engine for retrieving relevant nodes.  </li> <li>Create Context Builder: The <code>ContextBuilder</code> is initialized with the graph and search engine, allowing it to retrieve and structure context dynamically for downstream applications.</li> </ul> <pre><code>&gt;&gt;&gt; from tigergraphx.factories import create_openai_components\n&gt;&gt;&gt; settings = {\n...     \"vector_db\": {\n...         \"type\": \"TigerVector\",\n...         \"graph_name\": \"RetailGraph\",\n...         \"node_type\": \"Product\",\n...         \"vector_attribute_name\": \"emb_features\",\n...     },\n...     \"llm\": {\n...         \"type\": \"OpenAI\",\n...         # NOTE: The api_key must be provided via the environment variable OPENAI_API_KEY\n...     },\n...     \"embedding\": {\n...         \"type\": \"OpenAI\",\n...         \"model\": \"text-embedding-3-small\",\n...     },\n...     \"chat\": {\n...         \"type\": \"OpenAI\",\n...         \"model\": \"gpt-4o-mini\",\n...     },\n... }\n&gt;&gt;&gt; (openai_chat, search_engine) = create_openai_components(settings, G)\n&gt;&gt;&gt; context_builder = ContextBuilder(graph=G, search_engine=search_engine)\n</code></pre> <p>Let's verify that the context builder functions as expected.</p> <pre><code>&gt;&gt;&gt; context = await context_builder.build_context(\"I am looking for a begginer drone. Please give me some recommendations.\")\n&gt;&gt;&gt; print(context)\n</code></pre> <pre><code>2025-03-28 15:15:46,803 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\nNode Data for SnapShot Voyager Remote Shutter Release: {'name': 'SnapShot Voyager Remote Shutter Release', 'price': 24.99, 'weight': 40, 'features': \"Reduced Camera Shake: Allows you to trigger the shutter without touching the camera, minimizing movement and ensuring sharper images. Convenient Control: Provides a comfortable and ergonomic grip with a simple button to activate the shutter. Long Cable: Offers flexibility and ease of use with a generous cable length. Easy Connection: Plugs directly into the camera's remote port for quick and simple setup.\"}\n\nEdges for SnapShot Voyager Remote Shutter Release: [('SnapShot Voyager Camera 3.0', 'SnapShot Voyager Remote Shutter Release'), ('SnapShot Voyager Remote Shutter Release', 'SnapShot Voyager Camera 3.0'), ('SnapShot Voyager Remote Shutter Release', 'Photography')]\n\nNode Data for Aura X5 Pro: {'name': 'Aura X5 Pro', 'price': 1299, 'weight': 205, 'features': 'Advanced Camera System: Featuring a 50MP primary sensor with OIS, a 12MP ultrawide lens, and a 10MP telephoto lens with 3x optical zoom, the Aura X5 Pro captures professional-quality images in any lighting conditions. Extended Battery Life: The 5000mAh battery delivers all-day power, allowing you to browse, stream, and create without worrying about running out of charge. Supports 65W fast charging. Brilliant Display: Immerse yourself in vibrant colors and sharp details on the 6.7-inch AMOLED display with a 120Hz refresh rate. Powerful Performance: Powered by the Snapdragon 8 Gen 2 processor, the Aura X5 Pro delivers lightning-fast performance for gaming, multitasking, and demanding applications. Enhanced Security: Features an in-display fingerprint sensor and advanced facial recognition for secure and convenient unlocking. Durable Design: Crafted with a premium aluminum frame and Gorilla Glass Victus+ on both the front and back for exceptional durability.'}\n\nEdges for Aura X5 Pro: [('Aura X5', 'Aura X5 Pro'), ('Aura X5 Pro', 'Phone'), ('Aura X5 Pro', 'Mobile Phones'), ('Aura X5 Pro', 'Aura X5'), ('Aura X5 Pro', 'Home')]\n\nNode Data for SnapShot Voyager Camera 3.0: {'name': 'SnapShot Voyager Camera 3.0', 'price': 249.99, 'weight': 350, 'features': 'Intuitive Interface: Navigate settings and modes effortlessly with a user-friendly touchscreen and simple controls. High-Resolution Sensor: Capture sharp, vibrant photos and videos with a 24-megapixel sensor. Optical Image Stabilization: Reduce blur from camera shake for clear images even in low light or while in motion. 4K Video Recording: Record smooth, high-definition video at 4K resolution. Built-in Wi-Fi: Easily transfer photos and videos to your smartphone or tablet for sharing. Versatile Shooting Modes: Choose from a variety of modes, including portrait, landscape, sports, and night mode. Long Battery Life: Enjoy extended shooting sessions with a long-lasting rechargeable battery.'}\n\nEdges for SnapShot Voyager Camera 3.0: [('SnapShot Voyager Lens Hood', 'SnapShot Voyager Camera 3.0'), ('SnapShot Voyager Remote Shutter Release', 'SnapShot Voyager Camera 3.0'), ('SnapShot Voyager Camera 3.0', 'Camera'), ('SnapShot Voyager Camera 3.0', 'Home'), ('SnapShot Voyager Camera 3.0', 'SnapShot Voyager Remote Shutter Release'), ('SnapShot Voyager Camera 3.0', 'SnapShot Voyager Lens Hood'), ('SnapShot Voyager Camera 3.0', 'Photography')]\n\nNode Data for AuraBook Air: {'name': 'AuraBook Air', 'price': 999, 'weight': 2.5, 'features': 'Ultra-lightweight design for maximum portability. Brilliant 13.3-inch Full HD Display. Fast and responsive performance. Long-lasting battery life for all-day use. Integrated HD webcam for video conferencing. Sleek, modern design.'}\n\nEdges for AuraBook Air: [('AuraBook Air', 'Computer'), ('AuraBook Air', 'Office'), ('AuraBook Air', 'Laptops'), ('AuraBook Air', 'Home')]\n\nNode Data for SkyHawk Zephyr Drone: {'name': 'SkyHawk Zephyr Drone', 'price': 0, 'weight': 0, 'features': 'Simple Controls: Beginner friendly and intuitive controls, plus automatic takeoff and landing. Tough Build: Designed to handle rookie mistakes, thanks to its robust construction. Capture Memories: Record crisp HD photos and videos from above. Extended Fun: Enjoy up to 15 minutes of flight time per charge. Worry-Free Flying: Free Fly mode lets you fly without directional concerns.'}\n\nEdges for SkyHawk Zephyr Drone: [('SkyHawk Zephyr 2.0 - Reach New Heights', 'SkyHawk Zephyr Drone'), ('SkyHawk Zephyr Drone', 'Videography'), ('SkyHawk Zephyr Drone', 'SkyHawk Zephyr Propeller Guards'), ('SkyHawk Zephyr Drone', 'Drone'), ('SkyHawk Zephyr Propeller Guards', 'SkyHawk Zephyr Drone'), ('SkyHawk Zephyr Extended Battery', 'SkyHawk Zephyr Drone'), ('SkyHawk Zephyr Drone', 'SkyHawk Zephyr Extended Battery'), ('SkyHawk Zephyr Drone', 'Home'), ('SkyHawk Zephyr Drone', 'SkyHawk Zephyr 2.0 - Reach New Heights'), ('SkyHawk Zephyr Drone', 'Photography')]\n\nNode Data for SkyHawk Zephyr Extended Battery: {'name': 'SkyHawk Zephyr Extended Battery', 'price': 29.99, 'weight': 70, 'features': 'Increased Capacity: Enjoy up to 25 minutes of flight time on a single charge, a 67% increase over the standard battery. Easy Installation: Seamlessly swap out with the original battery in seconds. Safe and Reliable: Built to the same high-quality standards as the SkyHawk Zephyr drone.'}\n\nEdges for SkyHawk Zephyr Extended Battery: [('SkyHawk Zephyr Drone', 'SkyHawk Zephyr Extended Battery'), ('SkyHawk Zephyr Extended Battery', 'Videography'), ('SkyHawk Zephyr Extended Battery', 'Photography'), ('SkyHawk Zephyr Extended Battery', 'SkyHawk Zephyr Drone')]\n\nNode Data for SkyHawk Zephyr 2.0 - Reach New Heights: {'name': 'SkyHawk Zephyr 2.0 - Reach New Heights', 'price': 199.99, 'weight': 250, 'features': '4K Camera: Capture breathtaking aerial footage in stunning 4K resolution with enhanced image stabilization. Extended Flight Time: Enjoy up to 20 minutes of flight time on a single charge. Increased Range: Fly farther with an extended control range of up to 1.2km (3/4 mile). Intelligent Flight Modes: Explore creative filming options with Follow Me, Orbit, and Waypoint modes. GPS-Assisted Flight: Benefit from precise positioning and enhanced safety features like Return-to-Home. Upgraded Motors: Experience smoother, more responsive flight and increased agility. Streamlined Design: A sleek and aerodynamic design for improved flight performance.'}\n\nEdges for SkyHawk Zephyr 2.0 - Reach New Heights: [('SkyHawk Zephyr Drone', 'SkyHawk Zephyr 2.0 - Reach New Heights'), ('SkyHawk Zephyr 2.0 - Reach New Heights', 'Drone'), ('SkyHawk Zephyr 2.0 - Reach New Heights', 'Photography'), ('SkyHawk Zephyr 2.0 - Reach New Heights', 'SkyHawk Zephyr Drone'), ('SkyHawk Zephyr 2.0 - Reach New Heights', 'Home'), ('SkyHawk Zephyr 2.0 - Reach New Heights', 'Videography')]\n\nNode Data for  answer questions: {'name': ' answer questions', 'price': 0, 'weight': 0, 'features': ''}\n\nEdges for  answer questions: []\n\nNode Data for SkyHawk Zephyr Propeller Guards: {'name': 'SkyHawk Zephyr Propeller Guards', 'price': 14.99, 'weight': 20, 'features': 'Enhanced Safety: Prevent accidental damage to the propellers and surroundings during flight. Lightweight Design: Minimal impact on flight performance. Easy Installation: Snap on and off in seconds for quick and convenient use. Increased Durability: Provides an extra layer of protection for your drone.'}\n\nEdges for SkyHawk Zephyr Propeller Guards: [('SkyHawk Zephyr Drone', 'SkyHawk Zephyr Propeller Guards'), ('SkyHawk Zephyr Propeller Guards', 'Photography'), ('SkyHawk Zephyr Propeller Guards', 'SkyHawk Zephyr Drone'), ('SkyHawk Zephyr Propeller Guards', 'Videography')]\n\nNode Data for ChromaJet Starter Bundle: {'name': 'ChromaJet Starter Bundle', 'price': 528, 'weight': 12, 'features': 'Complete Starter Package: Includes printer and cleaning kit for immediate use. Professional-Grade Quality: Produce high-resolution prints with exceptional color accuracy. User-Friendly Interface: Intuitive controls for easy operation, even for beginners. Versatile Media Handling: Supports a wide range of paper types and sizes. Durable Construction: Built to last, ensuring years of reliable performance.'}\n\nEdges for ChromaJet Starter Bundle: [('ChromaJet Starter Bundle', 'Printing')]\n</code></pre> <p>Congratulations! It works.  </p>"},{"location":"graphrag/simple_graphrag_2/#generate-answer","title":"Generate Answer","text":"<p>The final step is to generate an answer using the LLM.  </p>"},{"location":"graphrag/simple_graphrag_2/#define-a-prompt","title":"Define a Prompt","text":"<p>First, let's define a prompt template for the LLM to generate an answer as follows.</p> <pre><code>&gt;&gt;&gt; PROMPTS = \"\"\"---Role---\n... \n... You are a helpful assistant responding to questions about data in the tables provided.\n... \n... \n... ---Goal---\n... \n... Generate a response of the target length and format that responds to the user's question, summarizing all information in the input data tables appropriate for the response length and format, and incorporating any relevant general knowledge.\n... If you don't know the answer, just say so. Do not make anything up.\n... Do not include information where the supporting evidence for it is not provided.\n... \n... ---Target response length and format---\n... \n... {response_type}\n... \n... \n... ---Data tables---\n... \n... {context_data}\n... \n... \n... ---Goal---\n... \n... Generate a response of the target length and format that responds to the user's question, summarizing all information in the input data tables appropriate for the response length and format, and incorporating any relevant general knowledge.\n... \n... If you don't know the answer, just say so. Do not make anything up.\n... \n... Do not include information where the supporting evidence for it is not provided.\n... \n... \n... ---Target response length and format---\n... \n... {response_type}\n... \n... Add sections and commentary to the response as appropriate for the length and format. Style the response in markdown.\n... \"\"\"\n</code></pre>"},{"location":"graphrag/simple_graphrag_2/#define-a-function-to-generate-answer","title":"Define a Function to Generate Answer","text":"<p>Then let's define a <code>query</code> function that integrates the context builder and OpenAIChat to process user queries. This function retrieves relevant context from the graph, constructs a system prompt, and generates a response using the LLM.</p> <pre><code>&gt;&gt;&gt; from tigergraphx.graphrag import BaseContextBuilder\n&gt;&gt;&gt; from tigergraphx.llm import OpenAIChat\n&gt;&gt;&gt; async def query(\n...     query: str,\n...     openai_chat: OpenAIChat,\n...     context_builder: BaseContextBuilder,\n...     top_k: int = 10,\n...     only_need_context: bool = False,\n...     response_type: str = \"Multiple Paragraphs\",\n... ) -&gt; str:\n...     \"\"\"\n...     Perform a local search using the context builder and return the result.\n...     \"\"\"\n...     # Generate context using the local context builder\n...     context = await context_builder.build_context(\n...         query,\n...         k=top_k,\n...     )\n...     if only_need_context:\n...         if not isinstance(context, str):\n...             raise TypeError(\"Expected `context` to be an instance of str.\")\n...         return context\n... \n...     # Validate that context exists\n...     if not context:\n...         return \"Apologies, but I couldn't provide an answer as no relevant context was found for your query.\"\n... \n...     # Construct the system prompt using the context\n...     system_prompt = PROMPTS.format(context_data=context, response_type=response_type)\n... \n...     # Perform the query using OpenAIChat\n...     try:\n...         response = await openai_chat.chat(\n...             [\n...                 {\"role\": \"system\", \"content\": system_prompt},\n...                 {\"role\": \"user\", \"content\": query},\n...             ]\n...         )\n...         return response\n...     except Exception:\n...         return \"An error occurred while processing the query.\"\n</code></pre>"},{"location":"graphrag/simple_graphrag_2/#run-the-function-to-generate-an-answer","title":"Run the Function to Generate an Answer","text":"<p>Great job! The final step is to provide a question and call the function to generate an answer.</p> <pre><code>&gt;&gt;&gt; result = await query(\n...     query=\"I am looking for a begginer drone. Please give me some recommendations.\",\n...     openai_chat=openai_chat,\n...     context_builder=context_builder,\n...     only_need_context=False,\n... )\n&gt;&gt;&gt; print(result)\n</code></pre> <pre><code>2025-03-28 15:15:53,971 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-03-28 15:16:04,309 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n### Recommendations for Beginner Drones\n\nWhen it comes to selecting a beginner-friendly drone, it's essential to consider ease of use, durability, and features that enhance the flying experience. Based on available data, here are two excellent options for beginner drones:\n\n#### 1. SkyHawk Zephyr Drone\n\n**Price:** $0 (likely indicating it comes free with a package or promotional offer)\n\n**Features:**\n- **Simple Controls:** This drone is designed with beginner-friendly and intuitive controls, plus it includes automatic takeoff and landing capabilities to ease new users into flying.\n- **Robust Build:** The SkyHawk Zephyr is constructed to withstand typical beginner mistakes, making it durable and reliable for novice pilots.\n- **Photography and Videography:** Equipped with an HD camera, it allows users to capture crisp photos and videos from above, appealing to those interested in aerial photography.\n- **Flight Time:** Users can enjoy approximately 15 minutes of flight time per charge, giving a decent amount of flying enjoyment.\n\nGiven its features, the SkyHawk Zephyr Drone is a fantastic option for newcomers to the world of drones, providing an intuitive flying experience while delivering quality content during flights.\n\n#### 2. SkyHawk Zephyr 2.0 - Reach New Heights\n\n**Price:** $199.99\n\n**Features:**\n- **4K Camera:** This drone boasts a high-quality 4K camera, perfect for capturing stunning aerial footage, appealing to users looking to create high-definition content.\n- **Extended Flight Time:** With up to 20 minutes of flight time on a single charge, users can enjoy longer flying sessions.\n- **Intelligent Flight Modes:** It offers advanced flight options such as Follow Me, Orbit, and Waypoint modes for creative filming, making it great for users interested in exploring versatile filming capabilities.\n- **GPS-Assisted Flight:** Features like Return-to-Home enhance safety for beginners, ensuring that even those new to flying can have a worry-free experience.\n\nThe SkyHawk Zephyr 2.0 presents a step up in features from the base model. It's suitable for beginners who want to grow their skills while still having access to advanced features for creative pursuits.\n\n### Conclusion\n\nBoth the SkyHawk Zephyr Drone and the SkyHawk Zephyr 2.0 are excellent choices for beginner drone enthusiasts. The former is particularly good for pure novices due to its straightforward controls and robust build, while the latter provides additional features that enhance the flying experience as users become more comfortable. When selecting a drone, consider your specific needs, such as the desire for photography or content creation, and choose the model that aligns best with those interests.\n</code></pre>"},{"location":"graphrag/simple_graphrag_2/#reset","title":"Reset","text":"<p>After completing the query, it is recommended to clean up the environment by removing the graph you created. You can drop the graph by running the following single line of code.</p> <pre><code>&gt;&gt;&gt; G.drop_graph()\n</code></pre> <pre><code>2025-03-28 15:20:17,365 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: RetailGraph...\n2025-03-28 15:20:22,112 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n</code></pre>"},{"location":"graphrag/simple_graphrag_2/#whats-next","title":"What\u2019s Next?","text":"<ul> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"reference/introduction/","title":"Introduction","text":""},{"location":"reference/introduction/#overview","title":"Overview","text":"<p>The TigerGraphX project is organized into several top-level directories, each serving a distinct purpose within the codebase. The first-level package structure is as follows:</p> <ul> <li><code>core</code>: Defines core components and the main graph-related functionality. This includes the <code>Graph</code> class, which provides a unified structure for handling both homogeneous and heterogeneous graphs. It offers a range of interfaces for performing various graph operations.</li> <li><code>vector_search</code>: Implements vector-based search functionalities, including integration with vector databases and support for TigerGraph\u2019s TigerVector feature. It also provides embedding utilities and search operations.</li> <li><code>llm</code>: Focuses on large language model (LLM) integrations. This directory contains connectors for services like OpenAI as well as chat-related utilities.</li> <li><code>config</code>: Contains configurations and settings used across the project. This includes database settings, query configurations, and settings for GraphRAG applications.</li> <li><code>graphrag</code>: Houses logic related to the GraphRAG framework.</li> <li><code>pipelines</code>: Provides components for processing data in a pipeline manner, such as handling Parquet files.</li> <li><code>utils</code>: Offers various utilities and helper functions to streamline development tasks.</li> </ul>"},{"location":"reference/introduction/#graph-class-in-tigergraphx","title":"Graph Class in TigerGraphX","text":"<p>The fundamental feature of TigerGraphX is a class named Graph. This class encapsulates the entire structure of a graph, including all nodes and edges defined by a set of node types and edge types. In other words, it supports heterogeneous graphs\u2014allowing you to work with multiple types of nodes and multiple types of edges within the same graph.</p> <p>You can create multiple instances of the <code>Graph</code> class, each identified by a unique graph name. The graph name serves as the identifier for that particular graph in TigerGraph. This design ensures isolation between graphs; when you create a new <code>Graph</code> instance with a different name, a completely separate graph is created within TigerGraph. No nodes or edges are shared between these graph instances, so each graph can be managed and queried independently.</p> <p>The <code>Graph</code> class provides a rich interface that enables you to:</p> <ul> <li> <p>Define a Graph Schema and Create a Graph:   Specify the schema\u2014detailing the various node types, edge types, and their respective attributes\u2014using flexible formats such as Python dictionaries, YAML, or JSON. The <code>Graph</code> class then uses this schema to create a new graph inside TigerGraph, ensuring that the structure adheres to your specified design.</p> </li> <li> <p>Load Data into the Graph from Files:   Once the graph schema is in place, import data into the graph from various file formats. This feature streamlines the data ingestion process and allows you to quickly populate your graph with nodes and edges.</p> </li> <li> <p>Use the Graph Library Interface:   Leverage a suite of functions and methods that are very similar to those provided by NetworkX, a popular Python library for graph processing, to perform common graph operations.</p> </li> <li> <p>Use the Graph Query Interface:   Execute complex graph queries with simplified Python-based methods. Query results are formatted as Pandas DataFrames, providing seamless integration with your analytics workflows.</p> </li> <li> <p>Leverage Vector Search Capabilities:   Enhance your graph analytics with integrated vector search functionality, enabling tasks like similarity searches and semantic queries directly within your graph.</p> </li> </ul> <p>To explore the extensive features of the Graph class, please refer to Graph.</p>"},{"location":"reference/01_core/graph/","title":"Graph","text":""},{"location":"reference/01_core/graph/#overview","title":"Overview","text":""},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph","title":"<code>Graph</code>","text":"<p>A versatile graph data structure for representing both homogeneous and heterogeneous graphs.</p> <p>This class supports a variety of graph types, including:</p> <ul> <li>Undirected Homogeneous Graphs (comparable to NetworkX's <code>Graph</code>)</li> <li>Directed Homogeneous Graphs (comparable to NetworkX's <code>DiGraph</code>)</li> <li>Undirected Homogeneous Graphs with Parallel Edges (comparable to NetworkX's <code>MultiGraph</code>)</li> <li>Directed Homogeneous Graphs with Parallel Edges (comparable to NetworkX's <code>MultiDiGraph</code>)</li> <li>Heterogeneous Graphs that can include multiple node and edge types</li> </ul> <p>By bridging established concepts from NetworkX with enhanced support for complex, heterogeneous structures, the <code>Graph</code> class provides a flexible and powerful interface for various applications in network analysis, data modeling, and beyond.</p>"},{"location":"reference/01_core/graph/#constructor","title":"Constructor","text":"<p>Examples:</p> <p>Since our data is stored in a TigerGraph instance\u2014whether on-premise or in the cloud\u2014we need to configure the connection settings. Here are three methods for connecting:</p> <ul> <li>User/password authentication</li> <li>Secret-based authentication</li> <li>Token-based authentication</li> </ul> <p>Though you set up the connection by directly assigning the <code>tigergraph_connection_config</code> parameter, it is highly recommended to use environment variables for security reasons. Environment variables can be set by running the following shell commands:</p> User/password authenticationSecret-based authenticationToken-based authentication <pre><code>export TG_HOST=http://127.0.0.1\nexport TG_USERNAME=tigergraph\nexport TG_PASSWORD=tigergraph\n# The ports below are optional unless yours are different.\nexport TG_RESTPP_PORT=14240\nexport TG_GSQL_PORT=14240\n</code></pre> <pre><code>export TG_HOST=http://127.0.0.1\nexport TG_SECRET=&lt;Your Secret&gt;\n# The ports below are optional unless yours are different.\nexport TG_RESTPP_PORT=14240\nexport TG_GSQL_PORT=14240\n</code></pre> <pre><code>export TG_HOST=http://127.0.0.1\nexport TG_TOKEN=&lt;Your Token&gt;\n# The ports below are optional unless yours are different.\nexport TG_RESTPP_PORT=14240\nexport TG_GSQL_PORT=14240\n</code></pre> <p>Note</p> <p>Both the default RESTPP and GSQL ports for TigerGraph 4 are 14240, which is consistent with TigerGraphX's default setting.</p> <p>In TigerGraph 3, the default RESTPP port is 9000 and the default GSQL port is 14240.</p> <p>If you are using TigerGraph 3 or have changed your server's port number, please set the environment variables TG_RESTPP_PORT and TG_GSQL_PORT accordingly.</p> <p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>We offer several methods to define the schema, including using a Python dictionary, YAML file, or JSON file. Below is an example of defining the same homogeneous graph\u2014with one node type and one edge type\u2014using all three approaches.</p> Python DictionaryYAMLJSON <pre><code>graph_schema = {\n    \"graph_name\": \"Social\",\n    \"nodes\": {\n        \"Person\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n                \"age\": \"UINT\",\n                \"gender\": \"STRING\",\n            },\n        },\n    },\n    \"edges\": {\n        \"Friendship\": {\n            \"is_directed_edge\": False,\n            \"from_node_type\": \"Person\",\n            \"to_node_type\": \"Person\",\n            \"attributes\": {\n                \"closeness\": \"DOUBLE\",\n            },\n        },\n    },\n}\n</code></pre> <p><pre><code>graph_schema = \"/path/to/your/schema.yaml\"\n</code></pre> The contents of the file \"/path/to/your/schema.yaml\" is as follows: <pre><code>graph_name: Social\nnodes:\n  Person:\n    primary_key: name\n    attributes:\n      name: STRING\n      age: UINT\n      gender: STRING\nedges:\n  Friendship:\n    is_directed_edge: false\n    from_node_type: Person\n    to_node_type: Person\n    attributes:\n      closeness: DOUBLE\n</code></pre></p> <p><pre><code>graph_schema = \"/path/to/your/schema.json\"\n</code></pre> The contents of the file \"/path/to/your/schema.json\" is as follows: <pre><code>{\n  \"graph_name\": \"Social\",\n  \"nodes\": {\n    \"Person\": {\n      \"primary_key\": \"name\",\n      \"attributes\": {\n        \"name\": \"STRING\",\n        \"age\": \"UINT\",\n        \"gender\": \"STRING\"\n      }\n    }\n  },\n  \"edges\": {\n    \"Friendship\": {\n      \"is_directed_edge\": false,\n      \"from_node_type\": \"Person\",\n      \"to_node_type\": \"Person\",\n      \"attributes\": {\n        \"closeness\": \"DOUBLE\"\n      }\n    }\n  }\n}\n</code></pre></p> <p>This schema defines a simple social graph where each person is represented as a node with attributes like <code>name</code>, <code>age</code>, and <code>gender</code>. Relationships between people are modeled as undirected \"Friendship\" edges, which include an attribute <code>closeness</code> to represent the strength of the connection. We will use this schema for the examples in most of the following methods.</p> <p>Once the connection configuration and schema are set up, you can create a graph using the following code.</p> <pre><code>from tigergraphx import Graph\nG = Graph(graph_schema)\n</code></pre> <p>Running the command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite an existing graph, set the <code>drop_existing_graph</code> parameter to <code>True</code>.</p> <p>Note</p> <p>Creating the graph may take several seconds.</p> <p>Alternative Connection Setup Methods</p> <p>An alternative way to set up the connection is by directly assigning the <code>tigergraph_connection_config</code> parameter. Suppose we have already defined the same <code>graph_schema</code> as before. Now let's define the connection. Like the schema, the connection can be defined using a Python dictionary, YAML file, or JSON file. Below are examples of defining the same connection using all three approaches:</p> User/password authenticationSecret-based authenticationToken-based authentication <pre><code>tigergraph_connection_config = {\n    \"host\": \"http://localhost\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n}\n</code></pre> <pre><code>tigergraph_connection_config = {\n    \"host\": \"http://localhost\",\n    \"secret\": \"&lt;Your Secret&gt;\",\n}\n</code></pre> <pre><code>tigergraph_connection_config = {\n    \"host\": \"http://localhost\",\n    \"token\": \"&lt;Your Token&gt;\",\n}\n</code></pre> <p>Once the connection configuration and schema are set up, you can create a graph using the following code.</p> <pre><code>from tigergraphx import Graph\nG = Graph(graph_schema)\n</code></pre> <p>Warning</p> <p>Avoid setting the environment variables if you intend to configure the connection by directly assigning the <code>tigergraph_connection_config</code> parameter; otherwise, conflicts will occur.</p> <p>Examples:</p> <p>If a graph is already created in TigerGraph, you can easily retrieve it using the <code>from_db</code> class method. By simply providing the <code>graph_name</code>, the schema is automatically fetched, making this the most straightforward way to obtain an existing graph instance.</p> <p>Retrieve a graph named \"Social\" from the database: <pre><code>from tigergraphx import Graph\nG = Graph.from_db(\"Social\")\n</code></pre></p> <p>For details on setting the TigerGraph connection configuration, please refer to __init__.</p>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.__init__","title":"<code>__init__(graph_schema, tigergraph_connection_config=None, drop_existing_graph=False, mode='normal')</code>","text":"<p>Initialize a Graph instance.</p> <p>Parameters:</p> <ul> <li> <code>graph_schema</code>               (<code>GraphSchema | Dict | str | Path</code>)           \u2013            <p>The schema of the graph.</p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig | Dict | str | Path]</code>, default:                   <code>None</code> )           \u2013            <p>Connection configuration for TigerGraph.</p> </li> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, drop existing graph before schema creation.</p> </li> <li> <code>mode</code>               (<code>Literal['normal', 'lazy']</code>, default:                   <code>'normal'</code> )           \u2013            <p>Defines the initialization behavior. \"normal\" ensures that the schema is created if it doesn\u2019t exist, while \"lazy\" skips schema creation.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.from_db","title":"<code>from_db(graph_name, tigergraph_connection_config=None)</code>  <code>classmethod</code>","text":"<p>Retrieve an existing graph schema from TigerGraph and initialize a Graph.</p> <p>Parameters:</p> <ul> <li> <code>graph_name</code>               (<code>str</code>)           \u2013            <p>The name of the graph to retrieve.</p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig | Dict | str | Path]</code>, default:                   <code>None</code> )           \u2013            <p>Connection configuration for TigerGraph.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>An instance of Graph initialized from the database schema.</p> </li> </ul>"},{"location":"reference/01_core/graph/#nodeview","title":"NodeView","text":"<p>Examples:</p> <p><code>nodes</code> is a property of the <code>Graph</code> class. Using it allows you to get the total number of nodes, retrieve data for a specific node, and check if a node exists.</p> <p>If your graph contains only one node type, you don\u2019t need to specify the type when accessing nodes: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_nodes_from([\"Alice\", \"Mike\"])\n&gt;&gt;&gt; len(G.nodes)\n2\n&gt;&gt;&gt; G.nodes[\"Alice\"]\n{'name': 'Alice', 'age': 0, 'gender': ''}\n&gt;&gt;&gt; \"Alice\" in G.nodes\nTrue\n</code></pre></p> <p>For graphs with multiple node types, you must include the node type when accessing nodes: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_nodes_from([\"Alice\", \"Mike\"], \"Person\")\n&gt;&gt;&gt; len(G.nodes)\n2\n&gt;&gt;&gt; G.nodes[(\"Person\", \"Alice\")]\n{'name': 'Alice', 'age': 0, 'gender': ''}\n&gt;&gt;&gt; (\"Person\", \"Alice\") in G.nodes\nTrue\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.nodes","title":"<code>nodes</code>  <code>property</code>","text":"<p>Return a NodeView instance.</p> <p>Returns:</p> <ul> <li> <code>NodeView</code>           \u2013            <p>The node view for the graph.</p> </li> </ul>"},{"location":"reference/01_core/graph/#schema-operations","title":"Schema Operations","text":"<p>The following methods handle schema operations:</p> <p>Examples:</p> <p>The default schema format retrieved from the database is a Python dictionary.  <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.get_schema()\n{'graph_name': 'Social',\n 'nodes': {'Person': {'primary_key': 'name',\n   'attributes': {'name': {'data_type': &lt;DataType.STRING: 'STRING'&gt;,\n     'default_value': None},\n    'age': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None},\n    'gender': {'data_type': &lt;DataType.STRING: 'STRING'&gt;,\n     'default_value': None}},\n   'vector_attributes': {}}},\n 'edges': {'Friendship': {'is_directed_edge': False,\n   'from_node_type': 'Person',\n   'to_node_type': 'Person',\n   'discriminator': set(),\n   'attributes': {'closeness': {'data_type': &lt;DataType.DOUBLE: 'DOUBLE'&gt;,\n     'default_value': None}}}}}\n</code></pre></p> <p>To retrieve the schema in JSON format, you can use: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.get_schema(\"json\")\n'{\"graph_name\":\"Social\",\"nodes\":{\"Person\":{\"primary_key\":\"name\",\"attributes\":{\"name\":{\"data_type\":\"STRING\",\"default_value\":null},\"age\":{\"data_type\":\"UINT\",\"default_value\":null},\"gender\":{\"data_type\":\"STRING\",\"default_value\":null}},\"vector_attributes\":{}}},\"edges\":{\"Friendship\":{\"is_directed_edge\":false,\"from_node_type\":\"Person\",\"to_node_type\":\"Person\",\"discriminator\":[],\"attributes\":{\"closeness\":{\"data_type\":\"DOUBLE\",\"default_value\":null}}}}}'\n</code></pre></p> <p>Examples:</p> <p>This method is rarely used because it is already called in the constructor.</p> <p>If you do not need to drop the existing graph before creating the schema, you can use: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.create_schema()\nFalse\n</code></pre></p> <p>If you need to drop the existing graph, you can call: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.create_schema(True)\n2025-01-21 16:27:52,323 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: Social...\n2025-01-21 16:27:55,618 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n2025-01-21 16:27:55,619 - tigergraphx.core.managers.schema_manager - INFO - Creating schema for graph: Social...\n2025-01-21 16:27:58,573 - tigergraphx.core.managers.schema_manager - INFO - Graph schema created successfully.\nTrue\n</code></pre></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.drop_graph()\n2025-01-20 16:45:04,544 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: Social...\n2025-01-20 16:45:07,645 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n</code></pre>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_schema","title":"<code>get_schema(format='dict')</code>","text":"<p>Get the schema of the graph.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>Literal['json', 'dict']</code>, default:                   <code>'dict'</code> )           \u2013            <p>Format of the schema.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | Dict</code>           \u2013            <p>The graph schema.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.create_schema","title":"<code>create_schema(drop_existing_graph=False)</code>","text":"<p>Create the graph schema.</p> <p>Parameters:</p> <ul> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, drop the graph before creation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if schema was created successfully.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.drop_graph","title":"<code>drop_graph()</code>","text":"<p>Drop the graph from TigerGraph.</p>"},{"location":"reference/01_core/graph/#data-loading-operations","title":"Data Loading Operations","text":"<p>The following methods handle data loading operations:</p> <p>Examples:</p> <p>The loading job can be defined using a Python dictionary, YAML file, or JSON file. Below are examples of defining the same loading job using each format:</p> Python DictionaryYAMLJSON <pre><code>loading_job_config = {\n    \"loading_job_name\": \"loading_job_Social\",\n    \"files\": [\n        {\n            \"file_alias\": \"f_person\",\n            \"file_path\": \"/path/to/person_data.csv\",\n            \"csv_parsing_options\": {\n                \"separator\": \",\",\n                \"header\": True,\n                \"EOL\": \"\\\\n\",\n                \"quote\": \"DOUBLE\",\n            },\n            \"node_mappings\": [\n                {\n                    \"target_name\": \"Person\",\n                    \"attribute_column_mappings\": {\n                        \"name\": \"name\",\n                        \"age\": \"age\",\n                    },\n                }\n            ],\n        },\n        {\n            \"file_alias\": \"f_friendship\",\n            \"file_path\": \"/path/to/friendship_data.csv\",\n            \"edge_mappings\": [\n                {\n                    \"target_name\": \"Friendship\",\n                    \"source_node_column\": \"source\",\n                    \"target_node_column\": \"target\",\n                    \"attribute_column_mappings\": {\n                        \"closeness\": \"closeness\",\n                    },\n                }\n            ],\n        },\n    ],\n}\n</code></pre> <p><pre><code>loading_job_config = \"/path/to/your/loading_job_config.yaml\"\n</code></pre> The contents of the file \"/path/to/your/loading_job_config.yaml\" is as follows: <pre><code>loading_job_name: loading_job_Social\nfiles:\n  - file_alias: f_person\n    file_path: /path/to/person_data.csv\n    csv_parsing_options:\n      separator: \",\"\n      header: true\n      EOL: \"\\n\"\n      quote: DOUBLE\n    node_mappings:\n      - target_name: Person\n        attribute_column_mappings:\n          name: name\n          age: age\n  - file_alias: f_friendship\n    file_path: /path/to/friendship_data.csv\n    edge_mappings:\n      - target_name: Friendship\n        source_node_column: source\n        target_node_column: target\n        attribute_column_mappings:\n          closeness: closeness\n</code></pre></p> <p><pre><code>loading_job_config = \"/path/to/your/loading_job_config.json\"\n</code></pre> The contents of the file \"/path/to/your/loading_job_config.json\" is as follows: <pre><code>{\n  \"loading_job_name\": \"loading_job_Social\",\n  \"files\": [\n    {\n      \"file_alias\": \"f_person\",\n      \"file_path\": \"/path/to/person_data.csv\",\n      \"csv_parsing_options\": {\n        \"separator\": \",\",\n        \"header\": true,\n        \"EOL\": \"\\\\n\",\n        \"quote\": \"DOUBLE\"\n      },\n      \"node_mappings\": [\n        {\n          \"target_name\": \"Person\",\n          \"attribute_column_mappings\": {\n            \"name\": \"name\",\n            \"age\": \"age\"\n          }\n        }\n      ]\n    },\n    {\n      \"file_alias\": \"f_friendship\",\n      \"file_path\": \"/path/to/friendship_data.csv\",\n      \"edge_mappings\": [\n        {\n          \"target_name\": \"Friendship\",\n          \"source_node_column\": \"source\",\n          \"target_node_column\": \"target\",\n          \"attribute_column_mappings\": {\n            \"closeness\": \"closeness\"\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre></p> <p>The code above defines the configuration for a loading job into the graph. It specifies the loading job name, the files to be imported, and how the data in those files maps to graph nodes and edges.</p> <ul> <li>loading_job_name: The name of the loading job.</li> <li> <p>files: A list of file configurations.</p> <ul> <li>file_alias: A unique identifier for the file within this loading job.</li> <li>file_path: The path to the CSV file containing data to be loaded.</li> <li>csv_parsing_options: Parsing options for the CSV file. The default value is: <pre><code>{\n    \"separator\": \",\",\n    \"header\": True,\n    \"EOL\": \"\\\\n\",\n    \"quote\": \"DOUBLE\",\n}\n</code></pre> This section is optional if the user\u2019s configuration matches these defaults.</li> <li>node_mappings: For files containing node data, this maps columns in the CSV to the corresponding node attributes in the graph.</li> <li>edge_mappings: For files containing edge data, this maps columns in the CSV to the corresponding edge attributes and source/target nodes in the graph.</li> </ul> </li> </ul> <p>After the loading job is defined, we can load data by running the command below: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.load_data(loading_job_config)\n2025-02-27 17:06:48,941 - tigergraphx.core.managers.schema_manager - INFO - Creating schema for graph: Social...\n2025-02-27 17:06:52,332 - tigergraphx.core.managers.schema_manager - INFO - Graph schema created successfully.\n2025-02-27 17:06:52,353 - tigergraphx.core.managers.data_manager - INFO - Initiating data load for job: loading_job_Social...\n2025-02-27 17:06:59,944 - tigergraphx.core.managers.data_manager - INFO - Data load completed successfully.\n&gt;&gt;&gt; print(G.number_of_nodes())\n1\n&gt;&gt;&gt; print(G.number_of_edges())\n1\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.load_data","title":"<code>load_data(loading_job_config)</code>","text":"<p>Load data into the graph using the provided loading job configuration.</p> <p>Parameters:</p> <ul> <li> <code>loading_job_config</code>               (<code>LoadingJobConfig | Dict | str | Path</code>)           \u2013            <p>Loading job config.</p> </li> </ul>"},{"location":"reference/01_core/graph/#node-operations","title":"Node Operations","text":"<p>The following methods manage nodes:</p> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>add_node()</code>.</p> <p>Warning</p> <p>This method is intended for adding individual nodes, and is best suited for tiny datasets.</p> <p>For larger datasets, consider using <code>add_nodes_from</code> for small batches or <code>load_data</code> for handling large amounts of data efficiently.</p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_node(\"Alice\", age=30, gender=\"Female\")\n&gt;&gt;&gt; G.add_node(\"Mike\", age=29)\n&gt;&gt;&gt; len(G.nodes)\n2\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_node(\"Alice\", \"Person\", age=30, gender=\"Female\")\n&gt;&gt;&gt; G.add_node(\"Mike\", \"Person\", age=29)\n&gt;&gt;&gt; len(G.nodes)\n2\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>add_node()</code>.</p> <p>Warning</p> <p>This method is best suited for adding small batches of nodes. For larger datasets, consider using <code>load_data</code> to improve efficiency.</p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Add nodes using a list of node IDs only, without additional attributes\n&gt;&gt;&gt; G.add_nodes_from([\"Alice\", \"Mike\"])\n2\n&gt;&gt;&gt; # Add nodes with individual attributes using a list of (ID, attribute_dict) tuples\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding)\n2\n&gt;&gt;&gt; # Add nodes with shared attributes applied to all listed node IDs\n&gt;&gt;&gt; G.add_nodes_from([\"Alice\", \"Mike\"], age=30)\n2\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding, \"Person\")\n2\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>remove_node()</code>.</p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_node(\"Alice\", age=30, gender=\"Female\")\n&gt;&gt;&gt; len(G.nodes)\n1\n&gt;&gt;&gt; G.remove_node(\"Alice\")\nTrue\n&gt;&gt;&gt; len(G.nodes)\n0\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_node(\"Alice\", \"Person\", age=30, gender=\"Female\")\n&gt;&gt;&gt; len(G.nodes)\n1\n&gt;&gt;&gt; G.remove_node(\"Alice\", \"Person\")\nTrue\n&gt;&gt;&gt; len(G.nodes)\n0\n</code></pre></p> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>has_node()</code>.</p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_node(\"Alice\", age=30, gender=\"Female\")\n&gt;&gt;&gt; G.has_node(\"Alice\")\nTrue\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_node(\"Alice\", \"Person\", age=30, gender=\"Female\")\n&gt;&gt;&gt; G.has_node(\"Alice\", \"Person\")\nTrue\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>See also:</p> <ul> <li>NodeView.__getitem__</li> </ul> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_node(\"Alice\", age=30, gender=\"Female\")\n&gt;&gt;&gt; G.get_node_data(\"Alice\")\n{'name': 'Alice', 'age': 30, 'gender': 'Female'}\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_node(\"Alice\", \"Person\", age=30, gender=\"Female\")\n&gt;&gt;&gt; G.get_node_data(\"Alice\", \"Person\")\n{'name': 'Alice', 'age': 30, 'gender': 'Female'}\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding)\n2\n&gt;&gt;&gt; G.add_edges_from([(\"Alice\", \"Mike\")])\n1\n&gt;&gt;&gt; G.get_node_edges(\"Alice\")\n[('Alice', 'Mike')]\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding, \"Person\")\n2\n&gt;&gt;&gt; G.add_edges_from([(\"Alice\", \"Mike\")], \"Person\", \"Friendship\", \"Person\")\n1\n&gt;&gt;&gt; # Retrieve all edges connected to Alice, regardless of type\n&gt;&gt;&gt; G.get_node_edges(\"Alice\", \"Person\")\n[('Alice', 'Mike')]\n&gt;&gt;&gt; # Retrieve only edges of type \"Friendship\"\n&gt;&gt;&gt; G.get_node_edges(\"Alice\", \"Person\", \"Friendship\")\n[('Alice', 'Mike')]\n&gt;&gt;&gt; # Retrieve edges of multiple specified types.\n&gt;&gt;&gt; G.get_node_edges(\"Alice\", \"Person\", [\"Friendship\", \"Friendship\"]) \n[('Alice', 'Mike')]\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>clear()</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding, \"Person\")\n2\n&gt;&gt;&gt; len(G.nodes)\n2\n&gt;&gt;&gt; G.clear()\nTrue\n&gt;&gt;&gt; len(G.nodes)\n0\n</code></pre>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.add_node","title":"<code>add_node(node_id, node_type=None, **attr)</code>","text":"<p>Add a node to the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str | int</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the node.</p> </li> <li> <code>**attr</code>           \u2013            <p>Additional attributes for the node.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.add_nodes_from","title":"<code>add_nodes_from(nodes_for_adding, node_type=None, **attr)</code>","text":"<p>Add nodes from a list of IDs or tuples of ID and attributes.</p> <p>Parameters:</p> <ul> <li> <code>nodes_for_adding</code>               (<code>List[str | int] | List[Tuple[str | int, Dict[str, Any]]]</code>)           \u2013            <p>List of node IDs or (ID, attributes) tuples.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the nodes.</p> </li> <li> <code>**attr</code>           \u2013            <p>Common attributes for all nodes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[int]</code>           \u2013            <p>The number of nodes added</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.remove_node","title":"<code>remove_node(node_id, node_type=None)</code>","text":"<p>Remove a node from the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str | int</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the node was removed, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.has_node","title":"<code>has_node(node_id, node_type=None)</code>","text":"<p>Check if a node exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str | int</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the node exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_node_data","title":"<code>get_node_data(node_id, node_type=None)</code>","text":"<p>Get data for a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str | int</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>The node data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_node_edges","title":"<code>get_node_edges(node_id, node_type=None, edge_types=None)</code>","text":"<p>Get edges connected to a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str | int</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the node.</p> </li> <li> <code>edge_types</code>               (<code>Optional[List[str] | str]</code>, default:                   <code>None</code> )           \u2013            <p>A list of edge types. If None, consider all edge types.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Tuple]</code>           \u2013            <p>A list of edges represented as (from_id, to_id).</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.clear","title":"<code>clear()</code>","text":"<p>Clear all nodes from the graph.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if nodes were cleared.</p> </li> </ul>"},{"location":"reference/01_core/graph/#edge-operations","title":"Edge Operations","text":"<p>The following methods manage edges:</p> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>add_nodes_from()</code>.</p> <p>Warning</p> <p>This method is intended for adding individual edges, and is best suited for tiny datasets.</p> <p>For larger datasets, consider using <code>add_edges_from</code> for small batches or <code>load_data</code> for handling large amounts of data efficiently.</p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding)\n2\n&gt;&gt;&gt; G.add_edge(\"Alice\", \"Mike\", closeness=2.5)\n&gt;&gt;&gt; G.has_edge(\"Alice\", \"Mike\")\nTrue\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding, \"Person\")\n2\n&gt;&gt;&gt; G.add_edge(\"Alice\", \"Mike\", \"Person\", \"Friendship\", \"Person\", closeness=2.5)\n&gt;&gt;&gt; G.has_edge(\"Alice\", \"Mike\", \"Person\", \"Friendship\", \"Person\")\nTrue\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>add_edges_from()</code>.</p> <p>Warning</p> <p>This method is best suited for adding small batches of edges. For larger datasets, consider using <code>load_data</code> to improve efficiency.</p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding)\n2\n&gt;&gt;&gt; # Add edges using a list of (source ID, target ID) tuples, without attributes\n&gt;&gt;&gt; G.add_edges_from([(\"Alice\", \"Mike\"), (\"Alice\", \"John\")])\n2\n&gt;&gt;&gt; # Add edges with individual attributes using (source ID, target ID, attribute_dict) tuples\n&gt;&gt;&gt; ebunch_to_add = [\n...    (\"Alice\", \"Mike\"),\n...    (\"Alice\", \"John\", {\"closeness\": 2.5}),\n... ]\n&gt;&gt;&gt; G.add_edges_from(ebunch_to_add)\n2\n&gt;&gt;&gt; # Add edges with shared attributes applied to all listed edges\n&gt;&gt;&gt; G.add_edges_from([(\"Alice\", \"Mike\"), (\"Alice\", \"John\")], closeness=2.5)\n2\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding, \"Person\")\n2\n&gt;&gt;&gt; G.add_edges_from([(\"Alice\", \"Mike\")], \"Person\", \"Friendship\", \"Person\")\n1\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>has_edge()</code>.</p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding)\n2\n&gt;&gt;&gt; G.add_edge(\"Alice\", \"Mike\")\n&gt;&gt;&gt; G.has_edge(\"Alice\", \"Mike\")\nTrue\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding, \"Person\")\n2\n&gt;&gt;&gt; G.add_edge(\"Alice\", \"Mike\", \"Person\", \"Friendship\", \"Person\")\n&gt;&gt;&gt; G.has_edge(\"Alice\", \"Mike\", \"Person\", \"Friendship\", \"Person\")\nTrue\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>get_edge_data()</code>.</p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding)\n2\n&gt;&gt;&gt; G.add_edge(\"Alice\", \"Mike\", closeness=2.5)\n&gt;&gt;&gt; G.get_edge_data(\"Alice\", \"Mike\")\n{'closeness': 2.5}\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding, \"Person\")\n2\n&gt;&gt;&gt; G.add_edge(\"Alice\", \"Mike\", \"Person\", \"Friendship\", \"Person\", closeness=2.5)\n&gt;&gt;&gt; G.get_edge_data(\"Alice\", \"Mike\", \"Person\", \"Friendship\", \"Person\")\n{'closeness': 2.5}\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.add_edge","title":"<code>add_edge(src_node_id, tgt_node_id, src_node_type=None, edge_type=None, tgt_node_type=None, **attr)</code>","text":"<p>Add an edge to the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str | int</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str | int</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Source node type.</p> </li> <li> <code>edge_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Edge type.</p> </li> <li> <code>tgt_node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Target node type.</p> </li> <li> <code>**attr</code>           \u2013            <p>Additional edge attributes.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.add_edges_from","title":"<code>add_edges_from(ebunch_to_add, src_node_type=None, edge_type=None, tgt_node_type=None, **attr)</code>","text":"<p>Add edges from a list of edge tuples.</p> <p>Parameters:</p> <ul> <li> <code>ebunch_to_add</code>               (<code>Sequence[Tuple[str | int, str | int]] | Sequence[Tuple[str | int, str | int, Dict[str, Any]]]</code>)           \u2013            <p>List of edges to add.</p> </li> <li> <code>src_node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Source node type.</p> </li> <li> <code>edge_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Edge type.</p> </li> <li> <code>tgt_node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Target node type.</p> </li> <li> <code>**attr</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Common attributes for all edges.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[int]</code>           \u2013            <p>The number of edges added</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.has_edge","title":"<code>has_edge(src_node_id, tgt_node_id, src_node_type=None, edge_type=None, tgt_node_type=None)</code>","text":"<p>Check if an edge exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str | int</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str | int</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Source node type.</p> </li> <li> <code>edge_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Edge type.</p> </li> <li> <code>tgt_node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Target node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the edge exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_edge_data","title":"<code>get_edge_data(src_node_id, tgt_node_id, src_node_type=None, edge_type=None, tgt_node_type=None)</code>","text":"<p>Get data for a specific edge.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str | int</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str | int</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Source node type.</p> </li> <li> <code>edge_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Edge type.</p> </li> <li> <code>tgt_node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Target node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | Dict[int | str, Dict] | None</code>           \u2013            <p>The edge data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#statistics-operations","title":"Statistics Operations","text":"<p>The following methods handle statistics operations:</p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding)\n2\n&gt;&gt;&gt; G.add_edges_from([(\"Alice\", \"Mike\")])\n1\n&gt;&gt;&gt; G.degree(\"Alice\")\n1\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; G.add_edges_from([(\"Alice\", \"Mike\")], \"Person\", \"Friendship\", \"Person\")\n1\n&gt;&gt;&gt; # Get the degree of node Alice for all edge types\n&gt;&gt;&gt; G.degree(\"Alice\", \"Person\")\n1\n&gt;&gt;&gt; # Get the degree of node Alice for a single edge type\n&gt;&gt;&gt; G.degree(\"Alice\", \"Person\", \"Friendship\")\n1\n&gt;&gt;&gt; # Get the degree of node Alice for multiple specified edge types.\n&gt;&gt;&gt; G.degree(\"Alice\", \"Person\", [\"Friendship\", \"Friendship\"])\n1\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>number_of_nodes()</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding, \"Person\")\n2\n&gt;&gt;&gt; # Get the total number of edges in the graph\n&gt;&gt;&gt; G.number_of_nodes()\n2\n&gt;&gt;&gt; # Get the number of edges of type \"Friendship\"\n&gt;&gt;&gt; G.number_of_nodes(\"Person\")\n2\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre> <p>Note</p> <p>This method follows a similar interface to NetworkX's <code>number_of_edges()</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; ebunch_to_add = [\n...    (\"Alice\", \"Mike\"),\n...    (\"Alice\", \"John\", {\"closeness\": 2.5}),\n... ]\n&gt;&gt;&gt; G.add_edges_from(ebunch_to_add)\n2\n&gt;&gt;&gt; # Get the total number of edges in the graph\n&gt;&gt;&gt; G.number_of_edges()\n2\n&gt;&gt;&gt; # Get the number of edges of type \"Friendship\"\n&gt;&gt;&gt; G.number_of_edges(\"Friendship\")\n2\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.degree","title":"<code>degree(node_id, node_type=None, edge_types=None)</code>","text":"<p>Get the degree of a node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str | int</code>)           \u2013            <p>Node identifier.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Node type.</p> </li> <li> <code>edge_types</code>               (<code>Optional[List[str] | str]</code>, default:                   <code>None</code> )           \u2013            <p>A list of edge types. If None, consider all edge types.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The degree of the node.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.number_of_nodes","title":"<code>number_of_nodes(node_type=None)</code>","text":"<p>Get the number of nodes in the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Type of nodes to count.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of nodes.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.number_of_edges","title":"<code>number_of_edges(edge_type=None)</code>","text":"<p>Get the number of edges in the graph.</p> <p>Parameters:</p> <ul> <li> <code>edge_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Edge type to count.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of edges.</p> </li> </ul>"},{"location":"reference/01_core/graph/#query-operations","title":"Query Operations","text":"<p>The following methods perform query operations:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29, \"gender\": \"Male\"}),\n...    (\"Emily\", {\"age\": 28, \"gender\": \"Female\"}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding, \"Person\")\n3\n&gt;&gt;&gt; # Get all nodes of type \"Person\"\n&gt;&gt;&gt; df = G.get_nodes(\"Person\")\n&gt;&gt;&gt; print(df)\n    v_id  v_type  gender   name  age\n0   Mike  Person    Male   Mike   29\n1  Emily  Person  Female  Emily   28\n2  Alice  Person  Female  Alice   30\n&gt;&gt;&gt; # Get all nodes of all types\n&gt;&gt;&gt; df = G.get_nodes(all_node_types=True)\n&gt;&gt;&gt; print(df)\n    v_id  v_type  gender   name  age\n0   Mike  Person    Male   Mike   29\n1  Alice  Person  Female  Alice   30\n2  Emily  Person  Female  Emily   28\n&gt;&gt;&gt; # Retrieve nodes with a filter expression\n&gt;&gt;&gt; df = G.get_nodes(\n...     node_type=\"Person\",\n...     node_alias=\"s\", # \"s\" is the default value, so you can remove this line\n...     filter_expression=\"s.age &gt;= 29\",\n... )\n&gt;&gt;&gt; # Retrieve women aged 29 or older\n&gt;&gt;&gt; df = G.get_nodes(node_type=\"Person\", filter_expression='s.age &gt;= 29 and s.gender == \"Female\"')\n&gt;&gt;&gt; print(df)\n    v_id  v_type  gender   name  age\n0   Mike  Person    Male   Mike   29\n1  Alice  Person  Female  Alice   30\n&gt;&gt;&gt; # Retrieve women aged 29 or older\n&gt;&gt;&gt; df = G.get_nodes(node_type=\"Person\", filter_expression='s.age &gt;= 29 and s.gender == \"Female\"')\n&gt;&gt;&gt; print(df)\n    v_id  v_type  gender   name  age\n0  Alice  Person  Female  Alice   30\n&gt;&gt;&gt; # Retrieve only specific attributes\n&gt;&gt;&gt; df = G.get_nodes(\n...     node_type=\"Person\",\n...     return_attributes=[\"name\", \"gender\"],\n... )\n&gt;&gt;&gt; print(df)\n    name  gender\n0   Mike    Male\n1  Emily  Female\n2  Alice  Female\n&gt;&gt;&gt; # Limit the number of nodes returned\n&gt;&gt;&gt; df = G.get_nodes(\n...     node_type=\"Person\",\n...     limit=1,\n... )\n&gt;&gt;&gt; print(df)\n    v_id  v_type  gender   name  age\n0  Emily  Person  Female  Emily   28\n&gt;&gt;&gt; # Retrieve \"Person\" nodes with a specific filter expression,\n&gt;&gt;&gt; # use a custom alias, request only selected attributes, and limit the results.\n&gt;&gt;&gt; df = G.get_nodes(\n...     node_type=\"Person\",\n...     filter_expression=\"s.age &gt;= 29\",\n...     return_attributes=[\"name\", \"age\"],\n...     limit=1\n... )\n&gt;&gt;&gt; print(df)\n   name  age\n0  Mike   29\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; nodes_for_adding = [\n...    (\"Alice\", {\"age\": 30, \"gender\": \"Female\"}),\n...    (\"Mike\", {\"age\": 29, \"gender\": \"Male\"}),\n...    (\"Emily\", {\"age\": 28, \"gender\": \"Female\"}),\n...    (\"John\", {\"age\": 27, \"gender\": \"Male\"}),\n...    (\"Mary\", {\"age\": 28, \"gender\": \"Female\"}),\n... ]\n&gt;&gt;&gt; G.add_nodes_from(nodes_for_adding, \"Person\")\n5\n&gt;&gt;&gt; ebunch_to_add = [\n...    (\"Alice\", \"Mike\", {\"closeness\": 1.5}),\n...    (\"Alice\", \"John\", {\"closeness\": 2.5}),\n...    (\"John\", \"Emily\", {\"closeness\": 3.5}),\n...    (\"Emily\", \"Mary\", {\"closeness\": 3.5}),\n... ]\n&gt;&gt;&gt; G.add_edges_from(ebunch_to_add)\n4\n&gt;&gt;&gt; # Get neighbors of Alice\n&gt;&gt;&gt; df = G.get_neighbors(start_nodes=\"Alice\", start_node_type=\"Person\")\n&gt;&gt;&gt; print(df)\n  gender  name  age\n0   Male  Mike   29\n1   Male  John   27\n&gt;&gt;&gt; # Get neighbors of Alice with a specific edge type\n&gt;&gt;&gt; df = G.get_neighbors(\n...     start_nodes=\"Alice\",\n...     start_node_type=\"Person\",\n...     edge_types=\"Friendship\",\n... )\n&gt;&gt;&gt; print(df)\n  gender  name  age\n0   Male  Mike   29\n1   Male  John   27\n&gt;&gt;&gt; # Get neighbors of Alice with a filter expression\n&gt;&gt;&gt; df = G.get_neighbors(\n...     start_nodes=\"Alice\",\n...     start_node_type=\"Person\",\n...     start_node_alias=\"s\", # \"s\" is the default value, so you can remove this line\n...     edge_alias=\"e\", # \"e\" is the default value, so you can remove this line\n...     target_node_alias=\"t\", # \"t\" is the default value, so you can remove this line\n...     filter_expression=\"e.closeness &gt; 1.5\",\n... )\n&gt;&gt;&gt; print(df)\n  gender  name  age\n0   Male  John   27\n&gt;&gt;&gt; # Retrieve only specific attributes for neighbors\n&gt;&gt;&gt; df = G.get_neighbors(\n...     start_nodes=\"Alice\",\n...     start_node_type=\"Person\",\n...     return_attributes=[\"name\", \"gender\"],\n... )\n&gt;&gt;&gt; print(df)\n   name gender\n0  Mike   Male\n1  John   Male\n&gt;&gt;&gt; # Limit the number of neighbors returned\n&gt;&gt;&gt; df = G.get_neighbors(\n...     start_nodes=\"Alice\",\n...     start_node_type=\"Person\",\n...     limit=1,\n... )\n&gt;&gt;&gt; print(df)\n  gender  name  age\n0   Male  Mike   29\n&gt;&gt;&gt; # Retrieve the first target node of type \"Person\" that is a friend of Alice (a \"Person\"),\n&gt;&gt;&gt; # filtering edges by \"closeness &gt; 1\" and returning the target node's \"name\" and \"gender\".\n&gt;&gt;&gt; df = G.get_neighbors(\n...     start_nodes=\"Alice\",\n...     start_node_type=\"Person\",\n...     edge_types=\"Friendship\",\n...     target_node_types=\"Person\",\n...     filter_expression=\"e.closeness &gt; 1\",\n...     return_attributes=[\"name\", \"gender\"],\n...     limit=1,\n... )\n&gt;&gt;&gt; print(df)\n   name gender\n0  Mike   Male\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Breadth First Search example\n&gt;&gt;&gt; # First hop: Retrieve neighbors of \"Alice\" of type \"Person\"\n&gt;&gt;&gt; visited = set([\"Alice\"])  # Track visited nodes\n&gt;&gt;&gt; df = G.get_neighbors(start_nodes=\"Alice\", start_node_type=\"Person\")\n&gt;&gt;&gt; primary_ids = set(df['name']) - visited  # Exclude already visited nodes\n&gt;&gt;&gt; print(primary_ids)\n{'Mike', 'John'}\n&gt;&gt;&gt; # Second hop: Retrieve neighbors of the nodes identified in the first hop\n&gt;&gt;&gt; visited.update(primary_ids)  # Mark these nodes as visited\n&gt;&gt;&gt; df = G.get_neighbors(start_nodes=primary_ids, start_node_type=\"Person\")\n&gt;&gt;&gt; primary_ids = set(df['name']) - visited  # Exclude visited nodes\n&gt;&gt;&gt; print(primary_ids)\n{'Emily'}\n&gt;&gt;&gt; # Third hop: Retrieve neighbors of the nodes identified in the second hop\n&gt;&gt;&gt; visited.update(primary_ids)  # Mark these nodes as visited\n&gt;&gt;&gt; df = G.get_neighbors(start_nodes=primary_ids, start_node_type=\"Person\")\n&gt;&gt;&gt; df = df[~df['name'].isin(visited)]  # Remove visited nodes from the final result\n&gt;&gt;&gt; print(df)\n   gender  name  age\n0  Female  Mary   28\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Alternatively, you can also use the built-in `bfs` method.\n&gt;&gt;&gt; df = G.bfs(start_nodes=[\"Alice\"], node_type=\"Person\", max_hops=3)\n&gt;&gt;&gt; print(df)\n   gender  name  age\n0  Female  Mary   28\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_nodes","title":"<code>get_nodes(node_type=None, all_node_types=False, node_alias='s', filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Retrieve nodes from the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Node type to retrieve.</p> </li> <li> <code>all_node_types</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, ignore filtering by node type.</p> </li> <li> <code>node_alias</code>               (<code>str</code>, default:                   <code>'s'</code> )           \u2013            <p>Alias for the node. Used in filter_expression.</p> </li> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of nodes to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame of nodes.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_neighbors","title":"<code>get_neighbors(start_nodes, start_node_type=None, start_node_alias='s', edge_types=None, edge_alias='e', target_node_types=None, target_node_alias='t', filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Get neighbors of specified nodes.</p> <p>Parameters:</p> <ul> <li> <code>start_nodes</code>               (<code>str | int | List[str] | List[int]</code>)           \u2013            <p>Starting node or nodes.</p> </li> <li> <code>start_node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Type of starting nodes.</p> </li> <li> <code>start_node_alias</code>               (<code>str</code>, default:                   <code>'s'</code> )           \u2013            <p>Alias for the starting node. Used in filter_expression.</p> </li> <li> <code>edge_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Edge types to consider.</p> </li> <li> <code>edge_alias</code>               (<code>str</code>, default:                   <code>'e'</code> )           \u2013            <p>Alias for the edge. Used in filter_expression.</p> </li> <li> <code>target_node_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Types of target nodes.</p> </li> <li> <code>target_node_alias</code>               (<code>str</code>, default:                   <code>'t'</code> )           \u2013            <p>Alias for the target node. Used in filter_expression.</p> </li> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of neighbors.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame of neighbors or None.</p> </li> </ul>"},{"location":"reference/01_core/graph/#vector-operations","title":"Vector Operations","text":"<p>The following methods handle vector operations:</p> <p>Note</p> <p>Vector operations are supported only on TigerGraph 4.2 and later versions, which include the TigerVector feature.</p> <p>The previous <code>Social</code> graph did not include vector attributes, which are essential for vector operations. Here, we define a new graph, <code>SocialWithVector</code>, that incorporates vector attributes, enabling tasks such as machine learning, similarity searches, and more.</p> <p>Vector attributes go beyond standard node properties by storing numerical embeddings directly in the graph schema. In most cases, specifying the attribute dimension is sufficient\u2014such as <code>\"emb_1\": 3</code> to define a 3-dimensional vector attribute. If additional customization is required, you can define properties like <code>index_type</code>, <code>data_type</code>, and <code>metric</code> using a dictionary format. For example, <code>\"emb_2\"</code> specifies these details explicitly, allowing you to tailor the vector attribute\u2019s behavior.</p> <p>Below are examples of how you can define the same graph schema\u2014with one node type, one edge type, and vector attributes\u2014using three different formats: a Python dictionary, YAML, and JSON.</p> Python DictionaryYAMLJSON <pre><code>graph_schema = {\n    \"graph_name\": \"SocialWithVector\",\n    \"nodes\": {\n        \"Person\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n                \"age\": \"UINT\",\n                \"gender\": \"STRING\",\n            },\n            \"vector_attributes\": {\n                \"emb_1\": 3,\n                \"emb_2\": {\n                    \"dimension\": 3,\n                    \"index_type\": \"HNSW\",\n                    \"data_type\": \"FLOAT\",\n                    \"metric\": \"COSINE\",\n                },\n            },\n        },\n    },\n    \"edges\": {\n        \"Friendship\": {\n            \"is_directed_edge\": False,\n            \"from_node_type\": \"Person\",\n            \"to_node_type\": \"Person\",\n            \"attributes\": {\n                \"closeness\": \"DOUBLE\",\n            },\n        },\n    },\n}\n</code></pre> <p><pre><code>graph_schema = \"/path/to/your/schema_with_vector.yaml\"\n</code></pre> The contents of the file \"/path/to/your/schema_with_vector.yaml\" are as follows: <pre><code>graph_name: SocialWithVector\nnodes:\n  Person:\n    primary_key: name\n    attributes:\n      name: STRING\n      age: UINT\n      gender: STRING\n    vector_attributes:\n      emb_1: 3\n      emb_2:\n        dimension: 3\n        index_type: HNSW\n        data_type: FLOAT\n        metric: COSINE\nedges:\n  Friendship:\n    is_directed_edge: false\n    from_node_type: Person\n    to_node_type: Person\n    attributes:\n      closeness: DOUBLE\n</code></pre></p> <p><pre><code>graph_schema = \"/path/to/your/schema_with_vector.json\"\n</code></pre> The contents of the file \"/path/to/your/schema_with_vector.json\" are as follows: <pre><code>{\n  \"graph_name\": \"SocialWithVector\",\n  \"nodes\": {\n    \"Person\": {\n      \"primary_key\": \"name\",\n      \"attributes\": {\n        \"name\": \"STRING\",\n        \"age\": \"UINT\",\n        \"gender\": \"STRING\"\n      },\n      \"vector_attributes\": {\n        \"emb_1\": 3,\n        \"emb_2\": {\n          \"dimension\": 3,\n          \"index_type\": \"HNSW\",\n          \"data_type\": \"FLOAT\",\n          \"metric\": \"COSINE\"\n        }\n      }\n    }\n  },\n  \"edges\": {\n    \"Friendship\": {\n      \"is_directed_edge\": false,\n      \"from_node_type\": \"Person\",\n      \"to_node_type\": \"Person\",\n      \"attributes\": {\n        \"closeness\": \"DOUBLE\"\n      }\n    }\n  }\n}\n</code></pre></p> <p>This schema represents a social graph where each person is a node with attributes like <code>name</code>, <code>age</code>, and <code>gender</code>. The addition of vector attributes\u2014<code>emb_1</code> and <code>emb_2</code>\u2014enables complex operations such as similarity-based queries. Relationships between people are defined as undirected \"Friendship\" edges, each with an attribute <code>closeness</code> that measures the strength of the connection.</p> <p>You can create a graph using this schema by running:</p> <pre><code>G = Graph(graph_schema)\n</code></pre> <p>This command will create a new graph using the schema if it doesn\u2019t already exist. If the graph exists, it will simply return the existing graph instance. To overwrite an existing graph, set the <code>drop_existing_graph</code> parameter to <code>True</code>.</p> <p>For details on setting the TigerGraph connection configuration, please refer to __init__.</p> <p>Note</p> <p>Creating the graph may take several seconds.</p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert a single node with vector data\n&gt;&gt;&gt; G.upsert(\n...     data={\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3]},\n... )\n1\n&gt;&gt;&gt; # Upsert multiple nodes with vector data\n&gt;&gt;&gt; G.upsert(\n...     data=[\n...         {\"name\": \"Mike\", \"age\": 29, \"gender\": \"Male\", \"emb_1\": [0.4, 0.5, 0.6]},\n...         {\"name\": \"Emily\", \"age\": 28, \"gender\": \"Female\", \"emb_1\": [0.7, 0.8, 0.9]},\n...     ],\n... )\n2\n&gt;&gt;&gt; # Get the total number of nodes in the graph\n&gt;&gt;&gt; G.number_of_nodes()\n3\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert a single node with vector data\n&gt;&gt;&gt; G.upsert(\n...     data={\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3]},\n...     node_type=\"Person\",\n... )\n1\n&gt;&gt;&gt; # Upsert multiple nodes with vector data\n&gt;&gt;&gt; G.upsert(\n...     data=[\n...         {\"name\": \"Mike\", \"age\": 29, \"gender\": \"Male\", \"emb_1\": [0.4, 0.5, 0.6]},\n...         {\"name\": \"Emily\", \"age\": 28, \"gender\": \"Female\", \"emb_1\": [0.7, 0.8, 0.9]},\n...     ],\n...     node_type=\"Person\",\n... )\n2\n&gt;&gt;&gt; # Get the total number of nodes in the graph\n&gt;&gt;&gt; G.number_of_nodes()\n3\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert a single node with vector data\n&gt;&gt;&gt; G.upsert(\n...     data={\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3]},\n... )\n1\n&gt;&gt;&gt; # Fetch vector data for a single node\n&gt;&gt;&gt; vector = G.fetch_node(\n...     node_id=\"Alice\",\n...     vector_attribute_name=\"emb_1\",\n... )\n&gt;&gt;&gt; print(vector)\n[0.1, 0.2, 0.3]\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert a single node with vector data, specifying node type\n&gt;&gt;&gt; G.upsert(\n...     data={\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3]},\n...     node_type=\"Person\",\n... )\n1\n&gt;&gt;&gt; # Fetch vector data for a single node, specifying node type\n&gt;&gt;&gt; vector = G.fetch_node(\n...     node_id=\"Alice\",\n...     vector_attribute_name=\"emb_1\",\n...     node_type=\"Person\",\n... )\n&gt;&gt;&gt; print(vector)\n[0.1, 0.2, 0.3]\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert multiple nodes with vector data\n&gt;&gt;&gt; G.upsert(\n...     data=[\n...         {\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3]},\n...         {\"name\": \"Bob\", \"age\": 32, \"gender\": \"Male\", \"emb_1\": [0.4, 0.5, 0.6]},\n...     ]\n... )\n2\n&gt;&gt;&gt; # Fetch vector data for multiple nodes\n&gt;&gt;&gt; vectors = G.fetch_nodes(\n...     node_ids=[\"Alice\", \"Bob\"],\n...     vector_attribute_name=\"emb_1\",\n... )\n&gt;&gt;&gt; print(vectors)\n{'Alice': [0.1, 0.2, 0.3], 'Bob': [0.4, 0.5, 0.6]}\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert multiple nodes with vector data, specifying node type\n&gt;&gt;&gt; G.upsert(\n...     data=[\n...         {\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3]},\n...         {\"name\": \"Bob\", \"age\": 32, \"gender\": \"Male\", \"emb_1\": [0.4, 0.5, 0.6]},\n...     ],\n...     node_type=\"Person\",\n... )\n2\n&gt;&gt;&gt; # Fetch vector data for multiple nodes, specifying node type\n&gt;&gt;&gt; vectors = G.fetch_nodes(\n...     node_ids=[\"Alice\", \"Bob\"],\n...     vector_attribute_name=\"emb_1\",\n...     node_type=\"Person\",\n... )\n&gt;&gt;&gt; print(vectors)\n{'Alice': [0.1, 0.2, 0.3], 'Bob': [0.4, 0.5, 0.6]}\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert multiple nodes with vector data\n&gt;&gt;&gt; G.upsert(\n...     data=[\n...         {\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3]},\n...         {\"name\": \"Bob\", \"age\": 32, \"gender\": \"Male\", \"emb_1\": [0.4, 0.5, 0.6]},\n...         {\"name\": \"Eve\", \"age\": 29, \"gender\": \"Female\", \"emb_1\": [0.3, 0.2, 0.1]},\n...     ]\n... )\n3\n&gt;&gt;&gt; # Search for nodes most similar to a query vector\n&gt;&gt;&gt; results = G.search(\n...     data=[0.2, 0.2, 0.2],\n...     vector_attribute_name=\"emb_1\",\n...     limit=2,\n...     return_attributes=[\"name\", \"gender\"],\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n{'id': 'Bob', 'distance': 0.01307237, 'name': 'Bob', 'gender': 'Male'}\n{'id': 'Eve', 'distance': 0.07417983, 'name': 'Eve', 'gender': 'Female'}\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert multiple nodes with vector data, specifying node type\n&gt;&gt;&gt; G.upsert(\n...     data=[\n...         {\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3]},\n...         {\"name\": \"Bob\", \"age\": 32, \"gender\": \"Male\", \"emb_1\": [0.4, 0.5, 0.6]},\n...         {\"name\": \"Eve\", \"age\": 29, \"gender\": \"Female\", \"emb_1\": [0.3, 0.2, 0.1]},\n...     ],\n...     node_type=\"Person\",\n... )\n3\n&gt;&gt;&gt; # Search for nodes most similar to a query vector, specifying node type\n&gt;&gt;&gt; results = G.search(\n...     data=[0.2, 0.2, 0.2],\n...     vector_attribute_name=\"emb_1\",\n...     node_type=\"Person\",\n...     limit=2,\n...     return_attributes=[\"name\", \"gender\"],\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n{'id': 'Bob', 'distance': 0.01307237, 'name': 'Bob', 'gender': 'Male'}\n{'id': 'Eve', 'distance': 0.07417983, 'name': 'Eve', 'gender': 'Female'}\n</code></pre></p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert multiple nodes with different vector attributes\n&gt;&gt;&gt; G.upsert(\n...     data=[\n...         {\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3], \"emb_2\": [0.2, 0.4, 0.6]},\n...         {\"name\": \"Bob\", \"age\": 32, \"gender\": \"Male\", \"emb_1\": [0.4, 0.5, 0.6], \"emb_2\": [0.5, 0.6, 0.7]},\n...         {\"name\": \"Eve\", \"age\": 29, \"gender\": \"Female\", \"emb_1\": [0.3, 0.2, 0.1], \"emb_2\": [0.1, 0.2, 0.3]},\n...     ]\n... )\n3\n&gt;&gt;&gt; # Search for nodes most similar to a query vector using multiple vector attributes\n&gt;&gt;&gt; results = G.search_multi_vector_attributes(\n...     data=[0.1, 0.2, 0.3],\n...     vector_attribute_names=[\"emb_1\", \"emb_2\"],\n...     limit=2,\n...     return_attributes_list=[[\"name\", \"gender\"], [\"name\"]],\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n{'id': 'Alice', 'distance': 1.192093e-07, 'name': 'Alice', 'gender': 'Female'}\n{'id': 'Eve', 'distance': 1.192093e-07, 'name': 'Eve'}\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert multiple nodes with vector attributes\n&gt;&gt;&gt; G.upsert(\n...     data=[\n...         {\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3], \"emb_2\": [0.2, 0.4, 0.6]},\n...         {\"name\": \"Bob\", \"age\": 32, \"gender\": \"Male\", \"emb_1\": [0.4, 0.5, 0.6], \"emb_2\": [0.5, 0.6, 0.7]},\n...         {\"name\": \"Eve\", \"age\": 29, \"gender\": \"Female\", \"emb_1\": [0.3, 0.2, 0.1], \"emb_2\": [0.1, 0.2, 0.3]},\n...     ],\n...     node_type=\"Person\",\n... )\n3\n&gt;&gt;&gt; # Search for nodes most similar to a query vector using multiple vector attributes\n&gt;&gt;&gt; results = G.search_multi_vector_attributes(\n...     data=[0.1, 0.2, 0.3],\n...     vector_attribute_names=[\"emb_1\", \"emb_2\"],\n...     node_types=[\"Person\", \"Person\"],\n...     limit=2,\n...     return_attributes_list=[[\"name\", \"gender\"], [\"name\"]],\n... )\n&gt;&gt;&gt; for result in results:\n...     print(result)\n{'id': 'Alice', 'distance': 1.192093e-07, 'name': 'Alice', 'gender': 'Female'}\n{'id': 'Bob', 'distance': 0.02536821, 'name': 'Bob', 'gender': 'Male'}\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Examples:</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert a node with vector data\n&gt;&gt;&gt; G.upsert(\n...     data=[\n...         {\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3]},\n...         {\"name\": \"Bob\", \"age\": 32, \"gender\": \"Male\", \"emb_1\": [0.1, 0.2, 0.4]},\n...         {\"name\": \"Eve\", \"age\": 29, \"gender\": \"Female\", \"emb_1\": [0.5, 0.6, 0.7]},\n...     ]\n... )\n3\n&gt;&gt;&gt; # Retrieve the top-1 nodes similar to \"Alice\" based on the emb_1 vector\n&gt;&gt;&gt; similar_nodes = G.search_top_k_similar_nodes(\n...     node_id=\"Alice\",\n...     vector_attribute_name=\"emb_1\",\n...     limit=1,\n...     return_attributes=[\"name\", \"age\", \"gender\"]\n... )\n&gt;&gt;&gt; for node in similar_nodes:\n...     print(node)\n{'id': 'Bob', 'distance': 0.008539915, 'name': 'Bob', 'age': 32, 'gender': 'Male'}\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph(graph_schema)\n&gt;&gt;&gt; # Upsert nodes with vector data\n&gt;&gt;&gt; G.upsert(\n...     data=[\n...         {\"name\": \"Alice\", \"age\": 30, \"gender\": \"Female\", \"emb_1\": [0.1, 0.2, 0.3]},\n...         {\"name\": \"Bob\", \"age\": 32, \"gender\": \"Male\", \"emb_1\": [0.1, 0.2, 0.4]},\n...         {\"name\": \"Eve\", \"age\": 29, \"gender\": \"Female\", \"emb_1\": [0.5, 0.6, 0.7]},\n...     ],\n...     node_type=\"Person\"\n... )\n3\n&gt;&gt;&gt; # Retrieve the top-5 nodes similar to \"Alice\" based on the emb_1 vector\n&gt;&gt;&gt; similar_nodes = G.search_top_k_similar_nodes(\n...     node_id=\"Alice\",\n...     vector_attribute_name=\"emb_1\",\n...     node_type=\"Person\",\n...     limit=5,\n...     return_attributes=[\"name\", \"age\", \"gender\"]\n... )\n&gt;&gt;&gt; for node in similar_nodes:\n...     print(node)\n{'id': 'Bob', 'distance': 0.008539915, 'name': 'Bob', 'age': 32, 'gender': 'Male'}\n{'id': 'Eve', 'distance': 0.03167039, 'name': 'Eve', 'age': 29, 'gender': 'Female'}\n&gt;&gt;&gt; G.clear()\nTrue\n</code></pre></p>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.upsert","title":"<code>upsert(data, node_type=None)</code>","text":"<p>Upsert nodes with vector data into the graph.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Dict | List[Dict]</code>)           \u2013            <p>Record(s) to upsert.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The node type for the upsert operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[int]</code>           \u2013            <p>The result of the upsert operation or None if an error occurs.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.fetch_node","title":"<code>fetch_node(node_id, vector_attribute_name, node_type=None)</code>","text":"<p>Fetch the embedding vector for a single node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str | int</code>)           \u2013            <p>The node's identifier.</p> </li> <li> <code>vector_attribute_name</code>               (<code>str</code>)           \u2013            <p>The vector attribute name.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List[float]]</code>           \u2013            <p>The embedding vector or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.fetch_nodes","title":"<code>fetch_nodes(node_ids, vector_attribute_name, node_type=None)</code>","text":"<p>Fetch embedding vectors for multiple nodes.</p> <p>Parameters:</p> <ul> <li> <code>node_ids</code>               (<code>List[str] | List[int]</code>)           \u2013            <p>List of node identifiers.</p> </li> <li> <code>vector_attribute_name</code>               (<code>str</code>)           \u2013            <p>The vector attribute name.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, List[float]]</code>           \u2013            <p>Mapping of node IDs to embedding vectors.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.search","title":"<code>search(data, vector_attribute_name, node_type=None, limit=10, return_attributes=None, candidate_ids=None)</code>","text":"<p>Search for similar nodes based on a query vector.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>List[float]</code>)           \u2013            <p>Query vector.</p> </li> <li> <code>vector_attribute_name</code>               (<code>str</code>)           \u2013            <p>The vector attribute name.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The node type to search.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of nearest neighbors to return.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return.</p> </li> <li> <code>candidate_ids</code>               (<code>Optional[Set[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Limit search to these node IDs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Dict]</code>           \u2013            <p>List of similar nodes and their details.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.search_multi_vector_attributes","title":"<code>search_multi_vector_attributes(data, vector_attribute_names, node_types=None, limit=10, return_attributes_list=None)</code>","text":"<p>Search for similar nodes using multiple vector attributes.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>List[float]</code>)           \u2013            <p>Query vector.</p> </li> <li> <code>vector_attribute_names</code>               (<code>List[str]</code>)           \u2013            <p>List of vector attribute names.</p> </li> <li> <code>node_types</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>List of node types corresponding to the attributes.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of nearest neighbors to return.</p> </li> <li> <code>return_attributes_list</code>               (<code>Optional[List[List[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return per node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Dict]</code>           \u2013            <p>List of similar nodes and their details.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.search_top_k_similar_nodes","title":"<code>search_top_k_similar_nodes(node_id, vector_attribute_name, node_type=None, limit=5, return_attributes=None)</code>","text":"<p>Retrieve the top-k nodes similar to a given node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str | int</code>)           \u2013            <p>The source node's identifier.</p> </li> <li> <code>vector_attribute_name</code>               (<code>str</code>)           \u2013            <p>The embedding attribute name.</p> </li> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of nodes to search.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Number of similar nodes to return.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Dict]</code>           \u2013            <p>List of similar nodes.</p> </li> </ul>"},{"location":"reference/01_core/nodeview/","title":"NodeView","text":"<p>Examples:</p> <p>To obtain a <code>NodeView</code> instance, please use <code>Graph.nodes</code>. Refer to Graph.nodes:</p> <pre><code>&gt;&gt;&gt; G = Graph.from_db(\"Social\")\n&gt;&gt;&gt; node_view = G.nodes\n&gt;&gt;&gt; len(G.nodes)\n2\n</code></pre> <p>Examples:</p> <p>Retrieve data for a node using its identifier.</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph.from_db(\"Social\")\n&gt;&gt;&gt; G.nodes[\"Alice\"]\n{'name': 'Alice', 'age': 25}\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph.from_db(\"Social\")\n&gt;&gt;&gt; G.nodes[(\"Person\", \"Alice\")]\n{'name': 'Alice', 'age': 25}\n</code></pre></p> <p>Examples:</p> <p>Check whether a node exists in the view.  </p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph.from_db(\"Social\")\n&gt;&gt;&gt; \"Alice\" in G.nodes\nTrue\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph.from_db(\"Social\")\n&gt;&gt;&gt; (\"Person\", \"Alice\") in G.nodes\nTrue\n</code></pre></p> <p>Warning</p> <p>Iterating over all nodes will retrieve all data from the database. </p> <p>This method is intended for small datasets only. For large datasets, using this method may lead to significant performance issues or excessive memory usage.</p> <p>Examples:</p> <p>Iterate over all nodes in the view.</p> <p>Single Node Type Example: <pre><code>&gt;&gt;&gt; G = Graph.from_db(\"Social\")\n&gt;&gt;&gt; for node_id in G.nodes:\n&gt;&gt;&gt;     print(node_id)\nMichael\nAlice\n</code></pre></p> <p>Multiple Node Types Example: <pre><code>&gt;&gt;&gt; G = Graph.from_db(\"Social\")\n&gt;&gt;&gt; for node_type, node_id in G.nodes:\n&gt;&gt;&gt;     print(f\"{node_type}: {node_id}\")\nPerson: Alice\nPerson: Michael\nCommunity: Photography Enthusiasts\nCommunity: Fitness and Wellness Group\n</code></pre></p> <p>Examples:</p> <p>Get the number of nodes in the view: <pre><code>&gt;&gt;&gt; len(G.nodes)\n2\n</code></pre></p>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__init__","title":"<code>__init__(graph)</code>","text":""},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve data associated with a node.</p> <p>The interpretation of <code>key</code> depends on the graph's node type configuration:</p> <ul> <li>Single Node Type: Pass the node\u2019s identifier as <code>node_id</code>. In this scenario, since the graph contains only one node type, the type is automatically assigned based on the provided <code>node_id</code>. You don\u2019t need to specify the node type explicitly.</li> <li>Multiple Node Types: Pass a tuple in the form <code>(node_type, node_id)</code>.</li> </ul>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if a node exists.</p> <p>The interpretation of <code>key</code> depends on the graph's node type configuration:</p> <ul> <li>Single Node Type: Pass the node\u2019s identifier as <code>node_id</code>. In this scenario, since the graph contains only one node type, the type is automatically assigned based on the provided <code>node_id</code>. You don\u2019t need to specify the node type explicitly.</li> <li>Multiple Node Types: Pass a tuple in the form <code>(node_type, node_id)</code>.</li> </ul>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over all nodes.</p> <p>The return value depends on the graph\u2019s node type configuration:</p> <ul> <li>Single Node Type: Each iteration returns a <code>node_id</code>.</li> <li>Multiple Node Types: Each iteration returns a tuple <code>(node_type, node_id)</code>.</li> </ul>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of nodes.</p>"},{"location":"reference/02_vector_search/embedding/","title":"Embedding","text":""},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.BaseEmbedding","title":"<code>BaseEmbedding</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for text embedding models.</p>"},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.BaseEmbedding.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the base embedding model.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseEmbeddingConfig</code>)           \u2013            <p>Configuration for the embedding model.</p> </li> </ul>"},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.BaseEmbedding.generate_embedding","title":"<code>generate_embedding(text)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Asynchronously generate an embedding for the given text.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>Input text to generate an embedding.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>A list of floats representing the text embedding.</p> </li> </ul>"},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding","title":"<code>OpenAIEmbedding</code>","text":"<p>               Bases: <code>BaseEmbedding</code>, <code>RetryMixin</code></p> <p>OpenAI Embedding model wrapper with async embedding generation and robust retries.</p>"},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding.__init__","title":"<code>__init__(llm_manager, config)</code>","text":"<p>Initialize the OpenAI Embedding wrapper.</p> <p>Parameters:</p> <ul> <li> <code>llm_manager</code>               (<code>OpenAIManager</code>)           \u2013            <p>Manager for OpenAI LLM interactions.</p> </li> <li> <code>config</code>               (<code>OpenAIEmbeddingConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for the embedding model.</p> </li> </ul>"},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding.generate_embedding","title":"<code>generate_embedding(text)</code>  <code>async</code>","text":"<p>Generate embedding asynchronously with retry for robustness.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The input text to generate embeddings for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>The normalized embedding vector.</p> </li> </ul>"},{"location":"reference/02_vector_search/search_engine/","title":"Search Engine","text":""},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.BaseSearchEngine","title":"<code>BaseSearchEngine</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for a search engine that performs text-to-vector searches in a vector store.</p>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.BaseSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the search engine with an embedding model and a vector database.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>BaseEmbedding</code>)           \u2013            <p>The model used to generate text embeddings.</p> </li> <li> <code>vector_db</code>               (<code>BaseVectorDB</code>)           \u2013            <p>The vector database for storing and querying embeddings.</p> </li> </ul>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.BaseSearchEngine.search","title":"<code>search(text, k=10, **kwargs)</code>  <code>async</code>","text":"<p>Convert text to embedding and search in the vector database.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The input text to search.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of top results to return.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments for the vector database query.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>A list of IDs corresponding to the search results.</p> </li> </ul>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.TigerVectorSearchEngine","title":"<code>TigerVectorSearchEngine</code>","text":"<p>               Bases: <code>BaseSearchEngine</code></p> <p>Search engine that performs text embedding and similarity search using OpenAI and TigerVector.</p>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.TigerVectorSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the TigerVectorSearchEngine.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>OpenAIEmbedding</code>)           \u2013            <p>The embedding model used for text-to-vector conversion.</p> </li> <li> <code>vector_db</code>               (<code>TigerVectorManager</code>)           \u2013            <p>The vector database for similarity search.</p> </li> </ul>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.NanoVectorDBSearchEngine","title":"<code>NanoVectorDBSearchEngine</code>","text":"<p>               Bases: <code>BaseSearchEngine</code></p> <p>Search engine that performs text embedding and similarity search using OpenAI and NanoVectorDB.</p>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.NanoVectorDBSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the NanoVectorDBSearchEngine.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>OpenAIEmbedding</code>)           \u2013            <p>The embedding model used for text-to-vector conversion.</p> </li> <li> <code>vector_db</code>               (<code>NanoVectorDBManager</code>)           \u2013            <p>The vector database for similarity search.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/","title":"Vector DB","text":""},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB","title":"<code>BaseVectorDB</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for managing vector database connections.</p>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the vector database connection.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseVectorDBConfig</code>)           \u2013            <p>Configuration for the vector DB connection.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.insert_data","title":"<code>insert_data(data)</code>  <code>abstractmethod</code>","text":"<p>Insert data into the vector database.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>The data to insert.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.query","title":"<code>query(query_embedding, k=10)</code>  <code>abstractmethod</code>","text":"<p>Perform a similarity search and return matching IDs.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>The vector to search with.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of nearest neighbors to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List of result IDs.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.TigerVectorManager","title":"<code>TigerVectorManager</code>","text":"<p>               Bases: <code>BaseVectorDB</code></p> <p>Manages vector database operations for TigerGraph.</p>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.TigerVectorManager.__init__","title":"<code>__init__(config, graph)</code>","text":"<p>Initialize TigerVectorManager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>TigerVectorConfig | Dict | str | Path</code>)           \u2013            <p>Config for the vector database connection, given as a config  object, dictionary, string, or path to a configuration file.</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>Graph instance for managing nodes.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.TigerVectorManager.insert_data","title":"<code>insert_data(data)</code>","text":"<p>Insert data into TigerGraph.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame containing data to be inserted.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.TigerVectorManager.query","title":"<code>query(query_embedding, k=10)</code>","text":"<p>Perform k-NN search on the vector database.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>The query embedding vector.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of nearest neighbors to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List of identifiers from the search results.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.NanoVectorDBManager","title":"<code>NanoVectorDBManager</code>","text":"<p>               Bases: <code>BaseVectorDB</code></p> <p>A wrapper class for NanoVectorDB that implements BaseVectorDB.</p>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the NanoVectorDBManager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>NanoVectorDBConfig</code>)           \u2013            <p>Configuration for NanoVectorDB.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.insert_data","title":"<code>insert_data(data)</code>","text":"<p>Insert data into NanoVectorDB.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame with data to insert.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.query","title":"<code>query(query_embedding, k=10)</code>","text":"<p>Perform a similarity search and return the result IDs.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>Embedding vector for search.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of top results to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List of IDs from the search results.</p> </li> </ul>"},{"location":"reference/03_llm/chat/","title":"Chat","text":""},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.BaseChat","title":"<code>BaseChat</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for chat models.</p>"},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.BaseChat.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the chat model with the given configuration.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseChatConfig</code>)           \u2013            <p>Configuration for the chat model.</p> </li> </ul>"},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.BaseChat.chat","title":"<code>chat(messages)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Asynchronously process the messages and return the generated response.</p> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>List[Any]</code>)           \u2013            <p>A list of messages to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The generated response.</p> </li> </ul>"},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.OpenAIChat","title":"<code>OpenAIChat</code>","text":"<p>               Bases: <code>BaseChat</code>, <code>RetryMixin</code></p> <p>Implementation of BaseChat for OpenAI models.</p>"},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.OpenAIChat.__init__","title":"<code>__init__(llm_manager, config)</code>","text":"<p>Initialize the OpenAIChat with the provided LLM manager and configuration.</p> <p>Parameters:</p> <ul> <li> <code>llm_manager</code>               (<code>OpenAIManager</code>)           \u2013            <p>Manager for OpenAI LLM interactions.</p> </li> <li> <code>config</code>               (<code>OpenAIChatConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for OpenAI chat.</p> </li> </ul>"},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.OpenAIChat.chat","title":"<code>chat(messages)</code>  <code>async</code>","text":"<p>Asynchronously process the messages and return the generated response.</p> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>List[ChatCompletionMessageParam]</code>)           \u2013            <p>List of messages for chat completion.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The generated response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RetryError</code>             \u2013            <p>If retry attempts are exhausted.</p> </li> <li> <code>Exception</code>             \u2013            <p>For any unexpected errors during processing.</p> </li> </ul>"},{"location":"reference/03_llm/llm_manager/","title":"LLM Manager","text":""},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.BaseLLMManager","title":"<code>BaseLLMManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for LLM implementations.</p>"},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.BaseLLMManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the base LLM manager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseLLMConfig</code>)           \u2013            <p>Configuration for the LLM.</p> </li> </ul>"},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.BaseLLMManager.get_llm","title":"<code>get_llm()</code>  <code>abstractmethod</code>","text":"<p>Retrieve the initialized LLM instance.</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The initialized LLM instance.</p> </li> </ul>"},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.OpenAIManager","title":"<code>OpenAIManager</code>","text":"<p>               Bases: <code>BaseLLMManager</code></p> <p>Manages an asynchronous OpenAI instance for LLM operations.</p>"},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.OpenAIManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize OpenAIManager with OpenAI settings.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>OpenAIConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for OpenAI settings.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the API key is not provided in the configuration.</p> </li> </ul>"},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.OpenAIManager.get_llm","title":"<code>get_llm()</code>","text":"<p>Retrieve the initialized async OpenAI instance.</p> <p>Returns:</p> <ul> <li> <code>AsyncOpenAI</code>           \u2013            <p>The initialized OpenAI instance.</p> </li> </ul>"},{"location":"reference/04_config/base_config/","title":"BaseConfig","text":""},{"location":"reference/04_config/base_config/#tigergraphx.config.BaseConfig","title":"<code>BaseConfig</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Base configuration class that extends Pydantic's BaseSettings. Provides utility methods to load configurations from various sources.</p>"},{"location":"reference/04_config/base_config/#tigergraphx.config.BaseConfig.ensure_config","title":"<code>ensure_config(config)</code>  <code>classmethod</code>","text":"<p>Ensure the config is an instance of the current config class.</p> <p>If the input is a dictionary, string, or path to a YAML/JSON file, it is loaded and converted into an instance of the class.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>T | Path | str | Dict</code>)           \u2013            <p>The input configuration, which can be an instance of the config class, a dictionary, a file path, or a string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>An instance of the current configuration class.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the provided file path does not exist.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the file type is unsupported.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If the input type is not supported.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/loading_job_config/","title":"Loading Job Configuration","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig","title":"<code>LoadingJobConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for a loading job consisting of multiple files.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.loading_job_name","title":"<code>loading_job_name = Field(description='The name of the loading job.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.files","title":"<code>files = Field(description='A list of files included in the loading job.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.validate_file_aliases","title":"<code>validate_file_aliases()</code>","text":"<p>Ensure that all file_alias values are unique.</p> <p>Returns:</p> <ul> <li> <code>LoadingJobConfig</code>           \u2013            <p>The validated loading job configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If duplicate file_alias values are found.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig","title":"<code>FileConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for a single file used in a loading job.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.file_alias","title":"<code>file_alias = Field(description='An alias for the file, used as a reference.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.file_path","title":"<code>file_path = Field(default=None, description='The path to the file on disk.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.csv_parsing_options","title":"<code>csv_parsing_options = Field(default_factory=CsvParsingOptions, description='Options for parsing the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.node_mappings","title":"<code>node_mappings = Field(default=[], description='Node mappings defined for this file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.edge_mappings","title":"<code>edge_mappings = Field(default=[], description='Edge mappings defined for this file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.validate_mappings","title":"<code>validate_mappings()</code>","text":"<p>Ensure that at least one mapping (node or edge) exists.</p> <p>Returns:</p> <ul> <li> <code>FileConfig</code>           \u2013            <p>The validated file configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no node or edge mappings are provided.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions","title":"<code>CsvParsingOptions</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration options for CSV parsing.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.separator","title":"<code>separator = Field(default=',', description='The separator used in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.header","title":"<code>header = Field(default=True, description='Whether the CSV file contains a header row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.EOL","title":"<code>EOL = Field(default='\\\\n', description='The end-of-line character in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.quote","title":"<code>quote = Field(default=QuoteType.DOUBLE, description='The type of quote used in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig","title":"<code>NodeMappingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for mapping node attributes from a file to the target schema.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig.target_name","title":"<code>target_name = Field(description='The name of the target node type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig.attribute_column_mappings","title":"<code>attribute_column_mappings = Field(default={}, description='Mapping file columns to node attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig","title":"<code>EdgeMappingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for mapping edge attributes from a file to the target schema.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.target_name","title":"<code>target_name = Field(description='The target edge type name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.source_node_column","title":"<code>source_node_column = Field(description='The column representing the source node in the file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.target_node_column","title":"<code>target_node_column = Field(description='The column representing the target node in the file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.attribute_column_mappings","title":"<code>attribute_column_mappings = Field(default={}, description='Mappings between file columns and edge attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/","title":"Schema Configuration","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema","title":"<code>GraphSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph, including nodes and edges.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.graph_name","title":"<code>graph_name = Field(description='The name of the graph.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.nodes","title":"<code>nodes = Field(description='A dictionary of node type names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.edges","title":"<code>edges = Field(description='A dictionary of edge type names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.validate_edge_references","title":"<code>validate_edge_references()</code>","text":"<p>Ensure all edges reference existing nodes in the graph schema.</p> <p>Returns:</p> <ul> <li> <code>GraphSchema</code>           \u2013            <p>The validated graph schema.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If any edge references undefined node types.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema","title":"<code>NodeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph node type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.primary_key","title":"<code>primary_key = Field(description='The primary key for the node type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.attributes","title":"<code>attributes = Field(default_factory=dict, description='A dictionary of attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.vector_attributes","title":"<code>vector_attributes = Field(default_factory=dict, description='A dictionary of vector attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.parse_attributes","title":"<code>parse_attributes(values)</code>","text":"<p>Parse shorthand attributes into full AttributeSchema.</p> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Input values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Parsed values with attributes as AttributeSchema.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.validate_primary_key_and_attributes","title":"<code>validate_primary_key_and_attributes()</code>","text":"<p>Validate that the primary key is present in attributes.</p> <p>Returns:</p> <ul> <li> <code>NodeSchema</code>           \u2013            <p>The validated node schema.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the primary key is not defined in attributes.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema","title":"<code>EdgeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph edge type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.is_directed_edge","title":"<code>is_directed_edge = Field(default=False, description='Whether the edge is directed.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.from_node_type","title":"<code>from_node_type = Field(description='The type of the source node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.to_node_type","title":"<code>to_node_type = Field(description='The type of the target node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.discriminator","title":"<code>discriminator = Field(default_factory=set, description='An attribute or set of attributes that uniquely identifies an edge in a graph, distinguishing it from other edges with the same source and target.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.attributes","title":"<code>attributes = Field(default_factory=dict, description='A dictionary of attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.parse_attributes","title":"<code>parse_attributes(values)</code>","text":"<p>Parse shorthand attributes into full AttributeSchema.</p> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Input values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Parsed values with attributes as AttributeSchema.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.validate_discriminator_and_attributes","title":"<code>validate_discriminator_and_attributes()</code>","text":"<p>Validate that every discriminator is present in attributes.</p> <p>Returns:</p> <ul> <li> <code>EdgeSchema</code>           \u2013            <p>The validated edge schema.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If any discriminator is not defined in attributes.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema","title":"<code>AttributeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph attribute.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.data_type","title":"<code>data_type = Field(description='The data type of the attribute.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.default_value","title":"<code>default_value = Field(default=None, description='The default value for the attribute.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.PYTHON_TYPES","title":"<code>PYTHON_TYPES = {DataType.INT: int, DataType.UINT: int, DataType.FLOAT: (float, int), DataType.DOUBLE: (float, int), DataType.BOOL: bool, DataType.STRING: str, DataType.DATETIME: str}</code>  <code>class-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.validate_default_value","title":"<code>validate_default_value()</code>","text":"<p>Validate that the default value matches the expected data type.</p> <p>Returns:</p> <ul> <li> <code>AttributeSchema</code>           \u2013            <p>The validated AttributeSchema.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the default value does not match the expected data type.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema","title":"<code>VectorAttributeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a vector attribute.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.dimension","title":"<code>dimension = Field(ge=1, default=1536, description='The dimension of the vector attribute. Must be at least 1.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.index_type","title":"<code>index_type = Field(default='HNSW', description='The index type for the vector attribute. Currently only \"HNSW\" is supported.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.data_type","title":"<code>data_type = Field(default='FLOAT', description='The data type of the attribute. Currently only \"FLOAT\" is supported. Future types may include \"DOUBLE\", \"HALF\", or \"BYTE\".')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.metric","title":"<code>metric = Field(default='COSINE', description='The metric used for distance calculations. Can be \"COSINE\", \"IP\" (inner product), or \"L2\".')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType","title":"<code>DataType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported data types.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.INT","title":"<code>INT = 'INT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents an integer type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.UINT","title":"<code>UINT = 'UINT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents an unsigned integer type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.FLOAT","title":"<code>FLOAT = 'FLOAT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents a floating-point type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.DOUBLE","title":"<code>DOUBLE = 'DOUBLE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents a double-precision floating-point type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.BOOL","title":"<code>BOOL = 'BOOL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents a boolean type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.STRING","title":"<code>STRING = 'STRING'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents a string type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.DATETIME","title":"<code>DATETIME = 'DATETIME'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents a datetime type.</p>"},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/","title":"TigerGraphConnectionConfig","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig","title":"<code>TigerGraphConnectionConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for connecting to a TigerGraph instance.</p> <p>This class supports:</p> <ol> <li>User/password authentication</li> <li>Secret-based authentication</li> <li>Token-based authentication</li> </ol>"},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.model_config","title":"<code>model_config = SettingsConfigDict(populate_by_name=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.host","title":"<code>host = Field(default=HttpUrl('http://127.0.0.1'), validation_alias='TG_HOST', description='The host URL for the TigerGraph connection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.restpp_port","title":"<code>restpp_port = Field(default='14240', validation_alias='TG_RESTPP_PORT', description='The port for REST++ API.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.gsql_port","title":"<code>gsql_port = Field(default='14240', validation_alias='TG_GSQL_PORT', description='The port for GSQL.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.username","title":"<code>username = Field(default=None, validation_alias='TG_USERNAME', description='The username for TigerGraph authentication. Use only for user/password authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.password","title":"<code>password = Field(default=None, validation_alias='TG_PASSWORD', description='The password for TigerGraph authentication. Use only for user/password authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.secret","title":"<code>secret = Field(default=None, validation_alias='TG_SECRET', description='The secret for TigerGraph authentication. Use only for secret-based authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.token","title":"<code>token = Field(default=None, validation_alias='TG_TOKEN', description='The API token for TigerGraph authentication. Use only for token-based authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.check_exclusive_authentication","title":"<code>check_exclusive_authentication(values)</code>","text":"<p>Ensure that exactly one authentication method is provided:</p> <ul> <li>username/password together, or</li> <li>secret, or</li> <li>token. If all fields are empty, username/password will default.</li> </ul> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input values for validation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>The validated values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than one authentication method is provided.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.create","title":"<code>create(**kwargs)</code>  <code>classmethod</code>","text":"<p>Allows initialization using both field names and aliases.</p>"},{"location":"reference/04_config/02_query/neighbor_spec/","title":"NeighborSpec","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec","title":"<code>NeighborSpec</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Specification for selecting neighbors in a graph query.</p>"},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.start_nodes","title":"<code>start_nodes = Field(..., description='List of starting node IDs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.start_node_type","title":"<code>start_node_type = Field(..., description='The type of the start node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.start_node_alias","title":"<code>start_node_alias = Field('s', description='Alias for the source node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.edge_type_set","title":"<code>edge_type_set = Field(None, description='Set of allowed edge types for traversal.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.edge_alias","title":"<code>edge_alias = Field('e', description='Alias for the edge.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.target_node_type_set","title":"<code>target_node_type_set = Field(None, description='Set of allowed target node types.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.target_node_alias","title":"<code>target_node_alias = Field('t', description='Alias for the target node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.filter_expression","title":"<code>filter_expression = Field(None, description='A string defining complex filtering logic.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.return_attributes","title":"<code>return_attributes = Field(None, description='List of attributes to include in the results.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.limit","title":"<code>limit = Field(None, description='Maximum number of results to return.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/","title":"NodeSpec","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec","title":"<code>NodeSpec</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Specification for selecting nodes in a graph query.</p>"},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.node_type","title":"<code>node_type = Field(None, description='The type of nodes to select.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.all_node_types","title":"<code>all_node_types = Field(False, description='If True, nodes of all types will be returned, and the value of `node_type` will be ignored.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.node_alias","title":"<code>node_alias = Field('e', description='Alias for the node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.filter_expression","title":"<code>filter_expression = Field(None, description='A string defining filtering logic for the node selection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.return_attributes","title":"<code>return_attributes = Field(None, description='List of attributes to include in the output.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.limit","title":"<code>limit = Field(None, description='Maximum number of nodes to select.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/","title":"Chat Settings","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.BaseChatConfig","title":"<code>BaseChatConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for chat models.</p>"},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.BaseChatConfig.type","title":"<code>type = Field(description='Mandatory base type; derived classes can override or set a default.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig","title":"<code>OpenAIChatConfig</code>","text":"<p>               Bases: <code>BaseChatConfig</code></p> <p>Configuration class for OpenAI Chat models.</p>"},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.type","title":"<code>type = Field(default='OpenAI', description='Default type for OpenAIChatConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.model","title":"<code>model = Field(default='gpt-4o-mini', description='Default OpenAI model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.max_retries","title":"<code>max_retries = Field(default=10, description='Maximum number of retries for API calls.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/","title":"Embedding Settings","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.BaseEmbeddingConfig","title":"<code>BaseEmbeddingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for embedding models.</p>"},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.BaseEmbeddingConfig.type","title":"<code>type = Field(description='Mandatory base type; derived classes can override or set a default.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig","title":"<code>OpenAIEmbeddingConfig</code>","text":"<p>               Bases: <code>BaseEmbeddingConfig</code></p> <p>Configuration class for OpenAI Embedding models.</p>"},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.type","title":"<code>type = Field(default='OpenAI', description='Default type for OpenAIEmbeddingConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.model","title":"<code>model = Field(default='text-embedding-3-small', description='Default OpenAI embedding model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.max_tokens","title":"<code>max_tokens = Field(default=8191, description='Maximum number of tokens supported.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.max_retries","title":"<code>max_retries = Field(default=10, description='Maximum number of retries for API calls.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.encoding_name","title":"<code>encoding_name = Field(default='cl100k_base', description='Token encoding name used by the model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/","title":"LLM Settings","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.BaseLLMConfig","title":"<code>BaseLLMConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for LLM.</p>"},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.BaseLLMConfig.type","title":"<code>type = Field(description='Mandatory type field for identifying the LLM type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig","title":"<code>OpenAIConfig</code>","text":"<p>               Bases: <code>BaseLLMConfig</code></p> <p>Configuration class for OpenAI.</p>"},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.type","title":"<code>type = Field(default='OpenAI', description='Default type for OpenAIConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.api_key","title":"<code>api_key = Field(alias='OPENAI_API_KEY', description='API key for authentication with OpenAI.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.base_url","title":"<code>base_url = Field(default=None, description='Custom base URL for OpenAI API.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.organization","title":"<code>organization = Field(default=None, description='OpenAI organization ID (if applicable).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.max_retries","title":"<code>max_retries = Field(default=10, description='Maximum number of retries for failed API requests.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.request_timeout","title":"<code>request_timeout = Field(default=180.0, description='Request timeout in seconds.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/","title":"Settings","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Application settings, including configurations for vector databases, LLMs, embeddings, and chat models.</p>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.vector_db","title":"<code>vector_db = Field(description='Configuration for the vector database.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.llm","title":"<code>llm = Field(description='Configuration for the language model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.embedding","title":"<code>embedding = Field(description='Configuration for the embedding model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.chat","title":"<code>chat = Field(description='Configuration for the chat model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_vector_db","title":"<code>validate_vector_db(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the vector_db field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the vector database.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseVectorDBConfig</code> (              <code>BaseVectorDBConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of vector database is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_llm","title":"<code>validate_llm(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the llm field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the language model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseLLMConfig</code> (              <code>BaseLLMConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of language model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_embedding","title":"<code>validate_embedding(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the embedding field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the embedding model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseEmbeddingConfig</code> (              <code>BaseEmbeddingConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of embedding model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_chat","title":"<code>validate_chat(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the chat field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the chat model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseChatConfig</code> (              <code>BaseChatConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of chat model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/vector_db_settings/","title":"Vector DB Settings","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.BaseVectorDBConfig","title":"<code>BaseVectorDBConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for vector databases.</p>"},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.BaseVectorDBConfig.type","title":"<code>type = Field(description='Mandatory type field to identify the database type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig","title":"<code>NanoVectorDBConfig</code>","text":"<p>               Bases: <code>BaseVectorDBConfig</code></p> <p>Configuration class for NanoVectorDB.</p>"},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.type","title":"<code>type = Field(default='NanoVectorDB', description='Default type for NanoVectorDBConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.storage_file","title":"<code>storage_file = Field(default='nano-vectordb.json', description='Path to the storage file for NanoVectorDB.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.embedding_dim","title":"<code>embedding_dim = Field(default=1536, description='Default embedding dimension for NanoVectorDB.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/05_graphrag/base_context_builder/","title":"BaseContextBuilder","text":""},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder","title":"<code>BaseContextBuilder</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for building context using graph data and a search engine.</p> <p>Attributes:</p> <ul> <li> <code>graph</code>           \u2013            <p>The graph object.</p> </li> <li> <code>single_batch</code>           \u2013            <p>Whether to process data in a single batch.</p> </li> <li> <code>search_engine</code>           \u2013            <p>The search engine for retrieving top-k objects.</p> </li> <li> <code>token_encoder</code>           \u2013            <p>Token encoder for text tokenization.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.__init__","title":"<code>__init__(graph, single_batch=True, search_engine=None, token_encoder=None)</code>","text":"<p>Initialize the BaseContextBuilder.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>The graph object.</p> </li> <li> <code>single_batch</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to process data in a single batch.</p> </li> <li> <code>search_engine</code>               (<code>Optional[BaseSearchEngine]</code>, default:                   <code>None</code> )           \u2013            <p>The search engine for similarity searches.</p> </li> <li> <code>token_encoder</code>               (<code>Optional[Encoding]</code>, default:                   <code>None</code> )           \u2013            <p>Token encoder for text tokenization. Defaults to \"cl100k_base\".</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.build_context","title":"<code>build_context(*args, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to build context.</p> <p>Returns:</p> <ul> <li> <code>str | List[str]</code>           \u2013            <p>The generated context as a string or list of strings.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.batch_and_convert_to_text","title":"<code>batch_and_convert_to_text(graph_data, section_name, single_batch=False, max_tokens=12000)</code>","text":"<p>Convert graph data to a formatted string or list of strings in batches based on token count.</p> <p>Parameters:</p> <ul> <li> <code>graph_data</code>               (<code>DataFrame</code>)           \u2013            <p>The graph data to convert.</p> </li> <li> <code>section_name</code>               (<code>str</code>)           \u2013            <p>The section name for the header.</p> </li> <li> <code>single_batch</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to process data in a single batch. Defaults to False.</p> </li> <li> <code>max_tokens</code>               (<code>int</code>, default:                   <code>12000</code> )           \u2013            <p>Maximum number of tokens per batch. Defaults to 12000.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | List[str]</code>           \u2013            <p>The formatted graph data as a string or list of strings.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.retrieve_top_k_objects","title":"<code>retrieve_top_k_objects(query, k=10, oversample_scaler=2, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the top-k objects most similar to the query.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>str</code>)           \u2013            <p>The query string.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of top results to retrieve. Defaults to 10.</p> </li> <li> <code>**kwargs</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters for the search engine.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>A list of the top-k results.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>k</code> is less than or equal to 0 or if the search engine is not initialized.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/","title":"ParquetProcessor","text":""},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor","title":"<code>ParquetProcessor</code>","text":"<p>A class to process Parquet files and generate CSV files with custom transformations.</p>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.__init__","title":"<code>__init__(input_dir, output_dir)</code>","text":"<p>Initialize the ParquetProcessor with input and output directories.</p> <p>Parameters:</p> <ul> <li> <code>input_dir</code>               (<code>str | Path</code>)           \u2013            <p>Directory containing the input Parquet files.</p> </li> <li> <code>output_dir</code>               (<code>str | Path</code>)           \u2013            <p>Directory to save the output CSV files.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.save_dataframe_to_csv","title":"<code>save_dataframe_to_csv(df, csv_file_name)</code>","text":"<p>Save a DataFrame or Series to a CSV file with specific formatting.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame | Series</code>)           \u2013            <p>The DataFrame or Series to save.</p> </li> <li> <code>csv_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.convert_parquet_to_csv","title":"<code>convert_parquet_to_csv(parquet_file_name, columns, csv_file_name)</code>","text":"<p>Convert a Parquet file to a CSV file with specific columns.</p> <p>Parameters:</p> <ul> <li> <code>parquet_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the input Parquet file.</p> </li> <li> <code>columns</code>               (<code>List[str]</code>)           \u2013            <p>List of columns to include in the output CSV.</p> </li> <li> <code>csv_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.create_relationship_file","title":"<code>create_relationship_file(df, element_list_name, element_name, collection_name, collection_new_name, output_name)</code>","text":"<p>Generate a CSV file for relationship mapping based on input DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>Input DataFrame containing relationship data.</p> </li> <li> <code>element_list_name</code>               (<code>str</code>)           \u2013            <p>Name of the column containing element lists.</p> </li> <li> <code>element_name</code>               (<code>str</code>)           \u2013            <p>Name of the element to map.</p> </li> <li> <code>collection_name</code>               (<code>str</code>)           \u2013            <p>Name of the collection column.</p> </li> <li> <code>collection_new_name</code>               (<code>str</code>)           \u2013            <p>New name for the collection in the output.</p> </li> <li> <code>output_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.process_parquet_files","title":"<code>process_parquet_files(configs)</code>","text":"<p>Process a list of Parquet file configurations and convert them to CSV.</p> <p>Parameters:</p> <ul> <li> <code>configs</code>               (<code>List[Dict[str, Any]]</code>)           \u2013            <p>List of configuration dictionaries for processing Parquet files.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.process_relationship_files","title":"<code>process_relationship_files(configs)</code>","text":"<p>Process a list of relationship file configurations and generate CSV files.</p> <p>Parameters:</p> <ul> <li> <code>configs</code>               (<code>List[Dict[str, Any]]</code>)           \u2013            <p>List of configuration dictionaries for generating relationship files.</p> </li> </ul>"},{"location":"reference/07_utils/retry_mixin/","title":"RetryMixin","text":""},{"location":"reference/07_utils/retry_mixin/#tigergraphx.utils.RetryMixin","title":"<code>RetryMixin</code>","text":"<p>Mixin for initializing a retry mechanism with configurable parameters.</p>"},{"location":"reference/07_utils/retry_mixin/#tigergraphx.utils.RetryMixin.initialize_retryer","title":"<code>initialize_retryer(max_retries, max_wait)</code>","text":"<p>Initialize the retry mechanism with exponential backoff and jitter.</p> <p>Parameters:</p> <ul> <li> <code>max_retries</code>               (<code>int</code>)           \u2013            <p>Maximum number of retry attempts.</p> </li> <li> <code>max_wait</code>               (<code>int</code>)           \u2013            <p>Maximum wait time between retries in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncRetrying</code> (              <code>AsyncRetrying</code> )          \u2013            <p>Configured retrying instance with specified parameters.</p> </li> </ul>"}]}