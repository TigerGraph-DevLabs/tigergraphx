{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to TigerGraphX","text":"<p>TigerGraphX is a high-level Python library offering a unified, Python-native interface for graph databases, advanced analytics, and GraphRAG workflows. Combining the simplicity of NetworkX with the advanced capabilities of TigerGraph, including tgCloud, it empowers Python developers to harness the power of graphs without the need to learn query languages like Cypher or GSQL.</p> <p>TigerGraphX is designed for two main audiences, catering to different use cases while maintaining an easy-to-use, developer-friendly experience:</p>"},{"location":"#who-should-use-tigergraphx","title":"Who Should Use TigerGraphX?","text":""},{"location":"#1-python-developers-for-graph-analytics-with-tigergraph","title":"1. Python Developers for Graph Analytics with TigerGraph","text":"<p>If you\u2019re a Python developer interested in performing graph analytics with TigerGraph, TigerGraphX provides:</p> <ul> <li>Python-Native APIs: No need to learn complex query languages like GSQL or Cypher.</li> <li>Seamless Integration: Easily perform CRUD operations, multi-hop queries, and advanced analytics directly from Python.</li> <li>Scalability: Leverage the powerful performance of TigerGraph for large-scale graph processing.</li> </ul> <p>Start here:</p> <ul> <li>Introduction to TigerGraphX: Discover the features and benefits of using TigerGraphX for graph database management and analytics.</li> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>Quick Start Guide: Quickly set up TigerGraphX and build your first graph with this step-by-step guide.</li> </ul>"},{"location":"#2-python-developers-for-graphrag-workflows","title":"2. Python Developers for GraphRAG Workflows","text":"<p>If you\u2019re a Python developer building GraphRAG applications, TigerGraphX enables you to:</p> <ul> <li>Use TigerGraph as a scalable database for storing and retrieving graph and vector data generated by GraphRAG algorithms.</li> <li>Build token-aware LLM workflows for advanced AI applications.</li> <li>Utilize context builders to streamline data preparation for large language models.</li> </ul> <p>Start here:</p> <ul> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>GraphRAG Overview: Explore how TigerGraphX integrates with GraphRAG workflows.</li> <li>Supporting Microsoft\u2019s GraphRAG: An example of using TigerGraphX for GraphRAG workflows.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"introduction/","title":"TigerGraphX: Unified Graph Solutions for Python Developers","text":""},{"location":"introduction/#what-is-tigergraphx","title":"What is TigerGraphX?","text":"<p>TigerGraphX is a high-level Python library offering a unified, Python-native interface for graph databases, advanced analytics, and GraphRAG workflows. Combining the simplicity of NetworkX with the advanced capabilities of TigerGraph, including tgCloud, it empowers Python developers to harness the power of graphs without the need to learn query languages like Cypher or GSQL.</p>"},{"location":"introduction/#core-mission","title":"Core Mission","text":"<p>TigerGraphX seeks to democratize graph technology by providing an intuitive, all-encompassing framework that integrates and provides direct connection to:</p> <ul> <li>TigerGraph Database capabilities</li> <li>TigerGraph Vector Database functionality</li> <li>Large Language Model (LLM) integration</li> <li>TigerGraph\u2019s GraphRAG support for intelligent workflow</li> </ul>"},{"location":"introduction/#key-features","title":"Key Features","text":""},{"location":"introduction/#1-schema-management","title":"1. Schema Management","text":"<ul> <li>Easily create and modify schemas using YAML, JSON, or Python dictionaries.</li> <li>No GSQL knowledge is required.</li> <li>Pythonic tools for designing database structures effortlessly.</li> </ul>"},{"location":"introduction/#2-data-loading","title":"2. Data Loading","text":"<ul> <li>Automated loading jobs for streamlined data imports.</li> <li>High-efficiency workflows with support for Parquet files.</li> <li>Simplified data ingestion processes for faster setup.</li> </ul>"},{"location":"introduction/#3-graph-library-interface","title":"3. Graph Library Interface","text":"<ul> <li>Python-native APIs for CRUD operations.</li> <li>Comprehensive tools for graph reporting and visualization.</li> <li>Built-in graph algorithms including centrality, community detection, and path analysis algorithms</li> </ul>"},{"location":"introduction/#4-graph-query-interface","title":"4. Graph Query Interface","text":"<ul> <li>Simplified advanced querying with intuitive APIs.</li> <li>Seamless integration into analytics workflows via DataFrame outputs.</li> <li>Support for advanced multi-hop query traversal and manipulation</li> </ul>"},{"location":"introduction/#5-vector-search-capabilities","title":"5. Vector Search Capabilities","text":"<ul> <li>AI-driven applications with integrated vector embeddings.</li> <li>Efficient top-K entity retrieval for enhanced intelligence.</li> <li>Ideal for recommendation systems and contextual analysis.</li> </ul>"},{"location":"introduction/#6-llm-integration-and-graphrag-support","title":"6. LLM Integration and GraphRAG support","text":"<ul> <li>Full support for GraphRAG workflows.</li> <li>Flexible, token-aware context builders for advanced applications.</li> <li>Tools for token optimization and seamless LLM integration.</li> </ul>"},{"location":"introduction/#7-machine-learning-ready-planned-feature","title":"7. Machine Learning Ready [Planned Feature]","text":"<ul> <li>Seamless integration with popular ML libraries</li> <li>Graph feature extraction</li> <li>Native support for graph neural networks (GNNs)</li> </ul>"},{"location":"introduction/#why-choose-tigergraphx","title":"Why Choose TigerGraphX?","text":"<p>TigerGraphX redefines graph technology by making advanced and powerful graph operations accessible and intuitive for Python developers. With its unified, user-friendly interface, TigerGraphX bridges the gap between simplicity and scalability, enabling developers to:</p> <ul> <li>Leverage TigerGraph\u2019s unmatched scalability for high-performance graph processing.  </li> <li>Enjoy the familiarity of tools like NetworkX while unlocking enterprise-grade graph capabilities.  </li> <li>Access advanced graph analytics with ease, reducing the learning curve and technical barriers.  </li> <li>Develop intelligent, context-aware GraphRAG applications effortlessly with token-aware workflows and streamlined context builders.</li> </ul> <p>TigerGraphX empowers developers to explore, analyze, and build with graphs like never before\u2014efficiently and effectively.</p>"},{"location":"introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>GraphRAG Overview: Explore how TigerGraphX integrates with GraphRAG workflows.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/installation/","title":"Installation Guide","text":"<p>Follow this guide to install and set up TigerGraphX in your environment.</p>"},{"location":"getting_started/installation/#requirements","title":"Requirements","text":"<p>This project requires Python 3.12 and TigerGraph. Ensure you meet the following prerequisites before proceeding:</p>"},{"location":"getting_started/installation/#1-python-312","title":"1. Python 3.12","text":"<ul> <li>Please ensure Python 3.12 is installed on your system.</li> <li>You can download and install it from the official Python website.</li> </ul>"},{"location":"getting_started/installation/#2-tigergraph","title":"2. TigerGraph","text":"<p>TigerGraph is required for this project and can be set up in one of the following ways:</p> <ul> <li>TigerGraph DB: Install and configure a local instance of TigerGraph.</li> <li>TigerGraph Cloud: Use a cloud-hosted instance of TigerGraph.</li> </ul> <p>It is recommended to use TigerGraph LTS (Long-Term Support) Versions, which can be downloaded from the TigerGraph Downloads page. To enable support for TigerVector and leverage advanced features like hybrid retrieval, ensure you are using TigerGraph 4.2 or above.</p> <p>Refer to the official TigerGraph Documentation for detailed installation and configuration instructions.</p>"},{"location":"getting_started/installation/#installation-steps","title":"Installation Steps","text":""},{"location":"getting_started/installation/#option-1-install-from-pypi","title":"Option 1: Install from PyPI","text":"<p>The simplest way to get started with TigerGraphX is by installing it directly from PyPI. Using a virtual environment is recommended to ensure a clean and isolated setup.</p> <p>To install TigerGraphX, run: <pre><code>pip install tigergraphx\n</code></pre></p> <p>This allows you to quickly start using the library without needing the source code.</p>"},{"location":"getting_started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installing, verify that TigerGraphX is installed correctly by running: <pre><code>python -c \"import tigergraphx; print('TigerGraphX installed successfully!')\"\n</code></pre></p> <p>If the installation was successful, you will see: <pre><code>TigerGraphX installed successfully!\n</code></pre></p> <p>This ensures that the library is properly installed and ready for use.</p>"},{"location":"getting_started/installation/#option-2-build-from-source-code","title":"Option 2: Build from Source Code","text":"<p>If you want to modify or explore the source code, you can install TigerGraphX from its GitHub repository. The source code is available here: TigerGraphX on GitHub.</p> <p>This project uses Poetry to manage dependencies. If you don\u2019t have Poetry installed, follow the instructions on the Poetry website.</p> <p>Once Poetry is installed, clone the repository, navigate to the project\u2019s root directory, and use one of the following commands to install dependencies based on your needs:</p>"},{"location":"getting_started/installation/#core-installation","title":"Core Installation","text":"<p>If you need only the core functionality of TigerGraphX (without running application examples like GraphRAG, unit tests, or integration tests), run: <pre><code>poetry install --without dev\n</code></pre></p> <p>This command will:</p> <ul> <li>Install only the dependencies required for the core features of TigerGraphX.</li> </ul>"},{"location":"getting_started/installation/#development-installation","title":"Development Installation","text":"<p>If you\u2019re contributing to the project or want to use advanced features like running the GraphRAG examples or test cases, run: <pre><code>poetry install --with dev\n</code></pre></p> <p>This command will:</p> <ul> <li>Install all core dependencies.</li> <li>Include development dependencies defined under <code>[tool.poetry.group.dev.dependencies]</code> in <code>pyproject.toml</code>.</li> </ul>"},{"location":"getting_started/installation/#verify-your-installation","title":"Verify Your Installation","text":"<p>After installing dependencies, verify your setup by listing the installed packages: <pre><code>poetry show --with dev\n</code></pre></p> <p>This ensures all required dependencies (including optional ones) are successfully installed.</p>"},{"location":"getting_started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start: Learn how to build your first graph with TigerGraphX.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/quick_start/","title":"Quick Start Guide","text":"In\u00a0[3]: Copied! <pre>from tigergraphx import Graph, GraphSchema, TigerGraphConnectionConfig\ngraph_schema = GraphSchema.ensure_config({\n    \"graph_name\": \"Social\",\n    \"nodes\": {\n        \"Person\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n                \"age\": \"UINT\",\n            },\n        },\n    },\n    \"edges\": {\n        \"Friendship\": {\n            \"is_directed_edge\": False,\n            \"from_node_type\": \"Person\",\n            \"to_node_type\": \"Person\",\n            \"attributes\": {\n                \"closeness\": \"DOUBLE\",\n            },\n        },\n    },\n})\n</pre> from tigergraphx import Graph, GraphSchema, TigerGraphConnectionConfig graph_schema = GraphSchema.ensure_config({     \"graph_name\": \"Social\",     \"nodes\": {         \"Person\": {             \"primary_key\": \"name\",             \"attributes\": {                 \"name\": \"STRING\",                 \"age\": \"UINT\",             },         },     },     \"edges\": {         \"Friendship\": {             \"is_directed_edge\": False,             \"from_node_type\": \"Person\",             \"to_node_type\": \"Person\",             \"attributes\": {                 \"closeness\": \"DOUBLE\",             },         },     }, }) In\u00a0[4]: Copied! <pre>connection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"user_name\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\n</pre> connection = TigerGraphConnectionConfig.ensure_config({     \"host\": \"http://127.0.0.1\",     \"user_name\": \"tigergraph\",     \"password\": \"tigergraph\", }) In\u00a0[5]: Copied! <pre>G = Graph(graph_schema, connection)\n</pre> G = Graph(graph_schema, connection) In\u00a0[6]: Copied! <pre>G.add_node(\"Alice\", \"Person\", age=25)\nG.add_node(\"Michael\", \"Person\", age=28)\nG.add_edge(\"Alice\", \"Michael\", closeness=0.98)\n</pre> G.add_node(\"Alice\", \"Person\", age=25) G.add_node(\"Michael\", \"Person\", age=28) G.add_edge(\"Alice\", \"Michael\", closeness=0.98) In\u00a0[7]: Copied! <pre>print(G.has_node(\"Alice\"))\n</pre> print(G.has_node(\"Alice\")) <pre>True\n</pre> In\u00a0[8]: Copied! <pre>print(G.has_node(\"Michael\"))\n</pre> print(G.has_node(\"Michael\")) <pre>True\n</pre> <p>Since the 'Friendship' edge is undirected, both 'Alice -&gt; Michael' and 'Michael -&gt; Alice' are valid and accessible.</p> In\u00a0[9]: Copied! <pre>print(G.has_edge(\"Alice\", \"Michael\"))\n</pre> print(G.has_edge(\"Alice\", \"Michael\")) <pre>True\n</pre> In\u00a0[10]: Copied! <pre>print(G.has_edge(\"Michael\", \"Alice\"))\n</pre> print(G.has_edge(\"Michael\", \"Alice\")) <pre>True\n</pre> In\u00a0[11]: Copied! <pre>print(G.get_node_data(\"Alice\"))\n</pre> print(G.get_node_data(\"Alice\")) <pre>{'name': 'Alice', 'age': 25}\n</pre> In\u00a0[12]: Copied! <pre>print(G.get_edge_data(\"Alice\", \"Michael\"))\n</pre> print(G.get_edge_data(\"Alice\", \"Michael\")) <pre>{'closeness': 0.98}\n</pre> In\u00a0[13]: Copied! <pre>print(G.nodes[\"Alice\"])\n</pre> print(G.nodes[\"Alice\"]) <pre>{'name': 'Alice', 'age': 25}\n</pre> In\u00a0[14]: Copied! <pre>print(G.nodes[\"Michael\"][\"age\"])\n</pre> print(G.nodes[\"Michael\"][\"age\"]) <pre>28\n</pre> <p>Note: The Edge View feature is planned for future releases.</p> In\u00a0[15]: Copied! <pre>print(G.degree(\"Alice\"))\n</pre> print(G.degree(\"Alice\")) <pre>1\n</pre> In\u00a0[16]: Copied! <pre>neighbors = G.get_neighbors(\"Alice\")\nprint(neighbors)\n</pre> neighbors = G.get_neighbors(\"Alice\") print(neighbors) <pre>      name  age\n0  Michael   28\n</pre> In\u00a0[17]: Copied! <pre>print(type(neighbors))\n</pre> print(type(neighbors)) <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\n</pre> In\u00a0[18]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>2\n</pre> In\u00a0[19]: Copied! <pre>print(G.number_of_edges())\n</pre> print(G.number_of_edges()) <pre>1\n</pre>"},{"location":"getting_started/quick_start/#quick-start-guide","title":"Quick Start Guide\u00b6","text":"<p>Follow this guide to quickly set up TigerGraphX and build your first graph. This guide assumes that you have already installed TigerGraphX and its dependencies as described in the Installation Guide.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from quick_start.ipynb.</p>"},{"location":"getting_started/quick_start/#create-a-graph","title":"Create a Graph\u00b6","text":""},{"location":"getting_started/quick_start/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we will create a graph named \"Social\" that includes one node type, \"Person,\" and one directed edge type, \"Friendship.\" Note that you must define the primary key for each node type, indicate whether an edge type is directed or undirected, and specify the source and target node types for each edge type.</p>"},{"location":"getting_started/quick_start/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p>"},{"location":"getting_started/quick_start/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"getting_started/quick_start/#nodes-and-edges","title":"Nodes and Edges\u00b6","text":""},{"location":"getting_started/quick_start/#add-nodes-and-edges","title":"Add Nodes and Edges\u00b6","text":"<p>Note: This example demonstrates how to easily add nodes and edges using the API. However, adding nodes and edges individually may not be efficient for large-scale operations. For better performance when loading data into TigerGraph, it is recommended to use a loading job. Nonetheless, these examples are ideal for quickly getting started.</p>"},{"location":"getting_started/quick_start/#check-if-nodes-and-edges-exist","title":"Check if Nodes and Edges Exist\u00b6","text":""},{"location":"getting_started/quick_start/#display-node-and-edge-attributes","title":"Display Node and Edge Attributes\u00b6","text":""},{"location":"getting_started/quick_start/#using-get_node_data-and-get_edge_data-functions","title":"Using <code>get_node_data</code> and <code>get_edge_data</code> Functions\u00b6","text":""},{"location":"getting_started/quick_start/#using-node-view","title":"Using Node View\u00b6","text":""},{"location":"getting_started/quick_start/#display-the-degree-of-nodes","title":"Display the Degree of Nodes\u00b6","text":""},{"location":"getting_started/quick_start/#retrieve-the-neighbors-of-a-node","title":"Retrieve the Neighbors of a Node\u00b6","text":""},{"location":"getting_started/quick_start/#graph-statistics","title":"Graph Statistics\u00b6","text":""},{"location":"getting_started/quick_start/#display-the-number-of-nodes","title":"Display the Number of Nodes\u00b6","text":""},{"location":"getting_started/quick_start/#display-the-number-of-edges","title":"Display the Number of Edges\u00b6","text":""},{"location":"getting_started/quick_start/#whats-next","title":"What\u2019s Next?\u00b6","text":"<p>Now that you\u2019ve set up your graph and performed basic operations, you can explore more advanced features of TigerGraphX:</p> <ul> <li>GraphRAG Overview: Learn about integrating graphs with LLMs.</li> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"graphrag/graphrag_overview/","title":"TigerGraph: Unlocking the Potential of GraphRAG","text":""},{"location":"graphrag/graphrag_overview/#overview","title":"Overview","text":"<p>TigerGraph is a highly scalable and efficient graph database, making it the ideal foundation for advanced GraphRAG workflows. It excels in handling both graph and vector data, enabling seamless integration and performance at scale. With built-in support for complex queries, multi-hop traversals, and real-time analytics, TigerGraph ensures fast and reliable results. Its versatility and performance make it the ideal choice for powering data-intensive workflows, while TigerGraphX simplifies access with a Python-native interface.</p> <p></p>"},{"location":"graphrag/graphrag_overview/#why-tigergraph-for-graphrag","title":"Why TigerGraph for GraphRAG?","text":""},{"location":"graphrag/graphrag_overview/#1-scalability-and-performance","title":"1. Scalability and Performance","text":"<p>TigerGraph excels in handling massive datasets with high-speed multi-hop queries and vector search capabilities. It is ideal for real-world GraphRAG applications that demand extensive and efficient data processing.</p>"},{"location":"graphrag/graphrag_overview/#2-unified-graph-and-vector-data-support","title":"2. Unified Graph and Vector Data Support","text":"<p>With native support for schema-defined nodes, edges, and vectors, TigerGraph streamlines data integration. Its advanced query optimization enables efficient graph traversal and vector-based retrieval, which is perfectly suited for LLM workflows.</p>"},{"location":"graphrag/graphrag_overview/#3-cost-effectiveness","title":"3. Cost-Effectiveness","text":"<p>TigerGraph reduces computational overhead through optimized queries and highly efficient storage, significantly cutting infrastructure costs while maintaining top-tier performance.</p>"},{"location":"graphrag/graphrag_overview/#4-flexibility-and-hybrid-integration","title":"4. Flexibility and Hybrid Integration","text":"<p>Seamlessly combines structured, semantic, and vector-based retrieval methods in one unified platform. Its compatibility with vector search and LLMs enables advanced hybrid retrieval strategies, unlocking new possibilities for GraphRAG workflows.</p>"},{"location":"graphrag/graphrag_overview/#graphrag-workflow-with-tigergraph","title":"GraphRAG Workflow with TigerGraph","text":""},{"location":"graphrag/graphrag_overview/#1-schema-design","title":"1. Schema Design","text":"<p>Define the graph schema with nodes, edges, and attributes tailored to your application, leveraging TigerGraph\u2019s native support for structured graph data.</p>"},{"location":"graphrag/graphrag_overview/#2-data-preparation-and-loading","title":"2. Data Preparation and Loading","text":"<p>Transform raw data into TigerGraph-compatible formats, including graph structures and embeddings, and load it efficiently into TigerGraph using TigerGraphX.</p>"},{"location":"graphrag/graphrag_overview/#3-knowledge-graph-management-and-analysis","title":"3. Knowledge Graph Management and Analysis","text":"<p>Maintain and enhance the knowledge graph to ensure data quality, relevance, and scalability. Perform in-depth analysis to uncover patterns, infer insights, and optimize data retrieval strategies; ensure the knowledge graph remains a dynamic, accurate, and actionable source of information, enriching context for LLMs while supporting explainability and scalability in the GraphRAG workflow.</p>"},{"location":"graphrag/graphrag_overview/#4-hybrid-retrieval","title":"4. Hybrid Retrieval","text":"<p>Combine structured queries, semantic search, and vector-based methods to fetch relevant data and embeddings from TigerGraph for context construction.</p>"},{"location":"graphrag/graphrag_overview/#5-context-building","title":"5. Context Building","text":"<p>Use TigerGraphX to process retrieved data, making it token-aware and formatted to meet the requirements of LLMs.</p>"},{"location":"graphrag/graphrag_overview/#6-llm-integration","title":"6. LLM Integration","text":"<p>Pass the context to an LLM to generate responses, enabling advanced GraphRAG workflows with seamless data flow and high efficiency.</p>"},{"location":"graphrag/graphrag_overview/#two-options-for-implementing-graphrag-with-tigergraph","title":"Two Options for Implementing GraphRAG with TigerGraph","text":"<p>There are two approaches to implementing GraphRAG with TigerGraph.</p>"},{"location":"graphrag/graphrag_overview/#1-tigergraph-as-a-storage-and-retrieval-engine","title":"1. TigerGraph as a Storage and Retrieval Engine","text":"<p>The first approach primarily utilizes TigerGraph for storing and retrieving graph/vector data. TigerGraphX provides interfaces similar to NetworkX, allowing seamless integration with GraphRAG applications. This approach is recommended for GraphRAG solutions like LightRAG and Nano-GraphRAG, which abstract their storage layers (e.g., graph storage, key-value storage, and vector storage). Here, you only need to implement these layers in a way that aligns with TigerGraph.</p>"},{"location":"graphrag/graphrag_overview/#2-tigergraph-for-storage-retrieval-and-llm-tasks","title":"2. TigerGraph for Storage, Retrieval, and LLM Tasks","text":"<p>The second approach extends beyond storage and retrieval by leveraging TigerGraphX for tasks related to large language models (LLMs), such as chat or embedding generation. This approach is suitable for complex projects like Microsoft's GraphRAG. As of December 2024, Microsoft's GraphRAG has not yet abstracted its storage layer, making it challenging to replace the indexing process. However, TigerGraphX can be used to convert the results of the indexing process (e.g., Parquet files) into a format supported by TigerGraph. These results can then be imported into TigerGraph, and TigerGraphX can handle the querying process without relying on Microsoft\u2019s GraphRAG.</p>"},{"location":"graphrag/graphrag_overview/#demonstrations","title":"Demonstrations","text":"<p>Both methods are demonstrated on the following pages, each with a real-world project:</p> <ul> <li>LightRAG: Refer to LightRAG for the first approach.</li> <li>Microsoft's GraphRAG: Refer to Microsoft GraphRAG: Part 1 for the second approach.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/lightrag/","title":"Supporting LightRAG","text":"<p>LightRAG is an open-source RAG system that enhances LLMs by integrating graph-based structures into text indexing and retrieval. It overcomes the limitations of traditional RAG systems, such as fragmented answers and weak contextual awareness, by enabling dual-level retrieval for more comprehensive knowledge discovery. With support for incremental data updates, LightRAG ensures timely integration of new information while delivering improved retrieval accuracy and efficiency.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from lightrag.ipynb.</p> In\u00a0[2]: Copied! <pre>import os\nfrom dataclasses import dataclass\nimport numpy as np\n\nfrom lightrag.base import BaseGraphStorage\nfrom lightrag.utils import logger\nfrom tigergraphx import UndiGraph, TigerGraphConnectionConfig\n\n\n@dataclass\nclass TigerGraphStorage(BaseGraphStorage):\n    def __post_init__(self):\n        try:\n            # Retrieve connection configuration from environment variables\n            connection_config = {\n                \"host\": os.environ[\"TG_HOST\"],\n                \"username\": os.environ[\"TG_USERNAME\"],\n                \"password\": os.environ[\"TG_PASSWORD\"],\n            }\n            logger.info(\"TigerGraph connection configuration retrieved successfully.\")\n            # Initialize the graph\n            self._graph = UndiGraph(\n                graph_name=\"LightRAG\",\n                node_type=\"MyNode\",\n                edge_type=\"MyEdge\",\n                node_primary_key=\"id\",\n                node_attributes={\n                    \"id\": \"STRING\",\n                    \"entity_type\": \"STRING\",\n                    \"description\": \"STRING\",\n                    \"source_id\": \"STRING\",\n                },\n                edge_attributes={\n                    \"weight\": \"DOUBLE\",\n                    \"description\": \"STRING\",\n                    \"keywords\": \"STRING\",\n                    \"source_id\": \"STRING\",\n                },\n                tigergraph_connection_config=TigerGraphConnectionConfig.ensure_config(\n                    connection_config\n                ),\n            )\n            logger.info(\n                \"Undirected graph initialized successfully with graph_name 'LightRAG'.\"\n            )\n        except KeyError as e:\n            logger.error(f\"Environment variable {str(e)} is missing.\")\n            raise\n        except Exception as e:\n            logger.error(f\"An error occurred during initialization: {e}\")\n            raise\n\n    @staticmethod\n    def clean_quotes(value: str) -&gt; str:\n        \"\"\"Remove leading and trailing &amp;quot; from a string if present.\"\"\"\n        if value.startswith('\"') and value.endswith('\"'):\n            return value[1:-1]\n        return value\n\n    async def has_node(self, node_id: str) -&gt; bool:\n        return self._graph.has_node(self.clean_quotes(node_id))\n\n    async def has_edge(self, source_node_id: str, target_node_id: str) -&gt; bool:\n        return self._graph.has_edge(\n            self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)\n        )\n\n    async def node_degree(self, node_id: str) -&gt; int:\n        result = self._graph.degree(self.clean_quotes(node_id))\n        return result\n\n    async def edge_degree(self, src_id: str, tgt_id: str) -&gt; int:\n        return self._graph.degree(self.clean_quotes(src_id)) + self._graph.degree(\n            self.clean_quotes(tgt_id)\n        )\n\n    async def get_node(self, node_id: str) -&gt; dict | None:\n        result = self._graph.get_node_data(self.clean_quotes(node_id))\n        return result\n\n    async def get_edge(self, source_node_id: str, target_node_id: str) -&gt; dict | None:\n        result = self._graph.get_edge_data(\n            self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)\n        )\n        return result\n\n    async def get_node_edges(self, source_node_id: str) -&gt; list[tuple[str, str]] | None:\n        source_node_id = self.clean_quotes(source_node_id)\n        if self._graph.has_node(source_node_id):\n            edges = self._graph.get_node_edges(source_node_id)\n            return list(edges)\n        return None\n\n    async def upsert_node(self, node_id: str, node_data: dict[str, str]):\n        node_id = self.clean_quotes(node_id)\n        self._graph.add_node(node_id, **node_data)\n\n    async def upsert_edge(\n        self, source_node_id: str, target_node_id: str, edge_data: dict[str, str]\n    ):\n        source_node_id = self.clean_quotes(source_node_id)\n        target_node_id = self.clean_quotes(target_node_id)\n        self._graph.add_edge(source_node_id, target_node_id, **edge_data)\n\n    async def delete_node(self, node_id: str):\n        if self._graph.has_node(node_id):\n            self._graph.remove_node(node_id)\n            logger.info(f\"Node {node_id} deleted from the graph.\")\n        else:\n            logger.warning(f\"Node {node_id} not found in the graph for deletion.\")\n\n    async def embed_nodes(self, algorithm: str) -&gt; tuple[np.ndarray, list[str]]:\n        return np.array([]), []\n</pre> import os from dataclasses import dataclass import numpy as np  from lightrag.base import BaseGraphStorage from lightrag.utils import logger from tigergraphx import UndiGraph, TigerGraphConnectionConfig   @dataclass class TigerGraphStorage(BaseGraphStorage):     def __post_init__(self):         try:             # Retrieve connection configuration from environment variables             connection_config = {                 \"host\": os.environ[\"TG_HOST\"],                 \"username\": os.environ[\"TG_USERNAME\"],                 \"password\": os.environ[\"TG_PASSWORD\"],             }             logger.info(\"TigerGraph connection configuration retrieved successfully.\")             # Initialize the graph             self._graph = UndiGraph(                 graph_name=\"LightRAG\",                 node_type=\"MyNode\",                 edge_type=\"MyEdge\",                 node_primary_key=\"id\",                 node_attributes={                     \"id\": \"STRING\",                     \"entity_type\": \"STRING\",                     \"description\": \"STRING\",                     \"source_id\": \"STRING\",                 },                 edge_attributes={                     \"weight\": \"DOUBLE\",                     \"description\": \"STRING\",                     \"keywords\": \"STRING\",                     \"source_id\": \"STRING\",                 },                 tigergraph_connection_config=TigerGraphConnectionConfig.ensure_config(                     connection_config                 ),             )             logger.info(                 \"Undirected graph initialized successfully with graph_name 'LightRAG'.\"             )         except KeyError as e:             logger.error(f\"Environment variable {str(e)} is missing.\")             raise         except Exception as e:             logger.error(f\"An error occurred during initialization: {e}\")             raise      @staticmethod     def clean_quotes(value: str) -&gt; str:         \"\"\"Remove leading and trailing \" from a string if present.\"\"\"         if value.startswith('\"') and value.endswith('\"'):             return value[1:-1]         return value      async def has_node(self, node_id: str) -&gt; bool:         return self._graph.has_node(self.clean_quotes(node_id))      async def has_edge(self, source_node_id: str, target_node_id: str) -&gt; bool:         return self._graph.has_edge(             self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)         )      async def node_degree(self, node_id: str) -&gt; int:         result = self._graph.degree(self.clean_quotes(node_id))         return result      async def edge_degree(self, src_id: str, tgt_id: str) -&gt; int:         return self._graph.degree(self.clean_quotes(src_id)) + self._graph.degree(             self.clean_quotes(tgt_id)         )      async def get_node(self, node_id: str) -&gt; dict | None:         result = self._graph.get_node_data(self.clean_quotes(node_id))         return result      async def get_edge(self, source_node_id: str, target_node_id: str) -&gt; dict | None:         result = self._graph.get_edge_data(             self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)         )         return result      async def get_node_edges(self, source_node_id: str) -&gt; list[tuple[str, str]] | None:         source_node_id = self.clean_quotes(source_node_id)         if self._graph.has_node(source_node_id):             edges = self._graph.get_node_edges(source_node_id)             return list(edges)         return None      async def upsert_node(self, node_id: str, node_data: dict[str, str]):         node_id = self.clean_quotes(node_id)         self._graph.add_node(node_id, **node_data)      async def upsert_edge(         self, source_node_id: str, target_node_id: str, edge_data: dict[str, str]     ):         source_node_id = self.clean_quotes(source_node_id)         target_node_id = self.clean_quotes(target_node_id)         self._graph.add_edge(source_node_id, target_node_id, **edge_data)      async def delete_node(self, node_id: str):         if self._graph.has_node(node_id):             self._graph.remove_node(node_id)             logger.info(f\"Node {node_id} deleted from the graph.\")         else:             logger.warning(f\"Node {node_id} not found in the graph for deletion.\")      async def embed_nodes(self, algorithm: str) -&gt; tuple[np.ndarray, list[str]]:         return np.array([]), [] <p>This code defines a <code>TigerGraphStorage</code> class that implements the <code>BaseGraphStorage</code> interface for graph storage and retrieval using TigerGraphX, a Python library for interacting with TigerGraph databases.</p> <p>Key highlights of this implementation include:</p> <ol> <li><p>Graph Initialization</p> <ul> <li>An undirected homogeneous graph (<code>UndiGraph</code>) is initialized. This graph type supports only one type of node and edge, making it similar to NetworkX's undirected graph.</li> <li>TigerGraph\u2019s schema-based nature requires a graph schema definition with specific attributes for nodes and edges. For instance:<ul> <li>Node attributes: <code>id</code>, <code>entity_type</code>, <code>description</code>, <code>source_id</code></li> <li>Edge attributes: <code>weight</code>, <code>description</code>, <code>keywords</code>, <code>source_id</code></li> </ul> </li> </ul> </li> <li><p>TigerGraphX Interfaces</p> <ul> <li>TigerGraphX provides user-friendly interfaces, very similar to NetworkX, which simplify operations like:<ul> <li>Node Operations: <code>has_node</code>, <code>add_node</code>, <code>remove_node</code>, <code>get_node_data</code></li> <li>Edge Operations: <code>has_edge</code>, <code>add_edge</code>, <code>get_edge_data</code>, <code>get_node_edges</code></li> <li>Degree Calculation: <code>degree</code> for nodes and edges.</li> </ul> </li> </ul> </li> <li><p>Key Methods</p> <ul> <li>Storage Operations:<ul> <li><code>upsert_node</code>: Inserts or updates a node with its data.</li> <li><code>upsert_edge</code>: Inserts or updates an edge between two nodes.</li> <li><code>delete_node</code>: Deletes a node if it exists.</li> </ul> </li> <li>Data Retrieval:<ul> <li><code>get_node</code>: Retrieves data for a specific node.</li> <li><code>get_edge</code>: Retrieves data for a specific edge.</li> <li><code>get_node_edges</code>: Retrieves all edges for a given node.</li> </ul> </li> <li>Graph Metrics:<ul> <li><code>node_degree</code>: Returns the degree of a node.</li> <li><code>edge_degree</code>: Calculates combined degrees of two nodes.</li> </ul> </li> </ul> </li> <li><p>Additional Notes</p> <ul> <li>The <code>clean_quotes</code> method ensures clean input values by stripping leading and trailing quotes from strings.</li> <li>TigerGraphX goes beyond NetworkX\u2019s capabilities by supporting heterogeneous graphs (graphs with multiple types of nodes and edges) using the <code>Graph</code> class, in addition to undirected (<code>UndiGraph</code>) and directed graphs (<code>DiGraph</code>).</li> </ul> </li> </ol> In\u00a0[3]: Copied! <pre>from lightrag import LightRAG\n\n\n# Define a subclass to include your custom graph storage in the storage mapping\nclass CustomLightRAG(LightRAG):\n    def _get_storage_class(self):\n        # Extend the default storage mapping with your custom storage\n        base_mapping = super()._get_storage_class()\n        base_mapping[\"TigerGraphStorage\"] = TigerGraphStorage\n        return base_mapping\n</pre> from lightrag import LightRAG   # Define a subclass to include your custom graph storage in the storage mapping class CustomLightRAG(LightRAG):     def _get_storage_class(self):         # Extend the default storage mapping with your custom storage         base_mapping = super()._get_storage_class()         base_mapping[\"TigerGraphStorage\"] = TigerGraphStorage         return base_mapping In\u00a0[\u00a0]: Copied! <pre>import logging\nimport nest_asyncio\n# Use the nest_asyncio package to allow running nested event loops in Jupyter Notebook without conflicts.\nnest_asyncio.apply()\n\n# Set log level to WARNING\nlogger = logging.getLogger(\"lightrag\")\nlogger.setLevel(logging.WARNING)\nlogger.propagate = False\nlogger = logging.getLogger(\"httpx\")\nlogger.setLevel(logging.WARNING)\nlogger.propagate = False\nlogging.basicConfig(level=logging.WARNING)\n\nworking_dir = \"../../applications/lightrag/data\"\n\ncustom_rag = CustomLightRAG(\n    working_dir=working_dir,\n    graph_storage=\"TigerGraphStorage\",\n)\n\nwith open(working_dir + \"/input/fin.txt\") as f:\n    custom_rag.insert(f.read())\n</pre> import logging import nest_asyncio # Use the nest_asyncio package to allow running nested event loops in Jupyter Notebook without conflicts. nest_asyncio.apply()  # Set log level to WARNING logger = logging.getLogger(\"lightrag\") logger.setLevel(logging.WARNING) logger.propagate = False logger = logging.getLogger(\"httpx\") logger.setLevel(logging.WARNING) logger.propagate = False logging.basicConfig(level=logging.WARNING)  working_dir = \"../../applications/lightrag/data\"  custom_rag = CustomLightRAG(     working_dir=working_dir,     graph_storage=\"TigerGraphStorage\", )  with open(working_dir + \"/input/fin.txt\") as f:     custom_rag.insert(f.read()) <p>Note that the output has been cleared here because it is too long, and most of the information consists of logs.</p> In\u00a0[5]: Copied! <pre>from lightrag import QueryParam\n\ncustom_rag = CustomLightRAG(\n    working_dir=working_dir,\n    graph_storage=\"TigerGraphStorage\",\n)\n\nquery = \"What is the overall financial health of the company?\"\n\nresult = custom_rag.query(query=query, param=QueryParam(mode=\"hybrid\"))\n\nprint(\"------------------- Query Result:  -------------------\")\nprint(result)\n</pre> from lightrag import QueryParam  custom_rag = CustomLightRAG(     working_dir=working_dir,     graph_storage=\"TigerGraphStorage\", )  query = \"What is the overall financial health of the company?\"  result = custom_rag.query(query=query, param=QueryParam(mode=\"hybrid\"))  print(\"------------------- Query Result:  -------------------\") print(result) <pre>2024-12-17 23:06:03,237 - nano-vectordb - INFO - Load (704, 1536) data\n2024-12-17 23:06:03,240 - nano-vectordb - INFO - Init {'embedding_dim': 1536, 'metric': 'cosine', 'storage_file': '../../applications/lightrag/data/vdb_entities.json'} 704 data\n2024-12-17 23:06:03,264 - nano-vectordb - INFO - Load (397, 1536) data\n2024-12-17 23:06:03,267 - nano-vectordb - INFO - Init {'embedding_dim': 1536, 'metric': 'cosine', 'storage_file': '../../applications/lightrag/data/vdb_relationships.json'} 397 data\n2024-12-17 23:06:03,271 - nano-vectordb - INFO - Load (46, 1536) data\n2024-12-17 23:06:03,272 - nano-vectordb - INFO - Init {'embedding_dim': 1536, 'metric': 'cosine', 'storage_file': '../../applications/lightrag/data/vdb_chunks.json'} 46 data\n{\n  \"high_level_keywords\": [\"Financial health\", \"Company performance\", \"Business sustainability\"],\n  \"low_level_keywords\": [\"Revenue\", \"Expenses\", \"Profit margins\", \"Debt\", \"Cash flow\", \"Assets\"]\n}\n------------------- Query Result:  -------------------\nThe financial health of CytoSorbents Corporation can be assessed through various aspects such as revenue generation, funding, equity transactions, and partnerships, which offer insights into its operational effectiveness and sustainability.\n\n### Revenue Generation\n\nCytoSorbents Corporation primarily generates revenue through the sales of its flagship product, CytoSorb. Since its launch in Germany in 2012, the company has achieved cumulative sales of approximately $111.8 million by the end of 2020. A significant portion of the company's revenue is sourced from direct product sales in Germany, where reimbursement has been established for CytoSorb, aiding its adoption in critical care settings. Additionally, the company has expanded its reach to other European countries and regions, establishing commercial partnerships to enhance market penetration.\n\n### Funding and Financial Support\n\nThe company has actively sought funding to support its research and development efforts, securing grants and contracts amounting to approximately $28.4 million from notable sources including DARPA, the U.S. Army, and the National Heart, Lung, and Blood Institute. This financial backing underscores the company\u2019s ability to leverage government funding for growth and innovation in medical technology. Moreover, the company has utilized convertible notes, equity transactions, and term loans as financing mechanisms, further diversifying its funding sources.\n\n### Equity Transactions\n\nCytoSorbents Corporation has engaged in public offerings to raise capital. On July 24, 2020, the company closed an underwritten public offering that raised approximately $53.8 million in net proceeds. This indicates robust market interest and the company\u2019s ability to access capital markets effectively, which is vital for ongoing development and commercialization efforts.\n\n### Partnerships and Strategic Collaborations\n\nCollaboration with partners such as B. Braun Avitum AG, Biocon Biologics Limited, and Fresenius Medical Care has enabled CytoSorbents to expand its distribution network and enhance the visibility of its products across different markets. These partnerships not only facilitate market entry but also strengthen the overall financial standing by broadening the revenue base.\n\n### Conclusion\n\nIn summary, the financial health of CytoSorbents Corporation appears solid, characterized by consistent revenue streams from its primary product, strategic use of funding to support ongoing research and development, and successful capital raising activities. Collaborations with reputable partners add a layer of financial stability and potential for future growth. However, like any company in the biotech sector, the financial outlook will be subject to the usual risks associated with regulatory approvals, market acceptance, and competition within the healthcare industry.\n</pre>"},{"location":"graphrag/lightrag/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Before proceeding, ensure you\u2019ve completed the installation and setup steps outlined in the Installation Guide, including:</p> <ul> <li><p>Setting up Python and TigerGraph. For more details, refer to the Requirements section.</p> </li> <li><p>Install TigerGraphX along with its development dependencies. For more details, refer to the Development Installation section.</p> </li> <li><p>Set the environment variables <code>TG_HOST</code>, <code>TG_USERNAME</code>, and <code>TG_PASSWORD</code>, which are required to connect to the TigerGraph server, as well as <code>OPENAI_API_KEY</code> for connecting to OpenAI. Use a command like the following to set these variables:</p> <pre>export TG_HOST=https://127.0.0.1\n</pre> </li> </ul>"},{"location":"graphrag/lightrag/#implement-graph-storage-with-tigergraphx","title":"Implement Graph Storage with TigerGraphX\u00b6","text":"<p>In LightRAG, the storage layers are abstracted into components such as graph storage, key-value storage, and vector storage. You can refer to the base classes BaseGraphStorage, BaseVectorStorage, and BaseKVStorage in the source code.</p> <p>In this section, we will demonstrate how to use TigerGraphX to implement the <code>BaseGraphStorage</code> class for storing and retrieving data in TigerGraph.</p>"},{"location":"graphrag/lightrag/#integrating-custom-graph-storage-with-lightrag","title":"Integrating Custom Graph Storage with LightRAG\u00b6","text":"<p>After defining the <code>TigerGraphStorage</code> class, we integrate it into LightRAG. By subclassing LightRAG and extending its storage mapping, you can easily replace or augment the default storage backends with your custom solution.</p> <p>While modifying the LightRAG source code is another option, this example demonstrates how to achieve the integration without altering the original source code.</p> <p>Below is the code for creating a <code>CustomLightRAG</code> class that incorporates <code>TigerGraphStorage</code> into its storage mapping.</p>"},{"location":"graphrag/lightrag/#indexing","title":"Indexing\u00b6","text":""},{"location":"graphrag/lightrag/#data-preparation","title":"Data Preparation\u00b6","text":""},{"location":"graphrag/lightrag/#set-up-working-directory","title":"Set Up Working Directory\u00b6","text":"<p>Create a folder to serve as the working directory. For this demo, we will use <code>applications/lightrag/data</code>.</p> <p>Next, create an <code>input</code> folder inside the <code>data</code> directory to store the documents you want to index:</p> <pre>mkdir -p applications/lightrag/data/input\n</pre>"},{"location":"graphrag/lightrag/#add-documents-to-the-input-folder","title":"Add Documents to the Input Folder\u00b6","text":"<p>Copy your documents (e.g., <code>fin.txt</code>) into the <code>applications/lightrag/data/input</code> folder.</p>"},{"location":"graphrag/lightrag/#indexing","title":"Indexing\u00b6","text":"<p>The following code sets up a working directory and demonstrates how to index a given document using LightRAG.</p>"},{"location":"graphrag/lightrag/#querying","title":"Querying\u00b6","text":"<p>The following code demonstrates how to perform a query in LightRAG using the TigerGraph graph storage implementation.</p>"},{"location":"graphrag/msft_graphrag_1/","title":"Supporting Microsoft\u2019s GraphRAG: Part 1","text":"<p>Microsoft's GraphRAG is a method for creating structured knowledge graphs from raw text, enhancing Retrieval Augmented Generation (RAG) tasks. By organizing information hierarchically, it enables more efficient data retrieval and summarization.</p>"},{"location":"graphrag/msft_graphrag_1/#what-youll-learn-in-this-guide","title":"What You\u2019ll Learn in This Guide","text":"<ul> <li>Indexing: Utilize Microsoft's GraphRAG to convert unstructured documents into Parquet files.</li> <li>Data Preprocessing: Learn how to use utility methods provided by TigerGraphX to transform Parquet files into CSV files compatible with TigerGraph.</li> <li>Schema Design: Understand how to design a graph schema for storing your data.</li> <li>Data Loading: Map the CSV files to the graph schema and load them into TigerGraph seamlessly.</li> </ul>"},{"location":"graphrag/msft_graphrag_1/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you\u2019ve completed the installation and setup steps outlined in the Installation Guide, including:</p> <ul> <li>Setting up Python and TigerGraph. For more details, refer to the Requirements section.</li> <li>Install TigerGraphX along with its development dependencies. For more details, refer to the Development Installation section.</li> </ul>"},{"location":"graphrag/msft_graphrag_1/#utilize-microsoft-graphrag-for-indexing","title":"Utilize Microsoft GraphRAG for Indexing","text":"<p>The indexing process transforms raw documents into structured data using Microsoft\u2019s GraphRAG. Follow these steps to prepare your data:</p>"},{"location":"graphrag/msft_graphrag_1/#data-preparation","title":"Data Preparation","text":""},{"location":"graphrag/msft_graphrag_1/#create-an-input-folder","title":"Create an Input Folder","text":"<p>Create an <code>input</code> folder in the <code>data</code> directory under <code>applications/msft_graphrag</code> to store the documents you want to index. You can specify a different directory by replacing <code>data</code> with your desired path.</p> <pre><code>mkdir -p data/input\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#add-documents-to-the-input-folder","title":"Add Documents to the Input Folder","text":"<p>Copy your documents (e.g., <code>fin.txt</code>) into the <code>data/input</code> folder.</p>"},{"location":"graphrag/msft_graphrag_1/#initialization","title":"Initialization","text":"<p>Initialize the indexing system in the <code>data</code> directory.</p> <pre><code>python3 -m graphrag init --root data\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#set-up-openai-api-key","title":"Set Up OpenAI API Key","text":"<p>GraphRAG requires an OpenAI API key. To configure it:</p> <ol> <li>Open the <code>.env</code> file in the <code>data</code> directory:    <pre><code>vi data/.env\n</code></pre></li> <li>Add your API key:    <pre><code>GRAPHRAG_API_KEY=&lt;Your OpenAI API Key&gt;\n</code></pre></li> </ol>"},{"location":"graphrag/msft_graphrag_1/#optional-switch-to-a-cost-effective-model","title":"Optional: Switch to a Cost-Effective Model","text":"<p>GraphRAG uses the <code>gpt-4-turbo-preview</code> model by default. To reduce costs, switch to the <code>gpt-4o-mini</code> model by editing the <code>settings.yaml</code> file in the <code>data</code> directory:</p> <pre><code>llm:\n  api_key: ${GRAPHRAG_API_KEY}\n  type: openai_chat # or azure_openai_chat\n  model: gpt-4o-mini # Use a cost-effective model\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#indexing","title":"Indexing","text":"<p>Run the indexing process to convert documents into structured data. This step uses LLMs and may take several minutes depending on the dataset size and hardware.</p> <pre><code>python3 -m graphrag index --no-cache --root data\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#utilize-tigergraphx-for-data-preprocessing","title":"Utilize TigerGraphX for Data Preprocessing","text":"<p>Transform the structured Parquet files generated by GraphRAG into CSV files that TigerGraph can import.</p>"},{"location":"graphrag/msft_graphrag_1/#convert-parquet-to-csv","title":"Convert Parquet to CSV","text":"<p>Run the script below to convert Parquet files into TigerGraph-compatible CSV files. You can find the Python script here.</p> <pre><code>python3 data_import/convert_parquet_to_tg_csv.py \\\n--input_dir data/output \\\n--output_dir data/tg_csv\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#transfer-csv-files-to-tigergraph-server","title":"Transfer CSV Files to TigerGraph Server","text":"<p>Transfer the generated CSV files to your TigerGraph server. Use the following command, replacing <code>username</code> and <code>tigergraph-server</code> with your server credentials:</p> <pre><code>scp data/tg_csv/* username@tigergraph-server:/home/tigergraph/data/graphrag\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#create-a-graph","title":"Create a Graph","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>Now, let's define the schema using Python. You can execute the following code in a Python shell or Jupyter Notebook. To access the original <code>.ipynb</code> file, download it from msft_graphrag_1_1.ipynb.</p>"},{"location":"graphrag/msft_graphrag_1/#define-a-graph-schema","title":"Define a Graph Schema","text":"<p>In this example, we will initialize a graph using a schema defined in a YAML file. The schema structure is represented visually in the following image.</p> <p></p> <p>First, convert the YAML file into a graph schema using the <code>GraphSchema.ensure_config</code> method. <pre><code>from tigergraphx import Graph, GraphSchema, LoadingJobConfig, TigerGraphConnectionConfig\nresource_dir = \"../../applications/msft_graphrag/query/resources/\"\nschema_path = resource_dir + \"graph_schema.yaml\"\ngraph_schema=GraphSchema.ensure_config(schema_path)\n</code></pre></p>"},{"location":"graphrag/msft_graphrag_1/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p> <pre><code>connection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"user_name\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#create-a-graph_1","title":"Create a Graph","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p> <pre><code>graph = Graph(\n    graph_schema=graph_schema,\n    tigergraph_connection_config=connection,\n    drop_existing_graph=False,\n)\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#load-data-to-tigergraph","title":"Load Data to TigerGraph","text":"<p>We will load data into the graph using a pre-defined loading job configuration. The configuration is stored in a YAML file.</p> <pre><code>loading_job_path = resource_dir + \"loading_job_config.yaml\"\ngraph.load_data(loading_job_config=LoadingJobConfig.ensure_config(loading_job_path))\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#next-steps","title":"Next Steps","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 2: Use Jupyter Notebook to explore graph data and perform Graph Analysis.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_1_1/","title":"Msft graphrag 1 1","text":"In\u00a0[2]: Copied! <pre>from tigergraphx import Graph, GraphSchema, LoadingJobConfig, TigerGraphConnectionConfig\nresource_dir = \"../../applications/msft_graphrag/query/resources/\"\nschema_path = resource_dir + \"graph_schema.yaml\"\ngraph_schema=GraphSchema.ensure_config(schema_path)\n</pre> from tigergraphx import Graph, GraphSchema, LoadingJobConfig, TigerGraphConnectionConfig resource_dir = \"../../applications/msft_graphrag/query/resources/\" schema_path = resource_dir + \"graph_schema.yaml\" graph_schema=GraphSchema.ensure_config(schema_path) In\u00a0[3]: Copied! <pre>connection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"user_name\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\n</pre> connection = TigerGraphConnectionConfig.ensure_config({     \"host\": \"http://127.0.0.1\",     \"user_name\": \"tigergraph\",     \"password\": \"tigergraph\", }) In\u00a0[4]: Copied! <pre>graph = Graph(\n    graph_schema=graph_schema,\n    tigergraph_connection_config=connection,\n    drop_existing_graph=False,\n)\n</pre> graph = Graph(     graph_schema=graph_schema,     tigergraph_connection_config=connection,     drop_existing_graph=False, ) In\u00a0[5]: Copied! <pre>print(graph.number_of_nodes())\n</pre> print(graph.number_of_nodes()) <pre>0\n</pre> <p>After that, we will load data into the graph using a pre-defined loading job configuration. The configuration is stored in a YAML file.</p> In\u00a0[6]: Copied! <pre>loading_job_path = resource_dir + \"loading_job_config.yaml\"\ngraph.load_data(loading_job_config=LoadingJobConfig.ensure_config(loading_job_path))\n</pre> loading_job_path = resource_dir + \"loading_job_config.yaml\" graph.load_data(loading_job_config=LoadingJobConfig.ensure_config(loading_job_path)) <p>Now, let's check the total number of nodes in the graph again. We should observe that some nodes have been successfully loaded into the graph.</p> In\u00a0[7]: Copied! <pre>print(graph.number_of_nodes())\n</pre> print(graph.number_of_nodes()) <pre>808\n</pre>"},{"location":"graphrag/msft_graphrag_1_1/#create-a-graph","title":"Create a Graph\u00b6","text":""},{"location":"graphrag/msft_graphrag_1_1/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we will initialize a graph using a schema defined in a YAML file.</p> <p>First, convert the YAML file into a graph schema using the <code>GraphSchema.ensure_config</code> method.</p>"},{"location":"graphrag/msft_graphrag_1_1/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p>"},{"location":"graphrag/msft_graphrag_1_1/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"graphrag/msft_graphrag_1_1/#load-data","title":"Load Data\u00b6","text":"<p>First, let's check the total number of nodes in the graph. As anticipated, the graph is currently empty.</p>"},{"location":"graphrag/msft_graphrag_2/","title":"Supporting Microsoft's GraphRAG: Part 2","text":"In\u00a0[2]: Copied! <pre>from tigergraphx import Graph, TigerGraphConnectionConfig\nconnection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"user_name\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\nG = Graph.from_db(\"GraphRAG\", connection)\n</pre> from tigergraphx import Graph, TigerGraphConnectionConfig connection = TigerGraphConnectionConfig.ensure_config({     \"host\": \"http://127.0.0.1\",     \"user_name\": \"tigergraph\",     \"password\": \"tigergraph\", }) G = Graph.from_db(\"GraphRAG\", connection) In\u00a0[3]: Copied! <pre>schema = G.get_schema()\nschema[\"graph_name\"]\n</pre> schema = G.get_schema() schema[\"graph_name\"] Out[3]: <pre>'GraphRAG'</pre> In\u00a0[4]: Copied! <pre>for node in schema[\"nodes\"].items():\n    print(node)\n</pre> for node in schema[\"nodes\"].items():     print(node) <pre>('Document', {'primary_key': 'id', 'attributes': {'title': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}})\n('TextUnit', {'primary_key': 'id', 'attributes': {'text': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'n_tokens': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}})\n('Entity', {'primary_key': 'id', 'attributes': {'human_readable_id': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'name': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'entity_type': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'description': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}})\n('Relationship', {'primary_key': 'id', 'attributes': {'human_readable_id': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'rank': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'weight': {'data_type': &lt;DataType.DOUBLE: 'DOUBLE'&gt;, 'default_value': None}, 'description': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}})\n('Community', {'primary_key': 'id', 'attributes': {'level': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'rank': {'data_type': &lt;DataType.DOUBLE: 'DOUBLE'&gt;, 'default_value': None}, 'rank_explanation': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'title': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'full_content': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'summary': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}})\n</pre> In\u00a0[5]: Copied! <pre>for edge in schema[\"edges\"].items():\n    print(edge)\n</pre> for edge in schema[\"edges\"].items():     print(edge) <pre>('document_contains_text_unit', {'is_directed_edge': False, 'from_node_type': 'Document', 'to_node_type': 'TextUnit', 'attributes': {}})\n('text_unit_contains_entity', {'is_directed_edge': False, 'from_node_type': 'TextUnit', 'to_node_type': 'Entity', 'attributes': {}})\n('text_unit_contains_relationship', {'is_directed_edge': False, 'from_node_type': 'TextUnit', 'to_node_type': 'Relationship', 'attributes': {}})\n('relationship_source', {'is_directed_edge': False, 'from_node_type': 'Relationship', 'to_node_type': 'Entity', 'attributes': {}})\n('relationship_target', {'is_directed_edge': False, 'from_node_type': 'Relationship', 'to_node_type': 'Entity', 'attributes': {}})\n('community_contains_entity', {'is_directed_edge': False, 'from_node_type': 'Community', 'to_node_type': 'Entity', 'attributes': {}})\n('community_contains_relationship', {'is_directed_edge': False, 'from_node_type': 'Community', 'to_node_type': 'Relationship', 'attributes': {}})\n</pre> In\u00a0[6]: Copied! <pre>G.number_of_nodes()\n</pre> G.number_of_nodes() Out[6]: <pre>931</pre> In\u00a0[7]: Copied! <pre>for node_type in schema[\"nodes\"]:\n    print(f\"{node_type}: {G.number_of_nodes(node_type)}\")\n</pre> for node_type in schema[\"nodes\"]:     print(f\"{node_type}: {G.number_of_nodes(node_type)}\") <pre>Document: 1\nTextUnit: 47\nEntity: 398\nRelationship: 426\nCommunity: 59\n</pre> In\u00a0[8]: Copied! <pre>G.number_of_edges()\n</pre> G.number_of_edges() Out[8]: <pre>3630</pre> In\u00a0[9]: Copied! <pre>for edge_type in schema[\"edges\"]:\n    print(f\"{edge_type}: {G.number_of_edges(edge_type)}\")\n</pre> for edge_type in schema[\"edges\"]:     print(f\"{edge_type}: {G.number_of_edges(edge_type)}\") <pre>document_contains_text_unit: 47\ntext_unit_contains_entity: 699\ntext_unit_contains_relationship: 517\nrelationship_source: 426\nrelationship_target: 426\ncommunity_contains_entity: 566\ncommunity_contains_relationship: 949\n</pre> In\u00a0[10]: Copied! <pre>G.get_nodes(node_type=\"Entity\", limit=2)\n</pre> G.get_nodes(node_type=\"Entity\", limit=2) Out[10]: v_id v_type human_readable_id entity_type name description id 0 7373c84a439841d580b4650dac71136f Entity 328 ORGANIZATION HEMERUS CORPORATION Hemerus Corporation is mentioned as one of the... 7373c84a439841d580b4650dac71136f 1 4a5ddbde3f354a79bb5ae3436ab67d25 Entity 294 ORGANIZATION RENALGUARD RenalGuard, developed by RenalGuard Solutions,... 4a5ddbde3f354a79bb5ae3436ab67d25 In\u00a0[11]: Copied! <pre>G.get_nodes(node_type=\"Relationship\", limit=2)\n</pre> G.get_nodes(node_type=\"Relationship\", limit=2) Out[11]: v_id v_type human_readable_id rank weight description id 0 f09d47220cf146a4bc9869976740f230 Relationship 111 122 1 CytoSorb received funding from JPEO-CBD for a ... f09d47220cf146a4bc9869976740f230 1 89d0f67d14504ef19601f6ff0eb2b32c Relationship 7 126 35 CytoSorb, a therapeutic device, has made signi... 89d0f67d14504ef19601f6ff0eb2b32c In\u00a0[12]: Copied! <pre>G.get_nodes(node_type=\"Community\", limit=2)\n</pre> G.get_nodes(node_type=\"Community\", limit=2) Out[12]: v_id v_type summary level full_content rank id rank_explanation title 0 8 Community This report focuses on Baxter and its signific... 0 # Baxter's Innovations in Dialysis and Sepsis ... 8.5 8 The high impact severity rating reflects Baxte... Community 8 1 16 Community The REMOVE study, focusing on the use of CytoS... 0 # REMOVE Study and Its Oversight Community\\n\\n... 7.5 16 The impact severity rating is high due to the ... Community 16"},{"location":"graphrag/msft_graphrag_2/#supporting-microsofts-graphrag-part-2","title":"Supporting Microsoft\u2019s GraphRAG: Part 2\u00b6","text":"<p>In the previous section, we utilized Microsoft's GraphRAG to transform unstructured documents into Parquet files. Using TigerGraphX, we then converted these files into CSV format, created a graph in TigerGraph, and loaded the CSV data into it.</p> <p>Now, let\u2019s use Jupyter Notebook to explore the graph data and perform graph analysis.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_2.ipynb.</p>"},{"location":"graphrag/msft_graphrag_2/#get-the-graph-from-tigergraph","title":"Get the Graph from TigerGraph\u00b6","text":"<p>Since the graph has already been created in TigerGraph, redefining its schema is unnecessary. Instead, you can provide the graph name to retrieve it. TigerGraphX will verify if the graph exists in TigerGraph and, if it does, will return the corresponding graph.</p>"},{"location":"graphrag/msft_graphrag_2/#display-the-graph-schema","title":"Display the Graph Schema\u00b6","text":"<p>Let's retrieve the graph schema using the <code>get_schema</code> method. The output is a Python dictionary containing three keys: <code>\"graph_name\"</code>, <code>\"nodes\"</code>, and <code>\"edges\"</code>. We'll print each of them individually to explore the schema details.</p>"},{"location":"graphrag/msft_graphrag_2/#retrieve-the-graph-schema-and-display-the-graph-name","title":"Retrieve the Graph Schema and Display the Graph Name\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-the-node-tyeps","title":"Display the Node Tyeps\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-the-edge-types","title":"Display the Edge Types\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-node-and-edge-counts","title":"Display Node and Edge Counts\u00b6","text":"<p>Gain deeper insights into the graph by exploring details such as the total number of nodes and the count of nodes for each node type.</p>"},{"location":"graphrag/msft_graphrag_2/#display-the-total-number-of-nodes","title":"Display the Total Number of Nodes\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-the-count-of-nodes-for-each-node-type","title":"Display the Count of Nodes for Each Node Type\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-the-total-number-of-edges","title":"Display the Total Number of Edges\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-the-count-of-edges-for-each-edge-type","title":"Display the Count of Edges for Each Edge Type\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#retrieve-sample-nodes-from-the-graph","title":"Retrieve Sample Nodes from the Graph\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#whats-next","title":"What\u2019s Next?\u00b6","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 3: Perform queries using GSQL and Python-native TigerGraphX, with global and local context builders.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_3/","title":"Supporting Microsoft's GraphRAG: Part 3","text":"In\u00a0[2]: Copied! <pre>from tigergraphx import Graph, TigerGraphConnectionConfig\nconnection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"user_name\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\nG = Graph.from_db(\"GraphRAG\", connection)\n</pre> from tigergraphx import Graph, TigerGraphConnectionConfig connection = TigerGraphConnectionConfig.ensure_config({     \"host\": \"http://127.0.0.1\",     \"user_name\": \"tigergraph\",     \"password\": \"tigergraph\", }) G = Graph.from_db(\"GraphRAG\", connection) In\u00a0[3]: Copied! <pre>G.get_nodes(\n    node_type=\"Entity\",\n    return_attributes=[\"id\", \"name\", \"entity_type\", \"description\"],\n    limit=2,\n)\n</pre> G.get_nodes(     node_type=\"Entity\",     return_attributes=[\"id\", \"name\", \"entity_type\", \"description\"],     limit=2, ) Out[3]: id name entity_type description 0 7373c84a439841d580b4650dac71136f HEMERUS CORPORATION ORGANIZATION Hemerus Corporation is mentioned as one of the... 1 4a5ddbde3f354a79bb5ae3436ab67d25 RENALGUARD ORGANIZATION RenalGuard, developed by RenalGuard Solutions,... In\u00a0[4]: Copied! <pre>start_nodes = [\"7373c84a439841d580b4650dac71136f\", \"4a5ddbde3f354a79bb5ae3436ab67d25\"]\nG.get_neighbors(\n    start_nodes=start_nodes,\n    start_node_type=\"Entity\",\n    edge_types=\"community_contains_entity\",\n    return_attributes=[\"id\", \"title\", \"full_content\"],\n)\n</pre> start_nodes = [\"7373c84a439841d580b4650dac71136f\", \"4a5ddbde3f354a79bb5ae3436ab67d25\"] G.get_neighbors(     start_nodes=start_nodes,     start_node_type=\"Entity\",     edge_types=\"community_contains_entity\",     return_attributes=[\"id\", \"title\", \"full_content\"], ) Out[4]: id title full_content 0 30 Community 30 # CytoSorb and Global Healthcare Impact\\n\\nThi... 1 10 Community 10 # Innovations in Preventing Contrast-Induced N... 2 1 Community 1 # CytoSorb and Its Global Healthcare Impact\\n\\... In\u00a0[5]: Copied! <pre>import tiktoken\nfrom typing import Optional, List\nfrom tigergraphx.graphrag import BaseContextBuilder\nfrom tigergraphx.core import Graph\nclass GlobalContextBuilder(BaseContextBuilder):\n    def __init__(\n        self,\n        graph: Graph,\n        token_encoder: Optional[tiktoken.Encoding] = None,\n    ):\n        \"\"\"Initialize LocalContextBuilder with graph config and token encoder.\"\"\"\n        super().__init__(\n            graph=graph,\n            single_batch=False,\n            token_encoder=token_encoder,\n        )\n    async def build_context(self) -&gt; str | List[str]:\n        \"\"\"Build local context.\"\"\"\n        context: List[str] = []\n        config = {\n            \"max_tokens\": 12000,\n            \"section_name\": \"Communities\",\n            \"return_attributes\": [\"id\", \"rank\", \"title\", \"full_content\"],\n            \"limit\": 1000,\n        }\n        df = self.graph.get_nodes(\n            node_type=\"Community\",\n            return_attributes=config[\"return_attributes\"],\n            limit=config[\"limit\"],\n        )\n        if df is not None:\n            text_context = self.batch_and_convert_to_text(\n                graph_data=df,\n                max_tokens=config[\"max_tokens\"],\n                single_batch=self.single_batch,\n                section_name=config[\"section_name\"],\n            )\n            context.extend(\n                text_context if isinstance(text_context, list) else [text_context]\n            )\n        return context\n</pre> import tiktoken from typing import Optional, List from tigergraphx.graphrag import BaseContextBuilder from tigergraphx.core import Graph class GlobalContextBuilder(BaseContextBuilder):     def __init__(         self,         graph: Graph,         token_encoder: Optional[tiktoken.Encoding] = None,     ):         \"\"\"Initialize LocalContextBuilder with graph config and token encoder.\"\"\"         super().__init__(             graph=graph,             single_batch=False,             token_encoder=token_encoder,         )     async def build_context(self) -&gt; str | List[str]:         \"\"\"Build local context.\"\"\"         context: List[str] = []         config = {             \"max_tokens\": 12000,             \"section_name\": \"Communities\",             \"return_attributes\": [\"id\", \"rank\", \"title\", \"full_content\"],             \"limit\": 1000,         }         df = self.graph.get_nodes(             node_type=\"Community\",             return_attributes=config[\"return_attributes\"],             limit=config[\"limit\"],         )         if df is not None:             text_context = self.batch_and_convert_to_text(                 graph_data=df,                 max_tokens=config[\"max_tokens\"],                 single_batch=self.single_batch,                 section_name=config[\"section_name\"],             )             context.extend(                 text_context if isinstance(text_context, list) else [text_context]             )         return context <p>Here\u2019s how you can utilize the custom global context builder:</p> In\u00a0[15]: Copied! <pre>global_context_builder = GlobalContextBuilder(G)\ncontext_list = await global_context_builder.build_context()\n# Print the first 1000 characters for easier visualization of long text\nprint(context_list[0][:1000])\n</pre> global_context_builder = GlobalContextBuilder(G) context_list = await global_context_builder.build_context() # Print the first 1000 characters for easier visualization of long text print(context_list[0][:1000]) <pre>-----Communities-----\nid|rank|title|full_content\n34|8.5|Community 34|# CytoSorb and FDA: Advancing Cardiac Surgery Innovations\\n\\nThis report focuses on the collaborative efforts between CytoSorb, the U.S. Food and Drug Administration (FDA), and academic institutions in advancing cardiac surgery innovations through the REFRESH I study and its implications for patient care. It highlights the regulatory approvals, the study's publication, and its presentation in prestigious medical forums.\\n\\n## FDA's pivotal role in CytoSorb's cardiac surgery innovations\\n\\nThe U.S. Food and Drug Administration (FDA) has been instrumental in the progression of CytoSorb's cardiac surgery innovations, particularly through the approval of the Investigational Device Exemption (IDE) for the REFRESH I study and subsequent amendments. This approval process underscores the FDA's commitment to facilitating the development of medical devices that can significantly improve patient outcomes. Furthermore, the FDA's \n</pre>"},{"location":"graphrag/msft_graphrag_3/#supporting-microsofts-graphrag-part-3","title":"Supporting Microsoft\u2019s GraphRAG: Part 3\u00b6","text":"<p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_3.ipynb.</p>"},{"location":"graphrag/msft_graphrag_3/#get-the-graph-from-tigergraph","title":"Get the Graph from TigerGraph\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#hybrid-retrieval","title":"Hybrid Retrieval\u00b6","text":"<p>TigerGraph offers two flexible ways to perform hybrid retrieval, allowing you to extract relevant graph and vector data efficiently for GraphRAG workflows.</p>"},{"location":"graphrag/msft_graphrag_3/#using-tigergraphx","title":"Using TigerGraphX\u00b6","text":"<p>TigerGraphX offers an intuitive, Python-native interface for hybrid retrieval, ideal for developers seeking simplicity and ease of use.</p> <p>Key Advantage: Minimal learning curve with high-level Python APIs, seamlessly integrated with existing workflows.</p> <p>Below are some illustrative examples.</p>"},{"location":"graphrag/msft_graphrag_3/#retrieve-nodes-with-specific-attributes","title":"Retrieve Nodes with Specific Attributes\u00b6","text":"<p>You can use the following code to fetch up to two nodes of type \"Entity\" and display their \"id,\" \"entity_type,\" and \"description\" attributes.</p>"},{"location":"graphrag/msft_graphrag_3/#retrieve-neighbors-with-specific-attributes","title":"Retrieve Neighbors with Specific Attributes\u00b6","text":"<p>The following code demonstrates how to fetch neighbors of specific nodes. In this example, the query retrieves neighbors connected to the given <code>start_nodes</code> of type <code>\"Entity\"</code> through the edge type <code>\"community_contains_entity\"</code>. The attributes <code>\"id\"</code>, <code>\"title\"</code>, and <code>\"full_content\"</code> of the neighbors are returned.</p>"},{"location":"graphrag/msft_graphrag_3/#retrieve-top-k-using-tigervectors-vector-search-capability-planned-feature","title":"Retrieve Top-K Using TigerVector's Vector Search Capability [Planned Feature]\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#using-gsql","title":"Using GSQL\u00b6","text":"<p>For developers seeking fine-grained control or complex retrieval logic, GSQL offers unmatched flexibility. As TigerGraph's built-in query language, GSQL empowers you to perform advanced graph data analysis. For more details, see the official documentation.</p> <p>Key Advantage: Supports complex logic, customization, and direct interaction with TigerGraph\u2019s powerful query engine.</p> <ol> <li>Use an LLM to convert the query into an embedding.</li> <li>Write a GSQL query to retrieve the top-K similar objects and their neighbors, combining structured and vector-based retrieval:</li> </ol> <pre>CREATE OR REPLACE QUERY query (List&lt;float&gt; embedding, int k) {\n  Nodes = TopKVectorSearch({Entity.entity_embedding}, embedding, k);\n\n  Neighbors =\n    SELECT t\n    FROM Nodes:s -(community_contains_entity:e)- :t;\n\n  PRINT Neighbors[Neighbors.id, Neighbors.title, Neighbors.full_content];\n}\n</pre>"},{"location":"graphrag/msft_graphrag_3/#context-building-writing-custom-context-builders","title":"Context Building: Writing Custom Context Builders\u00b6","text":"<p>Context builders play a vital role in graph-powered RAG workflows. They transform retrieved graph data into structured, meaningful contexts for tasks such as interactions with LLMs).</p> <p>TigerGraphX simplifies this process by offering the flexible <code>BaseContextBuilder</code> class, which allows developers to define custom logic for context building.</p>"},{"location":"graphrag/msft_graphrag_3/#key-features-of-basecontextbuilder","title":"Key Features of <code>BaseContextBuilder</code>\u00b6","text":"<p>The <code>BaseContextBuilder</code> class in TigerGraphX provides a strong foundation for creating custom context builders, offering:</p> <ul> <li>Core Abstraction: A reusable framework for building context logic.</li> <li>Customizable Design: Extensibility for implementing both global and query-specific context generation.</li> </ul>"},{"location":"graphrag/msft_graphrag_3/#key-components","title":"Key Components\u00b6","text":"<ol> <li><p>Abstract Method - <code>build_context</code>: Subclasses must implement this method to define the logic for constructing context.</p> <pre>@abstractmethod\nasync def build_context(self, *args, **kwargs) -&gt; str | List[str]:\n    \"\"\"Abstract method to build context.\"\"\"\n    pass\n</pre> </li> <li><p>Batching and Retrieval Methods:</p> <ul> <li><code>batch_and_convert_to_text</code>: Formats graph data into token-aware text.</li> <li><code>retrieve_top_k_objects</code>: Efficiently retrieves top-K objects for query-based context.</li> </ul> </li> </ol>"},{"location":"graphrag/msft_graphrag_3/#example-global-context-builder","title":"Example: Global Context Builder\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#example-local-context-builder","title":"Example: Local Context Builder\u00b6","text":"<p>To understand the functionality of the <code>LocalContextBuilder</code> class, let's review the key code from its <code>build_context</code> method.</p> <p></p> <pre><code># Retrieve top-k objects\ntop_k_objects: List[str] = await self.retrieve_top_k_objects(query, k=k)\n...\n# Iterate over different neighbor types\nfor neighbor in neighbor_types:\n    df = self.graph.get_neighbors(...)\n    if df is not None:\n        text_context = self.batch_and_convert_to_text(...)\n        context.extend(\n            text_context if isinstance(text_context, list) else [text_context]\n        )\nreturn \"\\n\\n\".join(context)\n</code></pre> <p>For full implementations of different context builders, refer to the following links:</p> <ul> <li>LocalContextBuilder Code</li> </ul> <p>Here\u2019s how you can utilize the custom local context builder:</p> <pre>local_builder = LocalContextBuilder(graph=graph, search_engine=search_engine)\nlocal_context = await local_builder.build_context(query=\"What are the main topics discussed in the article?\")\n</pre>"},{"location":"graphrag/msft_graphrag_3/#integrate-with-llm","title":"Integrate with LLM\u00b6","text":"<p>After successfully building context from TigerGraph, the final step is integrating it with LLMs, including chat models and embedding models.</p> <p>We have provided an example implementation, which you can find here: Example Code.</p>"},{"location":"graphrag/msft_graphrag_3/#workflow-overview","title":"Workflow Overview\u00b6","text":"<p>The integration process follows the workflow illustrated below:</p> <p></p>"},{"location":"graphrag/msft_graphrag_3/#whats-next","title":"What\u2019s Next?\u00b6","text":"<ul> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"reference/features_overview/","title":"Features Overview","text":"<p>TigerGraphX is designed to simplify complex workflows involving graph databases, vector search, and large language models (LLMs). This page provides an overview of the key features of TigerGraphX and serves as a roadmap to the detailed API documentation for each functionality.</p>"},{"location":"reference/features_overview/#1-schema-management-graph-db","title":"1. Schema Management (Graph DB)","text":"<p>TigerGraphX provides intuitive, Python-native APIs for defining and managing graph schemas. This feature includes:</p> <ul> <li>Programmatic creation and modification of vertices and edges.</li> <li>Support for attributes, primary keys, and schema constraints.</li> <li>Compatibility with YAML and JSON schema definitions.</li> </ul>"},{"location":"reference/features_overview/#2-data-loading-management-graph-db","title":"2. Data Loading Management (Graph DB)","text":"<p>Efficiently load data into TigerGraph from a variety of sources. Key capabilities include:</p> <ul> <li>Support for Parquet and CSV files for high-efficiency workflows.</li> <li>Automated loading jobs to streamline the data import process.</li> <li>Data transformation utilities for pre-processing and compatibility.</li> </ul>"},{"location":"reference/features_overview/#3-graph-library-interface-graph-db-graph-query-language","title":"3. Graph Library Interface (Graph DB, Graph Query Language)","text":"<p>Perform common graph operations using Python-native APIs, including:</p> <ul> <li>CRUD operations for vertices and edges.</li> <li>Multi-hop traversals to analyze relationships in the graph.</li> <li>Graph reporting for insights and analysis.</li> </ul>"},{"location":"reference/features_overview/#4-graph-query-interface-graph-db-graph-query-language","title":"4. Graph Query Interface (Graph DB, Graph Query Language)","text":"<p>Execute advanced queries on your TigerGraph database with ease. This feature includes:</p> <ul> <li>Simplified query execution with Python-based methods.</li> <li>Query results formatted as Pandas DataFrames for seamless integration with analytics workflows.</li> </ul>"},{"location":"reference/features_overview/#5-vector-search-capabilities-vector-db","title":"5. Vector Search Capabilities (Vector DB)","text":"<p>Enhance AI-driven applications with vector embedding support. Key functionalities include:</p> <ul> <li>Storing and querying vector embeddings alongside graph data.</li> <li>Top-K similarity searches for retrieving the most relevant entities.</li> <li>Hybrid retrieval workflows combining graph traversal and vector search.</li> </ul>"},{"location":"reference/features_overview/#6-llm-integration-and-support-llm","title":"6. LLM Integration and Support (LLM)","text":"<p>Enable advanced applications by integrating graph data with large language models (LLMs). Key features:</p> <ul> <li>Token-aware context building for LLM workflows.</li> <li>Hybrid retrieval combining graph, semantic, and vector-based searches.</li> <li>Direct API integration with LLM platforms like OpenAI.</li> </ul>"},{"location":"reference/features_overview/#7-configuration-management-graph-db-vector-db-llm","title":"7. Configuration Management (Graph DB, Vector DB, LLM)","text":"<p>Simplify configuration for various integrations and workflows:</p> <ul> <li>Manage graph database settings programmatically.</li> <li>Configure vector search parameters for efficient retrieval.</li> <li>Customize LLM settings for seamless API interaction.</li> </ul>"},{"location":"reference/features_overview/#8-graphrag-support-graph-db-vector-db-llm","title":"8. GraphRAG Support (Graph DB, Vector DB, LLM)","text":"<p>TigerGraphX simplifies Graph-Retrieval Augmented Generation (GraphRAG) workflows. This feature includes:</p> <ul> <li>Schema definition and data preparation for GraphRAG.</li> <li>Hybrid retrieval methods optimized for GraphRAG use cases.</li> <li>Python-native APIs for context building and LLM integration.</li> </ul>"},{"location":"reference/features_overview/#next-steps","title":"Next Steps","text":"<p>To dive deeper into TigerGraphX\u2019s features, explore the detailed API documentation for each section. Start building powerful graph applications today!</p>"}]}