{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to TigerGraphX","text":"<p>TigerGraphX is a high-level Python library offering a unified, Python-native interface for graph databases, advanced analytics, and GraphRAG workflows. Combining the simplicity of NetworkX with the advanced capabilities of TigerGraph, including tgCloud, it empowers Python developers to harness the power of graphs without the need to learn query languages like Cypher or GSQL.</p> <p>TigerGraphX is designed for two main audiences, catering to different use cases while maintaining an easy-to-use, developer-friendly experience:</p>"},{"location":"#who-should-use-tigergraphx","title":"Who Should Use TigerGraphX?","text":""},{"location":"#1-python-developers-for-graph-analytics-with-tigergraph","title":"1. Python Developers for Graph Analytics with TigerGraph","text":"<p>If you\u2019re a Python developer interested in performing graph analytics with TigerGraph, TigerGraphX provides:</p> <ul> <li>Python-Native APIs: No need to learn complex query languages like GSQL or Cypher.</li> <li>Seamless Integration: Easily perform CRUD operations, multi-hop queries, and advanced analytics directly from Python.</li> <li>Scalability: Leverage the powerful performance of TigerGraph for large-scale graph processing.</li> </ul> <p>Start here:</p> <ul> <li>Introduction to TigerGraphX: Discover the features and benefits of using TigerGraphX for graph database management and analytics.</li> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>Quick Start Guide: Quickly set up TigerGraphX and build your first graph with this step-by-step guide.</li> </ul>"},{"location":"#2-python-developers-for-graphrag-workflows","title":"2. Python Developers for GraphRAG Workflows","text":"<p>If you\u2019re a Python developer building GraphRAG applications, TigerGraphX enables you to:</p> <ul> <li>Use TigerGraph as a scalable database for storing and retrieving graph and vector data generated by GraphRAG algorithms.</li> <li>Build token-aware LLM workflows for advanced AI applications.</li> <li>Utilize context builders to streamline data preparation for large language models.</li> </ul> <p>Start here:</p> <ul> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>GraphRAG Overview: Explore how TigerGraphX integrates with GraphRAG workflows.</li> <li>Supporting Microsoft\u2019s GraphRAG: An example of using TigerGraphX for GraphRAG workflows.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"introduction/","title":"TigerGraphX: Unified Graph Solutions for Python Developers","text":""},{"location":"introduction/#what-is-tigergraphx","title":"What is TigerGraphX?","text":"<p>TigerGraphX is a high-level Python library offering a unified, Python-native interface for graph databases, advanced analytics, and GraphRAG workflows. Combining the simplicity of NetworkX with the advanced capabilities of TigerGraph, including tgCloud, it empowers Python developers to harness the power of graphs without the need to learn query languages like Cypher or GSQL.</p>"},{"location":"introduction/#core-mission","title":"Core Mission","text":"<p>TigerGraphX seeks to democratize graph technology by providing an intuitive, all-encompassing framework that integrates and provides direct connection to:</p> <ul> <li>TigerGraph Database capabilities</li> <li>TigerGraph Vector Database functionality</li> <li>Large Language Model (LLM) integration</li> <li>TigerGraph\u2019s GraphRAG support for intelligent workflow</li> </ul>"},{"location":"introduction/#key-features","title":"Key Features","text":""},{"location":"introduction/#1-schema-management","title":"1. Schema Management","text":"<ul> <li>Easily create and modify schemas using YAML, JSON, or Python dictionaries.</li> <li>No GSQL knowledge is required.</li> <li>Pythonic tools for designing database structures effortlessly.</li> </ul>"},{"location":"introduction/#2-data-loading","title":"2. Data Loading","text":"<ul> <li>Automated loading jobs for streamlined data imports.</li> <li>High-efficiency workflows with support for Parquet files.</li> <li>Simplified data ingestion processes for faster setup.</li> </ul>"},{"location":"introduction/#3-graph-library-interface","title":"3. Graph Library Interface","text":"<ul> <li>Python-native APIs for CRUD operations.</li> <li>Comprehensive tools for graph reporting and visualization.</li> <li>Built-in graph algorithms including centrality, community detection, and path analysis algorithms</li> </ul>"},{"location":"introduction/#4-graph-query-interface","title":"4. Graph Query Interface","text":"<ul> <li>Simplified advanced querying with intuitive APIs.</li> <li>Seamless integration into analytics workflows via DataFrame outputs.</li> <li>Support for advanced multi-hop query traversal and manipulation</li> </ul>"},{"location":"introduction/#5-vector-search-capabilities","title":"5. Vector Search Capabilities","text":"<ul> <li>AI-driven applications with integrated vector embeddings.</li> <li>Efficient top-K entity retrieval for enhanced intelligence.</li> <li>Ideal for recommendation systems and contextual analysis.</li> </ul>"},{"location":"introduction/#6-llm-integration-and-graphrag-support","title":"6. LLM Integration and GraphRAG support","text":"<ul> <li>Full support for GraphRAG workflows.</li> <li>Flexible, token-aware context builders for advanced applications.</li> <li>Tools for token optimization and seamless LLM integration.</li> </ul>"},{"location":"introduction/#7-machine-learning-ready-planned-feature","title":"7. Machine Learning Ready [Planned Feature]","text":"<ul> <li>Seamless integration with popular ML libraries</li> <li>Graph feature extraction</li> <li>Native support for graph neural networks (GNNs)</li> </ul>"},{"location":"introduction/#why-choose-tigergraphx","title":"Why Choose TigerGraphX?","text":"<p>TigerGraphX redefines graph technology by making advanced and powerful graph operations accessible and intuitive for Python developers. With its unified, user-friendly interface, TigerGraphX bridges the gap between simplicity and scalability, enabling developers to:</p> <ul> <li>Leverage TigerGraph\u2019s unmatched scalability for high-performance graph processing.  </li> <li>Enjoy the familiarity of tools like NetworkX while unlocking enterprise-grade graph capabilities.  </li> <li>Access advanced graph analytics with ease, reducing the learning curve and technical barriers.  </li> <li>Develop intelligent, context-aware GraphRAG applications effortlessly with token-aware workflows and streamlined context builders.</li> </ul> <p>TigerGraphX empowers developers to explore, analyze, and build with graphs like never before\u2014efficiently and effectively.</p>"},{"location":"introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>GraphRAG Overview: Explore how TigerGraphX integrates with GraphRAG workflows.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/installation/","title":"Installation Guide","text":"<p>Follow this guide to install and set up TigerGraphX in your environment.</p>"},{"location":"getting_started/installation/#requirements","title":"Requirements","text":"<p>This project requires Python 3.12 and TigerGraph. Ensure you meet the following prerequisites before proceeding:</p>"},{"location":"getting_started/installation/#1-python-312","title":"1. Python 3.12","text":"<ul> <li>Please ensure Python 3.12 is installed on your system.</li> <li>You can download and install it from the official Python website.</li> </ul>"},{"location":"getting_started/installation/#2-tigergraph","title":"2. TigerGraph","text":"<p>TigerGraph is required for this project and can be set up in one of the following ways:</p> <ul> <li>TigerGraph DB: Install and configure a local instance of TigerGraph.</li> <li>TigerGraph Cloud: Use a cloud-hosted instance of TigerGraph.</li> </ul> <p>It is recommended to use TigerGraph LTS (Long-Term Support) Versions, which can be downloaded from the TigerGraph Downloads page. To enable support for TigerVector and leverage advanced features like hybrid retrieval, ensure you are using TigerGraph 4.2 or above.</p> <p>Refer to the official TigerGraph Documentation for detailed installation and configuration instructions.</p>"},{"location":"getting_started/installation/#installation-steps","title":"Installation Steps","text":""},{"location":"getting_started/installation/#option-1-install-from-pypi","title":"Option 1: Install from PyPI","text":"<p>The simplest way to get started with TigerGraphX is by installing it directly from PyPI. Using a virtual environment is recommended to ensure a clean and isolated setup.</p> <p>To install TigerGraphX, run: <pre><code>pip install tigergraphx\n</code></pre></p> <p>This allows you to quickly start using the library without needing the source code.</p>"},{"location":"getting_started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installing, verify that TigerGraphX is installed correctly by running: <pre><code>python -c \"import tigergraphx; print('TigerGraphX installed successfully!')\"\n</code></pre></p> <p>If the installation was successful, you will see: <pre><code>TigerGraphX installed successfully!\n</code></pre></p> <p>This ensures that the library is properly installed and ready for use.</p>"},{"location":"getting_started/installation/#option-2-build-from-source-code","title":"Option 2: Build from Source Code","text":"<p>If you want to modify or explore the source code, you can install TigerGraphX from its GitHub repository. The source code is available here: TigerGraphX on GitHub.</p> <p>This project uses Poetry to manage dependencies. If you don\u2019t have Poetry installed, follow the instructions on the Poetry website.</p> <p>Once Poetry is installed, clone the repository, navigate to the project\u2019s root directory, and use one of the following commands to install dependencies based on your needs:</p>"},{"location":"getting_started/installation/#core-installation","title":"Core Installation","text":"<p>If you need only the core functionality of TigerGraphX (without running application examples like GraphRAG, unit tests, or integration tests), run: <pre><code>poetry install --without dev\n</code></pre></p> <p>This command will:</p> <ul> <li>Install only the dependencies required for the core features of TigerGraphX.</li> </ul>"},{"location":"getting_started/installation/#development-installation","title":"Development Installation","text":"<p>If you\u2019re contributing to the project or want to use advanced features like running the GraphRAG examples or test cases, run: <pre><code>poetry install --with dev\n</code></pre></p> <p>This command will:</p> <ul> <li>Install all core dependencies.</li> <li>Include development dependencies defined under <code>[tool.poetry.group.dev.dependencies]</code> in <code>pyproject.toml</code>.</li> </ul>"},{"location":"getting_started/installation/#verify-your-installation","title":"Verify Your Installation","text":"<p>After installing dependencies, verify your setup by listing the installed packages: <pre><code>poetry show --with dev\n</code></pre></p> <p>This ensures all required dependencies (including optional ones) are successfully installed.</p>"},{"location":"getting_started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start: Learn how to build your first graph with TigerGraphX.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/quick_start/","title":"Quick Start Guide","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph\ngraph_schema = {\n    \"graph_name\": \"Social\",\n    \"nodes\": {\n        \"Person\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n                \"age\": \"UINT\",\n            },\n        },\n    },\n    \"edges\": {\n        \"Friendship\": {\n            \"is_directed_edge\": False,\n            \"from_node_type\": \"Person\",\n            \"to_node_type\": \"Person\",\n            \"attributes\": {\n                \"closeness\": \"DOUBLE\",\n            },\n        },\n    },\n}\n</pre> from tigergraphx import Graph graph_schema = {     \"graph_name\": \"Social\",     \"nodes\": {         \"Person\": {             \"primary_key\": \"name\",             \"attributes\": {                 \"name\": \"STRING\",                 \"age\": \"UINT\",             },         },     },     \"edges\": {         \"Friendship\": {             \"is_directed_edge\": False,             \"from_node_type\": \"Person\",             \"to_node_type\": \"Person\",             \"attributes\": {                 \"closeness\": \"DOUBLE\",             },         },     }, } In\u00a0[2]: Copied! <pre>connection = {\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n}\n</pre> connection = {     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", } In\u00a0[3]: Copied! <pre>G = Graph(graph_schema, connection)\n</pre> G = Graph(graph_schema, connection) <pre>2024-12-30 20:08:05,978 - tigergraphx.core.graph.base_graph - INFO - Creating schema...\n2024-12-30 20:08:09,834 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n2024-12-30 20:08:09,835 - tigergraphx.core.graph.base_graph - INFO - Installing queries...\n2024-12-30 20:09:08,310 - tigergraphx.core.graph.base_graph - INFO - Queries installed successfully.\n</pre> In\u00a0[4]: Copied! <pre>G.add_node(\"Alice\", \"Person\", age=25)\nG.add_node(\"Michael\", \"Person\", age=28)\nG.add_edge(\"Alice\", \"Michael\", closeness=0.98)\n</pre> G.add_node(\"Alice\", \"Person\", age=25) G.add_node(\"Michael\", \"Person\", age=28) G.add_edge(\"Alice\", \"Michael\", closeness=0.98) In\u00a0[5]: Copied! <pre>print(G.has_node(\"Alice\"))\n</pre> print(G.has_node(\"Alice\")) <pre>True\n</pre> In\u00a0[6]: Copied! <pre>print(G.has_node(\"Michael\"))\n</pre> print(G.has_node(\"Michael\")) <pre>True\n</pre> <p>Since the 'Friendship' edge is undirected, both 'Alice -&gt; Michael' and 'Michael -&gt; Alice' are valid and accessible.</p> In\u00a0[7]: Copied! <pre>print(G.has_edge(\"Alice\", \"Michael\"))\n</pre> print(G.has_edge(\"Alice\", \"Michael\")) <pre>True\n</pre> In\u00a0[8]: Copied! <pre>print(G.has_edge(\"Michael\", \"Alice\"))\n</pre> print(G.has_edge(\"Michael\", \"Alice\")) <pre>True\n</pre> In\u00a0[9]: Copied! <pre>print(G.get_node_data(\"Alice\"))\n</pre> print(G.get_node_data(\"Alice\")) <pre>{'name': 'Alice', 'age': 25}\n</pre> In\u00a0[10]: Copied! <pre>print(G.get_edge_data(\"Alice\", \"Michael\"))\n</pre> print(G.get_edge_data(\"Alice\", \"Michael\")) <pre>{'closeness': 0.98}\n</pre> In\u00a0[11]: Copied! <pre>print(G.nodes[\"Alice\"])\n</pre> print(G.nodes[\"Alice\"]) <pre>{'name': 'Alice', 'age': 25}\n</pre> In\u00a0[12]: Copied! <pre>print(G.nodes[\"Michael\"][\"age\"])\n</pre> print(G.nodes[\"Michael\"][\"age\"]) <pre>28\n</pre> <p>Note: The Edge View feature is planned for future releases.</p> In\u00a0[13]: Copied! <pre>print(G.degree(\"Alice\"))\n</pre> print(G.degree(\"Alice\")) <pre>1\n</pre> In\u00a0[14]: Copied! <pre>neighbors = G.get_neighbors(\"Alice\")\nprint(neighbors)\n</pre> neighbors = G.get_neighbors(\"Alice\") print(neighbors) <pre>      name  age\n0  Michael   28\n</pre> In\u00a0[15]: Copied! <pre>print(type(neighbors))\n</pre> print(type(neighbors)) <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\n</pre> In\u00a0[16]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>2\n</pre> In\u00a0[17]: Copied! <pre>print(G.number_of_edges())\n</pre> print(G.number_of_edges()) <pre>1\n</pre> In\u00a0[18]: Copied! <pre>print(G.clear())\n</pre> print(G.clear()) <pre>True\n</pre> <p>Afterwards, you can confirm that there are no nodes in the graph by checking:</p> In\u00a0[19]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>0\n</pre> In\u00a0[20]: Copied! <pre>G.drop_graph()\n</pre> G.drop_graph()"},{"location":"getting_started/quick_start/#quick-start-guide","title":"Quick Start Guide\u00b6","text":"<p>Follow this guide to quickly set up TigerGraphX and build your first graph. This guide assumes that you have already installed TigerGraphX and its dependencies as described in the Installation Guide.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from quick_start.ipynb.</p>"},{"location":"getting_started/quick_start/#create-a-graph","title":"Create a Graph\u00b6","text":""},{"location":"getting_started/quick_start/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we will create a graph named \"Social\" that includes one node type, \"Person,\" and one directed edge type, \"Friendship.\" Note that you must define the primary key for each node type, indicate whether an edge type is directed or undirected, and specify the source and target node types for each edge type.</p>"},{"location":"getting_started/quick_start/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p>"},{"location":"getting_started/quick_start/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"getting_started/quick_start/#nodes-and-edges","title":"Nodes and Edges\u00b6","text":""},{"location":"getting_started/quick_start/#add-nodes-and-edges","title":"Add Nodes and Edges\u00b6","text":"<p>Note: This example demonstrates how to easily add nodes and edges using the API. However, adding nodes and edges individually may not be efficient for large-scale operations. For better performance when loading data into TigerGraph, it is recommended to use a loading job. Nonetheless, these examples are ideal for quickly getting started.</p>"},{"location":"getting_started/quick_start/#check-if-nodes-and-edges-exist","title":"Check if Nodes and Edges Exist\u00b6","text":""},{"location":"getting_started/quick_start/#display-node-and-edge-attributes","title":"Display Node and Edge Attributes\u00b6","text":""},{"location":"getting_started/quick_start/#using-get_node_data-and-get_edge_data-functions","title":"Using <code>get_node_data</code> and <code>get_edge_data</code> Functions\u00b6","text":""},{"location":"getting_started/quick_start/#using-node-view","title":"Using Node View\u00b6","text":""},{"location":"getting_started/quick_start/#display-the-degree-of-nodes","title":"Display the Degree of Nodes\u00b6","text":""},{"location":"getting_started/quick_start/#retrieve-the-neighbors-of-a-node","title":"Retrieve the Neighbors of a Node\u00b6","text":""},{"location":"getting_started/quick_start/#graph-statistics","title":"Graph Statistics\u00b6","text":""},{"location":"getting_started/quick_start/#display-the-number-of-nodes","title":"Display the Number of Nodes\u00b6","text":""},{"location":"getting_started/quick_start/#display-the-number-of-edges","title":"Display the Number of Edges\u00b6","text":""},{"location":"getting_started/quick_start/#clear-and-drop-a-graph","title":"Clear and Drop a Graph\u00b6","text":""},{"location":"getting_started/quick_start/#clear-the-graph","title":"Clear the Graph\u00b6","text":"<p>To clear the data in the graph without dropping it, use the following code:</p>"},{"location":"getting_started/quick_start/#drop-the-graph","title":"Drop the Graph\u00b6","text":"<p>To clear the data and completely remove the graph\u2014including schema, loading jobs, and queries\u2014use the following code:</p>"},{"location":"getting_started/quick_start/#whats-next","title":"What\u2019s Next?\u00b6","text":"<p>Now that you\u2019ve set up your graph and performed basic operations, you can explore more advanced features of TigerGraphX:</p> <ul> <li>TigerVector Quick Start Guide: Quickly get started with TigerGraph for storing both graph data and vectors.</li> <li>GraphRAG Overview: Learn about integrating graphs with LLMs.</li> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/tigervector_quick_start/","title":"TigerVector Quick Start Guide","text":"In\u00a0[1]: Copied! <pre>graph_schema = {\n    \"graph_name\": \"FinancialGraph\",\n    \"nodes\": {\n        \"Account\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n                \"isBlocked\": \"BOOL\",\n            },\n            \"vector_attributes\": {\"emb1\": 3},\n        },\n        \"City\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n            },\n        },\n        \"Phone\": {\n            \"primary_key\": \"number\",\n            \"attributes\": {\n                \"number\": \"STRING\",\n                \"isBlocked\": \"BOOL\",\n            },\n            \"vector_attributes\": {\"emb1\": 3},\n        },\n    },\n    \"edges\": {\n        \"transfer\": {\n            \"is_directed_edge\": True,\n            \"from_node_type\": \"Account\",\n            \"to_node_type\": \"Account\",\n            \"edge_identifier\": \"date\",\n            \"attributes\": {\n                \"date\": \"DATETIME\",\n                \"amount\": \"INT\",\n            },\n        },\n        \"hasPhone\": {\n            \"is_directed_edge\": False,\n            \"from_node_type\": \"Account\",\n            \"to_node_type\": \"Phone\",\n        },\n        \"isLocatedIn\": {\n            \"is_directed_edge\": True,\n            \"from_node_type\": \"Account\",\n            \"to_node_type\": \"City\",\n        },\n    },\n}\n</pre> graph_schema = {     \"graph_name\": \"FinancialGraph\",     \"nodes\": {         \"Account\": {             \"primary_key\": \"name\",             \"attributes\": {                 \"name\": \"STRING\",                 \"isBlocked\": \"BOOL\",             },             \"vector_attributes\": {\"emb1\": 3},         },         \"City\": {             \"primary_key\": \"name\",             \"attributes\": {                 \"name\": \"STRING\",             },         },         \"Phone\": {             \"primary_key\": \"number\",             \"attributes\": {                 \"number\": \"STRING\",                 \"isBlocked\": \"BOOL\",             },             \"vector_attributes\": {\"emb1\": 3},         },     },     \"edges\": {         \"transfer\": {             \"is_directed_edge\": True,             \"from_node_type\": \"Account\",             \"to_node_type\": \"Account\",             \"edge_identifier\": \"date\",             \"attributes\": {                 \"date\": \"DATETIME\",                 \"amount\": \"INT\",             },         },         \"hasPhone\": {             \"is_directed_edge\": False,             \"from_node_type\": \"Account\",             \"to_node_type\": \"Phone\",         },         \"isLocatedIn\": {             \"is_directed_edge\": True,             \"from_node_type\": \"Account\",             \"to_node_type\": \"City\",         },     }, } In\u00a0[2]: Copied! <pre>connection = {\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n}\n</pre> connection = {     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", } In\u00a0[3]: Copied! <pre>from tigergraphx import Graph\nG = Graph(graph_schema, connection)\n</pre> from tigergraphx import Graph G = Graph(graph_schema, connection) <pre>2025-01-05 21:33:13,963 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph FinancialGraph...\n2025-01-05 21:33:14,001 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n</pre> In\u00a0[4]: Copied! <pre>nodes_for_adding = [\n    (\"Scott\", {\"isBlocked\": False}),\n    (\"Jenny\", {\"isBlocked\": False}),\n    (\"Steven\", {\"isBlocked\": True}),\n    (\"Paul\", {\"isBlocked\": False}),\n    (\"Ed\", {\"isBlocked\": False}),\n]\nprint(G.add_nodes_from(nodes_for_adding, node_type=\"Account\"))\nnodes_for_adding = [\n    (\"718-245-5888\", {\"isBlocked\": False}),\n    (\"650-658-9867\", {\"isBlocked\": True}),\n    (\"352-871-8978\", {\"isBlocked\": False}),\n]\nprint(G.add_nodes_from(nodes_for_adding, node_type=\"Phone\"))\nnodes_for_adding = [\"New York\", \"Gainesville\", \"San Francisco\"]\nprint(G.add_nodes_from(nodes_for_adding, node_type=\"City\"))\n</pre> nodes_for_adding = [     (\"Scott\", {\"isBlocked\": False}),     (\"Jenny\", {\"isBlocked\": False}),     (\"Steven\", {\"isBlocked\": True}),     (\"Paul\", {\"isBlocked\": False}),     (\"Ed\", {\"isBlocked\": False}), ] print(G.add_nodes_from(nodes_for_adding, node_type=\"Account\")) nodes_for_adding = [     (\"718-245-5888\", {\"isBlocked\": False}),     (\"650-658-9867\", {\"isBlocked\": True}),     (\"352-871-8978\", {\"isBlocked\": False}), ] print(G.add_nodes_from(nodes_for_adding, node_type=\"Phone\")) nodes_for_adding = [\"New York\", \"Gainesville\", \"San Francisco\"] print(G.add_nodes_from(nodes_for_adding, node_type=\"City\")) <pre>5\n3\n3\n</pre> In\u00a0[5]: Copied! <pre>ebunch_to_add = [\n    (\"Scott\", \"718-245-5888\"),\n    (\"Jenny\", \"718-245-5888\"),\n    (\"Jenny\", \"650-658-9867\"),\n    (\"Paul\", \"650-658-9867\"),\n    (\"Ed\", \"352-871-8978\"),\n]\nprint(G.add_edges_from(ebunch_to_add, \"Account\", \"hasPhone\", \"Phone\"))\nebunch_to_add = [\n    (\"Scott\", \"New York\"),\n    (\"Jenny\", \"San Francisco\"),\n    (\"Steven\", \"San Francisco\"),\n    (\"Paul\", \"Gainesville\"),\n    (\"Ed\", \"Gainesville\"),\n]\nprint(G.add_edges_from(ebunch_to_add, \"Account\", \"isLocatedIn\", \"City\"))\nebunch_to_add = [\n    (\"Scott\", \"Ed\", {\"date\": \"2024-01-04\", \"amount\": 20000}),\n    (\"Scott\", \"Ed\", {\"date\": \"2024-02-01\", \"amount\": 800}),\n    (\"Scott\", \"Ed\", {\"date\": \"2024-02-14\", \"amount\": 500}),\n    (\"Jenny\", \"Scott\", {\"date\": \"2024-04-04\", \"amount\": 1000}),\n    (\"Paul\", \"Jenny\", {\"date\": \"2024-02-01\", \"amount\": 653}),\n    (\"Steven\", \"Jenny\", {\"date\": \"2024-05-01\", \"amount\": 8560}),\n    (\"Ed\", \"Paul\", {\"date\": \"2024-01-04\", \"amount\": 1500}),\n    (\"Paul\", \"Steven\", {\"date\": \"2023-05-09\", \"amount\": 20000}),\n]\nprint(G.add_edges_from(ebunch_to_add, \"Account\", \"transfer\", \"Account\"))\n</pre> ebunch_to_add = [     (\"Scott\", \"718-245-5888\"),     (\"Jenny\", \"718-245-5888\"),     (\"Jenny\", \"650-658-9867\"),     (\"Paul\", \"650-658-9867\"),     (\"Ed\", \"352-871-8978\"), ] print(G.add_edges_from(ebunch_to_add, \"Account\", \"hasPhone\", \"Phone\")) ebunch_to_add = [     (\"Scott\", \"New York\"),     (\"Jenny\", \"San Francisco\"),     (\"Steven\", \"San Francisco\"),     (\"Paul\", \"Gainesville\"),     (\"Ed\", \"Gainesville\"), ] print(G.add_edges_from(ebunch_to_add, \"Account\", \"isLocatedIn\", \"City\")) ebunch_to_add = [     (\"Scott\", \"Ed\", {\"date\": \"2024-01-04\", \"amount\": 20000}),     (\"Scott\", \"Ed\", {\"date\": \"2024-02-01\", \"amount\": 800}),     (\"Scott\", \"Ed\", {\"date\": \"2024-02-14\", \"amount\": 500}),     (\"Jenny\", \"Scott\", {\"date\": \"2024-04-04\", \"amount\": 1000}),     (\"Paul\", \"Jenny\", {\"date\": \"2024-02-01\", \"amount\": 653}),     (\"Steven\", \"Jenny\", {\"date\": \"2024-05-01\", \"amount\": 8560}),     (\"Ed\", \"Paul\", {\"date\": \"2024-01-04\", \"amount\": 1500}),     (\"Paul\", \"Steven\", {\"date\": \"2023-05-09\", \"amount\": 20000}), ] print(G.add_edges_from(ebunch_to_add, \"Account\", \"transfer\", \"Account\")) <pre>5\n5\n8\n</pre> In\u00a0[6]: Copied! <pre>data = [\n    {\n        \"name\": \"Scott\",\n        \"emb1\": [-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n    },\n    {\n        \"name\": \"Jenny\",\n        \"emb1\": [-0.019265105947852135, 0.0004929182468913496, 0.006711316294968128],\n    },\n    {\n        \"name\": \"Steven\",\n        \"emb1\": [-0.01505514420568943, -0.016819344833493233, -0.0221870020031929],\n    },\n    {\n        \"name\": \"Paul\",\n        \"emb1\": [0.0011193430982530117, -0.001038988004438579, -0.017158523201942444],\n    },\n    {\n        \"name\": \"Ed\",\n        \"emb1\": [-0.003692442551255226, 0.010494389571249485, -0.004631792660802603],\n    },\n]\nprint(G.upsert(data, \"Account\"))\n</pre> data = [     {         \"name\": \"Scott\",         \"emb1\": [-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],     },     {         \"name\": \"Jenny\",         \"emb1\": [-0.019265105947852135, 0.0004929182468913496, 0.006711316294968128],     },     {         \"name\": \"Steven\",         \"emb1\": [-0.01505514420568943, -0.016819344833493233, -0.0221870020031929],     },     {         \"name\": \"Paul\",         \"emb1\": [0.0011193430982530117, -0.001038988004438579, -0.017158523201942444],     },     {         \"name\": \"Ed\",         \"emb1\": [-0.003692442551255226, 0.010494389571249485, -0.004631792660802603],     }, ] print(G.upsert(data, \"Account\")) <pre>0\n</pre> <p>Note: A result of 0 simply indicates that no new nodes were added, as the nodes were already inserted into TigerGraph. This does not mean the update failed. In the next step, we'll perform a vector search to verify that the data has been updated successfully.</p> In\u00a0[7]: Copied! <pre>data = [-0.017733968794345856, -0.01019224338233471, -0.016571875661611557]\nprint(G.search(data, \"emb1\", \"Account\", 2))\n</pre> data = [-0.017733968794345856, -0.01019224338233471, -0.016571875661611557] print(G.search(data, \"emb1\", \"Account\", 2)) <pre>[{'id': 'Scott', 'distance': 0, 'name': 'Scott', 'isBlocked': False}, {'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}]\n</pre> In\u00a0[8]: Copied! <pre>print(G.clear())\n</pre> print(G.clear()) <pre>True\n</pre> <p>Afterwards, you can confirm that there are no nodes in the graph by checking:</p> In\u00a0[9]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>0\n</pre> In\u00a0[10]: Copied! <pre>G.drop_graph()\n</pre> G.drop_graph()"},{"location":"getting_started/tigervector_quick_start/#tigervector-quick-start-guide","title":"TigerVector Quick Start Guide\u00b6","text":"<p>Follow this guide to quickly get started with TigerGraph for storing both graph data and vectors. This guide assumes that you have already installed TigerGraphX and its dependencies, as outlined in the Installation Guide.</p> <p>To run this Jupyter Notebook, download the original <code>.ipynb</code> file from tigervector_quick_start.ipynb.</p> <p>In this quick start guide, we will work with the following graph:</p> <p></p>"},{"location":"getting_started/tigervector_quick_start/#create-a-graph","title":"Create a Graph\u00b6","text":""},{"location":"getting_started/tigervector_quick_start/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we create a graph called \"FinancialGraph\" with three node types: \"Account,\" \"City,\" and \"Phone,\" and three edge types: \"transfer,\" \"hasPhone,\" and \"isLocatedIn.\"</p> <ul> <li><p>Nodes:</p> <ul> <li>Account: Primary key <code>name</code>, attributes <code>name</code> (string) and <code>isBlocked</code> (boolean), vector attribute <code>emb1</code> (3).</li> <li>City: Primary key <code>name</code>, attribute <code>name</code> (string).</li> <li>Phone: Primary key <code>number</code>, attributes <code>number</code> (string) and <code>isBlocked</code> (boolean), vector attribute <code>emb1</code> (3).</li> </ul> </li> <li><p>Edges:</p> <ul> <li>transfer: Directed multi-edge between \"Account\" nodes, identified by <code>date</code> (datetime) as the unique identifier for each edge between a pair of source and target nodes. The edge has an attribute <code>amount</code> (integer).</li> <li>hasPhone: Undirected edge between \"Account\" and \"Phone\" nodes.</li> <li>isLocatedIn: Directed edge between \"Account\" and \"City\" nodes.</li> </ul> </li> </ul> <p>This schema defines the structure of the \"FinancialGraph\" with nodes and edges and their respective attributes.</p>"},{"location":"getting_started/tigervector_quick_start/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p>"},{"location":"getting_started/tigervector_quick_start/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"getting_started/tigervector_quick_start/#add-add-nodes-and-edges","title":"Add Add Nodes and Edges\u00b6","text":"<p>Note: This example demonstrates how to easily add nodes and edges using the API. However, adding nodes and edges individually may not be efficient for large-scale operations. For better performance when loading data into TigerGraph, it is recommended to use a loading job. Nonetheless, these examples are ideal for quickly getting started.</p>"},{"location":"getting_started/tigervector_quick_start/#add-nodes","title":"Add Nodes\u00b6","text":""},{"location":"getting_started/tigervector_quick_start/#add-edges","title":"Add Edges\u00b6","text":""},{"location":"getting_started/tigervector_quick_start/#inserting-embeddings-into-nodes","title":"Inserting Embeddings into Nodes\u00b6","text":"<p>To insert embeddings into the nodes, you can use the following data format:</p>"},{"location":"getting_started/tigervector_quick_start/#perform-vector-search","title":"Perform Vector Search\u00b6","text":"<p>To find the top 2 most similar accounts to \"Scott\" based on the embedding, we use the following code. As expected, \"Scott\" will appear in the list with a distance of 0.</p>"},{"location":"getting_started/tigervector_quick_start/#clear-and-drop-a-graph","title":"Clear and Drop a Graph\u00b6","text":""},{"location":"getting_started/tigervector_quick_start/#clear-the-graph","title":"Clear the Graph\u00b6","text":"<p>To clear the data in the graph without dropping it, use the following code:</p>"},{"location":"getting_started/tigervector_quick_start/#drop-the-graph","title":"Drop the Graph\u00b6","text":"<p>To clear the data and completely remove the graph\u2014including schema, loading jobs, and queries\u2014use the following code:</p>"},{"location":"getting_started/tigervector_quick_start/#whats-next","title":"What\u2019s Next?\u00b6","text":"<p>Now that you've learned how to use TigerGraph for storing both graph data and vectors, you can dive into more advanced features of TigerGraphX:</p> <ul> <li>GraphRAG Overview: Learn about integrating graphs with LLMs.</li> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"graphrag/graphrag_overview/","title":"TigerGraph: Unlocking the Potential of GraphRAG","text":""},{"location":"graphrag/graphrag_overview/#overview","title":"Overview","text":"<p>TigerGraph is a highly scalable and efficient graph database, making it the ideal foundation for advanced GraphRAG workflows. It excels in handling both graph and vector data, enabling seamless integration and performance at scale. With built-in support for complex queries, multi-hop traversals, and real-time analytics, TigerGraph ensures fast and reliable results. Its versatility and performance make it the ideal choice for powering data-intensive workflows, while TigerGraphX simplifies access with a Python-native interface.</p> <p></p>"},{"location":"graphrag/graphrag_overview/#why-tigergraph-for-graphrag","title":"Why TigerGraph for GraphRAG?","text":""},{"location":"graphrag/graphrag_overview/#1-scalability-and-performance","title":"1. Scalability and Performance","text":"<p>TigerGraph excels in handling massive datasets with high-speed multi-hop queries and vector search capabilities. It is ideal for real-world GraphRAG applications that demand extensive and efficient data processing.</p>"},{"location":"graphrag/graphrag_overview/#2-unified-graph-and-vector-data-support","title":"2. Unified Graph and Vector Data Support","text":"<p>With native support for schema-defined nodes, edges, and vectors, TigerGraph streamlines data integration. Its advanced query optimization enables efficient graph traversal and vector-based retrieval, which is perfectly suited for LLM workflows.</p>"},{"location":"graphrag/graphrag_overview/#3-cost-effectiveness","title":"3. Cost-Effectiveness","text":"<p>TigerGraph reduces computational overhead through optimized queries and highly efficient storage, significantly cutting infrastructure costs while maintaining top-tier performance.</p>"},{"location":"graphrag/graphrag_overview/#4-flexibility-and-hybrid-integration","title":"4. Flexibility and Hybrid Integration","text":"<p>Seamlessly combines structured, semantic, and vector-based retrieval methods in one unified platform. Its compatibility with vector search and LLMs enables advanced hybrid retrieval strategies, unlocking new possibilities for GraphRAG workflows.</p>"},{"location":"graphrag/graphrag_overview/#graphrag-workflow-with-tigergraph","title":"GraphRAG Workflow with TigerGraph","text":""},{"location":"graphrag/graphrag_overview/#1-schema-design","title":"1. Schema Design","text":"<p>Define the graph schema with nodes, edges, and attributes tailored to your application, leveraging TigerGraph\u2019s native support for structured graph data.</p>"},{"location":"graphrag/graphrag_overview/#2-data-preparation-and-loading","title":"2. Data Preparation and Loading","text":"<p>Transform raw data into TigerGraph-compatible formats, including graph structures and embeddings, and load it efficiently into TigerGraph using TigerGraphX.</p>"},{"location":"graphrag/graphrag_overview/#3-knowledge-graph-management-and-analysis","title":"3. Knowledge Graph Management and Analysis","text":"<p>Maintain and enhance the knowledge graph to ensure data quality, relevance, and scalability. Perform in-depth analysis to uncover patterns, infer insights, and optimize data retrieval strategies; ensure the knowledge graph remains a dynamic, accurate, and actionable source of information, enriching context for LLMs while supporting explainability and scalability in the GraphRAG workflow.</p>"},{"location":"graphrag/graphrag_overview/#4-hybrid-retrieval","title":"4. Hybrid Retrieval","text":"<p>Combine structured queries, semantic search, and vector-based methods to fetch relevant data and embeddings from TigerGraph for context construction.</p>"},{"location":"graphrag/graphrag_overview/#5-context-building","title":"5. Context Building","text":"<p>Use TigerGraphX to process retrieved data, making it token-aware and formatted to meet the requirements of LLMs.</p>"},{"location":"graphrag/graphrag_overview/#6-llm-integration","title":"6. LLM Integration","text":"<p>Pass the context to an LLM to generate responses, enabling advanced GraphRAG workflows with seamless data flow and high efficiency.</p>"},{"location":"graphrag/graphrag_overview/#two-options-for-implementing-graphrag-with-tigergraph","title":"Two Options for Implementing GraphRAG with TigerGraph","text":"<p>There are two approaches to implementing GraphRAG with TigerGraph.</p>"},{"location":"graphrag/graphrag_overview/#1-tigergraph-as-a-storage-and-retrieval-engine","title":"1. TigerGraph as a Storage and Retrieval Engine","text":"<p>The first approach primarily utilizes TigerGraph for storing and retrieving graph/vector data. TigerGraphX provides interfaces similar to NetworkX, allowing seamless integration with GraphRAG applications. This approach is recommended for GraphRAG solutions like LightRAG and Nano-GraphRAG, which abstract their storage layers (e.g., graph storage, key-value storage, and vector storage). Here, you only need to implement these layers in a way that aligns with TigerGraph.</p>"},{"location":"graphrag/graphrag_overview/#2-tigergraph-for-storage-and-retrieval-tigergraphx-for-llm-tasks","title":"2. TigerGraph for Storage and Retrieval; TigerGraphX for LLM Tasks","text":"<p>The second approach extends beyond storage and retrieval by leveraging TigerGraphX for tasks related to large language models (LLMs), such as chat or embedding generation. This approach is suitable for complex projects like Microsoft's GraphRAG. As of December 2024, Microsoft's GraphRAG has not yet abstracted its storage layer, making it challenging to replace the indexing process. However, TigerGraphX can be used to convert the results of the indexing process (e.g., Parquet files) into a format supported by TigerGraph. These results can then be imported into TigerGraph, and TigerGraphX can handle the querying process without relying on Microsoft\u2019s GraphRAG.</p>"},{"location":"graphrag/graphrag_overview/#demonstrations","title":"Demonstrations","text":"<p>Both methods are demonstrated on the following pages, each with a real-world project:</p> <ul> <li>LightRAG: Refer to LightRAG for the first approach.</li> <li>Microsoft's GraphRAG: Refer to Microsoft GraphRAG: Part 1 for the second approach.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/lightrag/","title":"Supporting LightRAG","text":"<p>LightRAG is an open-source RAG system that enhances LLMs by integrating graph-based structures into text indexing and retrieval. It overcomes the limitations of traditional RAG systems, such as fragmented answers and weak contextual awareness, by enabling dual-level retrieval for more comprehensive knowledge discovery. With support for incremental data updates, LightRAG ensures timely integration of new information while delivering improved retrieval accuracy and efficiency.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from lightrag.ipynb.</p> In\u00a0[1]: Copied! <pre>import os\nfrom dataclasses import dataclass\nfrom typing import Any, Dict\nimport numpy as np\n\nfrom lightrag.base import BaseGraphStorage\nfrom lightrag.utils import logger\n\nfrom tigergraphx import Graph\n\n\n@dataclass\nclass TigerGraphStorage(BaseGraphStorage):\n    def __post_init__(self):\n        try:\n            # Define the graph schema\n            graph_schema = {\n                \"graph_name\": \"LightRAG\",\n                \"nodes\": {\n                    \"Entity\": {\n                        \"primary_key\": \"id\",\n                        \"attributes\": {\n                            \"id\": \"STRING\",\n                            \"entity_type\": \"STRING\",\n                            \"description\": \"STRING\",\n                            \"source_id\": \"STRING\",\n                        },\n                    }\n                },\n                \"edges\": {\n                    \"relationship\": {\n                        \"is_directed_edge\": False,\n                        \"from_node_type\": \"Entity\",\n                        \"to_node_type\": \"Entity\",\n                        \"attributes\": {\n                            \"weight\": \"DOUBLE\",\n                            \"description\": \"STRING\",\n                            \"keywords\": \"STRING\",\n                            \"source_id\": \"STRING\",\n                        },\n                    }\n                },\n            }\n\n            # Retrieve connection configuration from environment variables\n            connection_config = {\n                \"host\": os.environ.get(\"TG_HOST\", \"http://127.0.0.1\"),\n                \"restpp_port\": os.environ.get(\"TG_RESTPP_PORT\", \"14240\"),\n                \"gsql_port\": os.environ.get(\"TG_GSQL_PORT\", \"14240\"),\n                # Option 1: User/password authentication\n                \"username\": os.environ.get(\"TG_USERNAME\"),\n                \"password\": os.environ.get(\"TG_PASSWORD\"),\n                # Option 2: Secret-based authentication\n                \"secret\": os.environ.get(\"TG_SECRET\"),\n                # Option 3: Token-based authentication\n                \"token\": os.environ.get(\"TG_TOKEN\"),\n            }\n\n            # Initialize the graph\n            self._graph = Graph(graph_schema, connection_config)\n        except Exception as e:\n            logger.error(f\"An error occurred during initialization: {e}\")\n            raise\n\n    @staticmethod\n    def clean_quotes(value: str) -&gt; str:\n        \"\"\"Remove leading and trailing &amp;quot; from a string if present.\"\"\"\n        if value.startswith('\"') and value.endswith('\"'):\n            return value[1:-1]\n        return value\n\n    async def has_node(self, node_id: str) -&gt; bool:\n        return self._graph.has_node(self.clean_quotes(node_id))\n\n    async def has_edge(self, source_node_id: str, target_node_id: str) -&gt; bool:\n        return self._graph.has_edge(\n            self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)\n        )\n\n    async def node_degree(self, node_id: str) -&gt; int:\n        result = self._graph.degree(self.clean_quotes(node_id))\n        return result\n\n    async def edge_degree(self, src_id: str, tgt_id: str) -&gt; int:\n        return self._graph.degree(self.clean_quotes(src_id)) + self._graph.degree(\n            self.clean_quotes(tgt_id)\n        )\n\n    async def get_node(self, node_id: str) -&gt; dict | None:\n        result = self._graph.get_node_data(self.clean_quotes(node_id))\n        return result\n\n    async def get_edge(self, source_node_id: str, target_node_id: str) -&gt; dict | None:\n        result = self._graph.get_edge_data(\n            self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)\n        )\n        return result\n\n    async def get_node_edges(self, source_node_id: str) -&gt; list[tuple[str, str]] | None:\n        source_node_id = self.clean_quotes(source_node_id)\n        if self._graph.has_node(source_node_id):\n            edges = self._graph.get_node_edges(source_node_id)\n            return list(edges)\n        return None\n\n    async def upsert_node(self, node_id: str, node_data: Dict[str, Any]):\n        node_id = self.clean_quotes(node_id)\n        self._graph.add_node(node_id, **node_data)\n\n    async def upsert_edge(\n        self, source_node_id: str, target_node_id: str, edge_data: Dict[str, Any]\n    ):\n        source_node_id = self.clean_quotes(source_node_id)\n        target_node_id = self.clean_quotes(target_node_id)\n        self._graph.add_edge(source_node_id, target_node_id, **edge_data)\n\n    async def delete_node(self, node_id: str):\n        if self._graph.has_node(node_id):\n            self._graph.remove_node(node_id)\n            logger.info(f\"Node {node_id} deleted from the graph.\")\n        else:\n            logger.warning(f\"Node {node_id} not found in the graph for deletion.\")\n\n    async def embed_nodes(self, algorithm: str) -&gt; tuple[np.ndarray, list[str]]:\n        return np.array([]), []\n\n    def drop_graph(self) -&gt; None:\n        self._graph.drop_graph()\n</pre> import os from dataclasses import dataclass from typing import Any, Dict import numpy as np  from lightrag.base import BaseGraphStorage from lightrag.utils import logger  from tigergraphx import Graph   @dataclass class TigerGraphStorage(BaseGraphStorage):     def __post_init__(self):         try:             # Define the graph schema             graph_schema = {                 \"graph_name\": \"LightRAG\",                 \"nodes\": {                     \"Entity\": {                         \"primary_key\": \"id\",                         \"attributes\": {                             \"id\": \"STRING\",                             \"entity_type\": \"STRING\",                             \"description\": \"STRING\",                             \"source_id\": \"STRING\",                         },                     }                 },                 \"edges\": {                     \"relationship\": {                         \"is_directed_edge\": False,                         \"from_node_type\": \"Entity\",                         \"to_node_type\": \"Entity\",                         \"attributes\": {                             \"weight\": \"DOUBLE\",                             \"description\": \"STRING\",                             \"keywords\": \"STRING\",                             \"source_id\": \"STRING\",                         },                     }                 },             }              # Retrieve connection configuration from environment variables             connection_config = {                 \"host\": os.environ.get(\"TG_HOST\", \"http://127.0.0.1\"),                 \"restpp_port\": os.environ.get(\"TG_RESTPP_PORT\", \"14240\"),                 \"gsql_port\": os.environ.get(\"TG_GSQL_PORT\", \"14240\"),                 # Option 1: User/password authentication                 \"username\": os.environ.get(\"TG_USERNAME\"),                 \"password\": os.environ.get(\"TG_PASSWORD\"),                 # Option 2: Secret-based authentication                 \"secret\": os.environ.get(\"TG_SECRET\"),                 # Option 3: Token-based authentication                 \"token\": os.environ.get(\"TG_TOKEN\"),             }              # Initialize the graph             self._graph = Graph(graph_schema, connection_config)         except Exception as e:             logger.error(f\"An error occurred during initialization: {e}\")             raise      @staticmethod     def clean_quotes(value: str) -&gt; str:         \"\"\"Remove leading and trailing \" from a string if present.\"\"\"         if value.startswith('\"') and value.endswith('\"'):             return value[1:-1]         return value      async def has_node(self, node_id: str) -&gt; bool:         return self._graph.has_node(self.clean_quotes(node_id))      async def has_edge(self, source_node_id: str, target_node_id: str) -&gt; bool:         return self._graph.has_edge(             self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)         )      async def node_degree(self, node_id: str) -&gt; int:         result = self._graph.degree(self.clean_quotes(node_id))         return result      async def edge_degree(self, src_id: str, tgt_id: str) -&gt; int:         return self._graph.degree(self.clean_quotes(src_id)) + self._graph.degree(             self.clean_quotes(tgt_id)         )      async def get_node(self, node_id: str) -&gt; dict | None:         result = self._graph.get_node_data(self.clean_quotes(node_id))         return result      async def get_edge(self, source_node_id: str, target_node_id: str) -&gt; dict | None:         result = self._graph.get_edge_data(             self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)         )         return result      async def get_node_edges(self, source_node_id: str) -&gt; list[tuple[str, str]] | None:         source_node_id = self.clean_quotes(source_node_id)         if self._graph.has_node(source_node_id):             edges = self._graph.get_node_edges(source_node_id)             return list(edges)         return None      async def upsert_node(self, node_id: str, node_data: Dict[str, Any]):         node_id = self.clean_quotes(node_id)         self._graph.add_node(node_id, **node_data)      async def upsert_edge(         self, source_node_id: str, target_node_id: str, edge_data: Dict[str, Any]     ):         source_node_id = self.clean_quotes(source_node_id)         target_node_id = self.clean_quotes(target_node_id)         self._graph.add_edge(source_node_id, target_node_id, **edge_data)      async def delete_node(self, node_id: str):         if self._graph.has_node(node_id):             self._graph.remove_node(node_id)             logger.info(f\"Node {node_id} deleted from the graph.\")         else:             logger.warning(f\"Node {node_id} not found in the graph for deletion.\")      async def embed_nodes(self, algorithm: str) -&gt; tuple[np.ndarray, list[str]]:         return np.array([]), []      def drop_graph(self) -&gt; None:         self._graph.drop_graph() <p>This code defines the <code>TigerGraphStorage</code> class, which interacts with TigerGraphX to manage graph data in TigerGraph.</p> In\u00a0[2]: Copied! <pre>import os\nfrom dataclasses import dataclass\nimport numpy as np\nfrom tqdm.asyncio import tqdm as tqdm_async\nimport asyncio\n\nfrom lightrag.base import BaseVectorStorage\nfrom lightrag.utils import logger\n\nfrom tigergraphx import Graph\n\n\n@dataclass\nclass TigerVectorStorage(BaseVectorStorage):\n    def __post_init__(self):\n        try:\n            # Define the graph schema\n            graph_schema = {\n                \"graph_name\": f\"Vector_{self.namespace}\",\n                \"nodes\": {\n                    \"Table\": {\n                        \"primary_key\": \"id\",\n                        \"attributes\": {\n                            \"id\": \"STRING\",\n                            **{field: \"STRING\" for field in self.meta_fields},\n                        },\n                        \"vector_attributes\": {\n                            \"vector_attribute\": self.embedding_func.embedding_dim,\n                        },\n                    }\n                },\n                \"edges\": {},\n            }\n\n            # Retrieve connection configuration from environment variables\n            connection_config = {\n                \"host\": os.environ.get(\"TG_HOST\", \"http://127.0.0.1\"),\n                \"restpp_port\": os.environ.get(\"TG_RESTPP_PORT\", \"14240\"),\n                \"gsql_port\": os.environ.get(\"TG_GSQL_PORT\", \"14240\"),\n                # Option 1: User/password authentication\n                \"username\": os.environ.get(\"TG_USERNAME\"),\n                \"password\": os.environ.get(\"TG_PASSWORD\"),\n                # Option 2: Secret-based authentication\n                \"secret\": os.environ.get(\"TG_SECRET\"),\n                # Option 3: Token-based authentication\n                \"token\": os.environ.get(\"TG_TOKEN\"),\n            }\n\n            # Initialize the graph\n            self._graph = Graph(graph_schema, connection_config)\n            self._max_batch_size = self.global_config[\"embedding_batch_num\"]\n        except Exception as e:\n            logger.error(f\"An error occurred during initialization: {e}\")\n            raise\n\n    async def upsert(self, data: dict[str, dict]):\n        \"\"\"\n        Insert or update data in the TigerGraph vector storage.\n        \"\"\"\n        logger.info(f\"Inserting {len(data)} vectors to {self.namespace}\")\n        if not len(data):\n            logger.warning(\"No data to insert into the vector DB.\")\n            return []\n\n        # Preparing the data for insertion\n        list_data = [\n            {\n                \"id\": k,\n                **{k1: v1 for k1, v1 in v.items() if k1 in self.meta_fields},\n            }\n            for k, v in data.items()\n        ]\n\n        contents = [v[\"content\"] for v in data.values()]\n\n        # Batch the data for embedding\n        batches = [\n            contents[i : i + self._max_batch_size]\n            for i in range(0, len(contents), self._max_batch_size)\n        ]\n\n        async def wrapped_task(batch):\n            result = await self.embedding_func(batch)\n            pbar.update(1)\n            return result\n\n        embedding_tasks = [wrapped_task(batch) for batch in batches]\n        pbar = tqdm_async(\n            total=len(embedding_tasks), desc=\"Generating embeddings\", unit=\"batch\"\n        )\n        embeddings_list = await asyncio.gather(*embedding_tasks)\n\n        embeddings = np.concatenate(embeddings_list)\n        if len(embeddings) == len(list_data):\n            for i, d in enumerate(list_data):\n                d[\"vector_attribute\"] = embeddings[i].tolist()\n            results = self._graph.upsert(data=list_data, node_type=\"Table\")\n            return results\n        else:\n            # sometimes the embedding is not returned correctly. just log it.\n            logger.error(\n                f\"embedding is not 1-1 with data, {len(embeddings)} != {len(list_data)}\"\n            )\n\n    async def query(self, query: str, top_k=5):\n        \"\"\"\n        Perform a vector search to find the most similar nodes based on the query vector.\n        \"\"\"\n        embedding = await self.embedding_func([query])\n        embedding = embedding[0]\n        results = self._graph.search(\n            data=embedding,\n            vector_attribute_name=\"vector_attribute\",\n            node_type=\"Table\",  # Specify the node type\n            limit=top_k,  # Retrieve the top_k closest nodes\n        )\n        return results\n</pre> import os from dataclasses import dataclass import numpy as np from tqdm.asyncio import tqdm as tqdm_async import asyncio  from lightrag.base import BaseVectorStorage from lightrag.utils import logger  from tigergraphx import Graph   @dataclass class TigerVectorStorage(BaseVectorStorage):     def __post_init__(self):         try:             # Define the graph schema             graph_schema = {                 \"graph_name\": f\"Vector_{self.namespace}\",                 \"nodes\": {                     \"Table\": {                         \"primary_key\": \"id\",                         \"attributes\": {                             \"id\": \"STRING\",                             **{field: \"STRING\" for field in self.meta_fields},                         },                         \"vector_attributes\": {                             \"vector_attribute\": self.embedding_func.embedding_dim,                         },                     }                 },                 \"edges\": {},             }              # Retrieve connection configuration from environment variables             connection_config = {                 \"host\": os.environ.get(\"TG_HOST\", \"http://127.0.0.1\"),                 \"restpp_port\": os.environ.get(\"TG_RESTPP_PORT\", \"14240\"),                 \"gsql_port\": os.environ.get(\"TG_GSQL_PORT\", \"14240\"),                 # Option 1: User/password authentication                 \"username\": os.environ.get(\"TG_USERNAME\"),                 \"password\": os.environ.get(\"TG_PASSWORD\"),                 # Option 2: Secret-based authentication                 \"secret\": os.environ.get(\"TG_SECRET\"),                 # Option 3: Token-based authentication                 \"token\": os.environ.get(\"TG_TOKEN\"),             }              # Initialize the graph             self._graph = Graph(graph_schema, connection_config)             self._max_batch_size = self.global_config[\"embedding_batch_num\"]         except Exception as e:             logger.error(f\"An error occurred during initialization: {e}\")             raise      async def upsert(self, data: dict[str, dict]):         \"\"\"         Insert or update data in the TigerGraph vector storage.         \"\"\"         logger.info(f\"Inserting {len(data)} vectors to {self.namespace}\")         if not len(data):             logger.warning(\"No data to insert into the vector DB.\")             return []          # Preparing the data for insertion         list_data = [             {                 \"id\": k,                 **{k1: v1 for k1, v1 in v.items() if k1 in self.meta_fields},             }             for k, v in data.items()         ]          contents = [v[\"content\"] for v in data.values()]          # Batch the data for embedding         batches = [             contents[i : i + self._max_batch_size]             for i in range(0, len(contents), self._max_batch_size)         ]          async def wrapped_task(batch):             result = await self.embedding_func(batch)             pbar.update(1)             return result          embedding_tasks = [wrapped_task(batch) for batch in batches]         pbar = tqdm_async(             total=len(embedding_tasks), desc=\"Generating embeddings\", unit=\"batch\"         )         embeddings_list = await asyncio.gather(*embedding_tasks)          embeddings = np.concatenate(embeddings_list)         if len(embeddings) == len(list_data):             for i, d in enumerate(list_data):                 d[\"vector_attribute\"] = embeddings[i].tolist()             results = self._graph.upsert(data=list_data, node_type=\"Table\")             return results         else:             # sometimes the embedding is not returned correctly. just log it.             logger.error(                 f\"embedding is not 1-1 with data, {len(embeddings)} != {len(list_data)}\"             )      async def query(self, query: str, top_k=5):         \"\"\"         Perform a vector search to find the most similar nodes based on the query vector.         \"\"\"         embedding = await self.embedding_func([query])         embedding = embedding[0]         results = self._graph.search(             data=embedding,             vector_attribute_name=\"vector_attribute\",             node_type=\"Table\",  # Specify the node type             limit=top_k,  # Retrieve the top_k closest nodes         )         return results <p>This code defines the <code>TigerVectorStorage</code> class, which is used for storing and querying vector data (like embeddings) in a TigerGraph database using TigerGraphX.</p> In\u00a0[3]: Copied! <pre>from lightrag import LightRAG\n\n\n# Define a subclass to include your custom graph storage in the storage mapping\nclass CustomLightRAG(LightRAG):\n    def _get_storage_class(self):\n        # Extend the default storage mapping with your custom storage\n        base_mapping = super()._get_storage_class()\n        base_mapping[\"TigerGraphStorage\"] = TigerGraphStorage\n        base_mapping[\"TigerVectorStorage\"] = TigerVectorStorage\n        return base_mapping\n</pre> from lightrag import LightRAG   # Define a subclass to include your custom graph storage in the storage mapping class CustomLightRAG(LightRAG):     def _get_storage_class(self):         # Extend the default storage mapping with your custom storage         base_mapping = super()._get_storage_class()         base_mapping[\"TigerGraphStorage\"] = TigerGraphStorage         base_mapping[\"TigerVectorStorage\"] = TigerVectorStorage         return base_mapping In\u00a0[\u00a0]: Copied! <pre>import logging\nimport nest_asyncio\n# Use the nest_asyncio package to allow running nested event loops in Jupyter Notebook without conflicts.\nnest_asyncio.apply()\n\n\nworking_dir = \"../../applications/lightrag/data\"\n\ncustom_rag = CustomLightRAG(\n    working_dir=working_dir,\n    graph_storage=\"TigerGraphStorage\",\n    # Use TigerGraph for storing vectors.\n    # To switch to the default vector database in LightRAG, comment out the line below.\n    vector_storage=\"TigerVectorStorage\",\n)\n\nwith open(working_dir + \"/input/book.txt\") as f:\n    custom_rag.insert(f.read())\n</pre> import logging import nest_asyncio # Use the nest_asyncio package to allow running nested event loops in Jupyter Notebook without conflicts. nest_asyncio.apply()   working_dir = \"../../applications/lightrag/data\"  custom_rag = CustomLightRAG(     working_dir=working_dir,     graph_storage=\"TigerGraphStorage\",     # Use TigerGraph for storing vectors.     # To switch to the default vector database in LightRAG, comment out the line below.     vector_storage=\"TigerVectorStorage\", )  with open(working_dir + \"/input/book.txt\") as f:     custom_rag.insert(f.read()) <p>Please note that the output has been cleared here due to its length, as most of the content consists of logs.</p> <p>Additionally, TigerVector is supported only in TigerGraph version 4.2.0 and later. If you're using a version prior to 4.2.0, you can comment out the line <code>vector_storage=\"TigerVectorStorage\",</code> to use the default vector database in LightRAG.</p> In\u00a0[5]: Copied! <pre>from lightrag import QueryParam\n\nquery = \"What are the top themes in this story?\"\n\nresult = custom_rag.query(query=query, param=QueryParam(mode=\"hybrid\"))\n\nprint(\"------------------- Query Result:  -------------------\")\nprint(result)\n</pre> from lightrag import QueryParam  query = \"What are the top themes in this story?\"  result = custom_rag.query(query=query, param=QueryParam(mode=\"hybrid\"))  print(\"------------------- Query Result:  -------------------\") print(result) <pre>2025-01-03 20:14:18,951 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-01-03 20:14:18,956 - lightrag - INFO - kw_prompt result:\n{\n  \"high_level_keywords\": [\"Themes\", \"Story analysis\"],\n  \"low_level_keywords\": [\"Character development\", \"Plot structure\", \"Motifs\", \"Symbolism\", \"Conflict\"]\n}\n2025-01-03 20:14:20,047 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-01-03 20:17:04,801 - lightrag - INFO - Local query uses 60 entites, 104 relations, 3 text units\n2025-01-03 20:17:05,260 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-01-03 20:18:15,647 - lightrag - INFO - Global query uses 49 entites, 60 relations, 3 text units\n2025-01-03 20:18:33,660 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n------------------- Query Result:  -------------------\n**Themes in \"A Christmas Carol\"**\n\n\"A Christmas Carol\" by Charles Dickens is a rich narrative that explores several powerful themes, ultimately leading to a story about redemption and human connection. Below are the top themes that weave throughout the tale:\n\n### 1. **Redemption and Transformation**\nOne of the most prominent themes in \"A Christmas Carol\" is the possibility of redemption. Ebenezer Scrooge, the story\u2019s central character, undergoes a profound transformation from a cold-hearted miser to a generous and caring individual. This journey is ignited by the visits from three spirits\u2014Marley's Ghost, the Ghost of Christmas Past, the Ghost of Christmas Present, and the Ghost of Christmas Yet to Come\u2014who guide him to reflect on his life choices and their ramifications. The notion that anyone can change, regardless of their past actions, stands as an optimistic commentary on the human experience.\n\n### 2. **The Spirit of Christmas**\nChristmas serves as a backdrop for themes of joy, generosity, and community. Initially, Scrooge dismisses Christmas as nonsense and a burden; however, through various encounters, he learns the true essence of the holiday: caring for others, celebrating family, and spreading goodwill. The contrast between Scrooge\u2019s grim perspective and the joyous spirit of Christmas embodied by characters like his nephew Fred and the Cratchit family illustrates the importance of community and connection during the festive season.\n\n### 3. **Social Critique and Wealth**\nDickens employs Scrooge\u2019s character to critique social issues such as greed, poverty, and the divide between the wealthy and the impoverished. Scrooge's initial indifference towards the needy reflects systemic societal neglect. Through his transformation, Dickens advocates for social responsibility and the need for individuals to act compassionately towards the less fortunate, symbolized in characters like Tiny Tim, whose fragility highlights the impact of societal indifference on vulnerable lives.\n\n### 4. **Familial Bonds and Love**\nThe narrative emphasizes the significance of family relationships and the warmth of loving connections. Scrooge\u2019s reflections on his past, particularly his memories of family gatherings, convey a longing for connection and belonging, which he initially shuns. The Cratchit family, despite their financial struggles, exemplifies love and togetherness, contrasting Scrooge\u2019s isolation. By the story's end, Scrooge learns to appreciate and actively engage with his family, indicating a renewal of these essential bonds.\n\n### 5. **Time and Memory**\nThe theme of time is central to Scrooge's transformation, as he confronts moments from his past, experiences the joys and struggles of the present, and considers the potential bleak future his choices could lead to. Dickens underscores the importance of memory in shaping one's identity and moral fabric. Scrooge's retrospective journey highlights the necessity of reflecting on past actions to foster personal growth and responsibility.\n\n### Conclusion\nIn \"A Christmas Carol,\" Dickens masterfully intertwines themes of redemption, compassion, and social awareness, creating a narrative that resonates with the importance of kindness and community spirit. Through Scrooge\u2019s transformation, readers are reminded of the power of empathy, the significance of familial connections, and the universal potential for redemption. Ultimately, the story serves as a poignant reminder of the enduring values associated with the holiday season.\n</pre>"},{"location":"graphrag/lightrag/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Before proceeding, ensure you\u2019ve completed the installation and setup steps outlined in the Installation Guide, including:</p> <ul> <li><p>Setting up Python and TigerGraph. For more details, refer to the Requirements section.</p> </li> <li><p>Install TigerGraphX along with its development dependencies. For more details, refer to the Development Installation section.</p> </li> <li><p>Set the environment variables <code>TG_HOST</code>, <code>TG_USERNAME</code>, and <code>TG_PASSWORD</code>, which are required to connect to the TigerGraph server, as well as <code>OPENAI_API_KEY</code> for connecting to OpenAI. Use a command like the following to set these variables:</p> <pre>export TG_HOST=https://127.0.0.1\n</pre> </li> </ul>"},{"location":"graphrag/lightrag/#implement-graph-and-vector-storage-with-tigergraph","title":"Implement Graph and Vector Storage with TigerGraph\u00b6","text":"<p>In LightRAG, storage layers are abstracted into components such as graph storage, key-value storage, and vector storage. You can explore the base classes BaseGraphStorage, BaseVectorStorage, and BaseKVStorage in the source code.</p> <p>In this section, we will demonstrate how to use TigerGraphX to implement the <code>BaseGraphStorage</code> class for storing and retrieving graph data in TigerGraph. Additionally, we will show how to implement the <code>BaseVectorStorage</code> class for storing vector data and performing vector searches using the TigerVector feature in TigerGraph.</p>"},{"location":"graphrag/lightrag/#implement-graph-storage-with-tigergraph","title":"Implement Graph Storage with TigerGraph\u00b6","text":""},{"location":"graphrag/lightrag/#key-features","title":"Key Features:\u00b6","text":"<ol> <li><p>Graph Schema</p> <ul> <li>Defines a node type <code>\"Entity\"</code> with attributes like <code>id</code>, <code>entity_type</code>, <code>description</code>, and <code>source_id</code>.</li> <li>Defines an edge type <code>\"relationship\"</code> with attributes like <code>weight</code>, <code>description</code>, and <code>source_id</code>.</li> </ul> </li> <li><p>Graph Initialization</p> <ul> <li>Initializes the graph with the schema using TigerGraphX.</li> <li>Connection details (host, ports, authentication) are fetched from environment variables.</li> </ul> </li> <li><p>Node and Edge Operations</p> <ul> <li>Node Operations:<ul> <li><code>has_node</code>: Checks if a node exists.</li> <li><code>get_node</code>: Gets data for a node.</li> <li><code>upsert_node</code>: Adds or updates a node.</li> <li><code>delete_node</code>: Deletes a node.</li> </ul> </li> <li>Edge Operations:<ul> <li><code>has_edge</code>: Checks if an edge exists.</li> <li><code>get_edge</code>: Gets data for an edge.</li> <li><code>upsert_edge</code>: Adds or updates an edge.</li> </ul> </li> </ul> </li> <li><p>Graph Metrics</p> <ul> <li><code>node_degree</code>: Returns the number of connections a node has.</li> <li><code>edge_degree</code>: Calculates the combined degrees of two nodes.</li> </ul> </li> <li><p>Additional Functions</p> <ul> <li><code>clean_quotes</code>: Strips quotes from strings.</li> <li><code>drop_graph</code>: Deletes the entire graph.</li> </ul> </li> </ol>"},{"location":"graphrag/lightrag/#conclusion","title":"Conclusion:\u00b6","text":"<p>The <code>TigerGraphStorage</code> class helps manage and interact with graph data in TigerGraph by offering simple methods for storing, retrieving, and managing nodes, edges, and graph metrics.</p>"},{"location":"graphrag/lightrag/#implement-vector-storage-with-tigergraph","title":"Implement Vector Storage with TigerGraph\u00b6","text":""},{"location":"graphrag/lightrag/#key-features","title":"Key Features:\u00b6","text":"<ol> <li><p>Graph Schema</p> <ul> <li>The graph schema defines a node type called <code>\"Table\"</code>, which has attributes including an <code>id</code> and a vector attribute for storing embeddings. The vector attribute's dimension is based on the <code>embedding_func</code>.</li> </ul> </li> <li><p>Upsert Method</p> <ul> <li>The <code>upsert</code> method inserts or updates vector data in the TigerGraph database. It batches the data and generates embeddings asynchronously using <code>embedding_func</code>, then stores these embeddings in the graph.</li> </ul> </li> <li><p>Query Method</p> <ul> <li>The <code>query</code> method performs a vector search in the TigerGraph database to find the most similar nodes based on a query vector. It uses the <code>embedding_func</code> to generate the query vector and then queries the database for the closest nodes.</li> </ul> </li> </ol>"},{"location":"graphrag/lightrag/#conclusion","title":"Conclusion:\u00b6","text":"<p><code>TigerVectorStorage</code> enables the use of vector embeddings in TigerGraph, allowing for efficient storage and search of vector data.</p>"},{"location":"graphrag/lightrag/#integrating-custom-graph-and-vector-storage-with-lightrag","title":"Integrating Custom Graph and Vector Storage with LightRAG\u00b6","text":"<p>After defining the <code>TigerGraphStorage</code> and <code>TigerVectorStorage</code> classes, we integrate them into LightRAG. By subclassing LightRAG and extending its storage mapping, you can easily replace or augment the default storage backends with your custom solutions.</p> <p>While modifying the LightRAG source code is another option, this example demonstrates how to achieve the integration without altering the original source code.</p> <p>Below is the code for creating a <code>CustomLightRAG</code> class that incorporates both <code>TigerGraphStorage</code> and <code>TigerVectorStorage</code> into its storage mapping.</p>"},{"location":"graphrag/lightrag/#indexing","title":"Indexing\u00b6","text":""},{"location":"graphrag/lightrag/#data-preparation","title":"Data Preparation\u00b6","text":""},{"location":"graphrag/lightrag/#set-up-working-directory","title":"Set Up Working Directory\u00b6","text":"<p>Create a folder to serve as the working directory. For this demo, we will use <code>applications/lightrag/data</code>.</p> <p>Next, create an <code>input</code> folder inside the <code>data</code> directory to store the documents you want to index:</p> <pre>mkdir -p applications/lightrag/data/input\n</pre>"},{"location":"graphrag/lightrag/#add-documents-to-the-input-folder","title":"Add Documents to the Input Folder\u00b6","text":"<p>Copy your documents (e.g., <code>fin.txt</code>) into the <code>applications/lightrag/data/input</code> folder.</p>"},{"location":"graphrag/lightrag/#indexing","title":"Indexing\u00b6","text":"<p>The following code sets up a working directory and demonstrates how to index a given document using LightRAG.</p>"},{"location":"graphrag/lightrag/#querying","title":"Querying\u00b6","text":"<p>The following code demonstrates how to perform a query in LightRAG using the TigerGraph graph storage implementation.</p>"},{"location":"graphrag/msft_graphrag_1/","title":"Supporting Microsoft\u2019s GraphRAG: Part 1","text":"<p>Microsoft's GraphRAG is a method for creating structured knowledge graphs from raw text, enhancing Retrieval Augmented Generation (RAG) tasks. By organizing information hierarchically, it enables more efficient data retrieval and summarization.</p>"},{"location":"graphrag/msft_graphrag_1/#what-youll-learn-in-this-guide","title":"What You\u2019ll Learn in This Guide","text":"<ul> <li>Indexing: Utilize Microsoft's GraphRAG to convert unstructured documents into Parquet files.</li> <li>Data Preprocessing: Learn how to use utility methods provided by TigerGraphX to transform Parquet files into CSV files compatible with TigerGraph.</li> </ul>"},{"location":"graphrag/msft_graphrag_1/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you\u2019ve completed the installation and setup steps outlined in the Installation Guide, including:</p> <ul> <li>Setting up Python and TigerGraph. For more details, refer to the Requirements section.</li> <li>Install TigerGraphX along with its development dependencies. For more details, refer to the Development Installation section.</li> </ul>"},{"location":"graphrag/msft_graphrag_1/#utilize-microsoft-graphrag-for-indexing","title":"Utilize Microsoft GraphRAG for Indexing","text":"<p>The indexing process transforms raw documents into structured data using Microsoft\u2019s GraphRAG. Follow these steps to prepare your data:</p>"},{"location":"graphrag/msft_graphrag_1/#data-preparation","title":"Data Preparation","text":""},{"location":"graphrag/msft_graphrag_1/#create-an-input-folder","title":"Create an Input Folder","text":"<p>Create an <code>input</code> folder in the <code>data</code> directory under <code>applications/msft_graphrag</code> to store the documents you want to index. You can specify a different directory by replacing <code>data</code> with your desired path.</p> <pre><code>mkdir -p data/input\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#add-documents-to-the-input-folder","title":"Add Documents to the Input Folder","text":"<p>Copy your documents into the <code>data/input</code> folder.</p> <p>For this demo, we will use the dataset A Christmas Carol by Charles Dickens.</p> <pre><code>curl https://www.gutenberg.org/cache/epub/24022/pg24022.txt -o data/input/book.txt\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#initialization","title":"Initialization","text":"<p>Initialize the indexing system in the <code>data</code> directory.</p> <pre><code>python3 -m graphrag init --root data\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#set-up-openai-api-key","title":"Set Up OpenAI API Key","text":"<p>GraphRAG requires an OpenAI API key. To configure it:</p> <ol> <li>Open the <code>.env</code> file in the <code>data</code> directory:    <pre><code>vi data/.env\n</code></pre></li> <li>Add your API key:    <pre><code>GRAPHRAG_API_KEY=&lt;Your OpenAI API Key&gt;\n</code></pre></li> </ol>"},{"location":"graphrag/msft_graphrag_1/#optional-switch-to-a-cost-effective-model","title":"Optional: Switch to a Cost-Effective Model","text":"<p>GraphRAG uses the <code>gpt-4-turbo-preview</code> model by default. To reduce costs, switch to the <code>gpt-4o-mini</code> model by editing the <code>settings.yaml</code> file in the <code>data</code> directory:</p> <pre><code>llm:\n  api_key: ${GRAPHRAG_API_KEY}\n  type: openai_chat # or azure_openai_chat\n  model: gpt-4o-mini # Use a cost-effective model\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#indexing","title":"Indexing","text":"<p>Run the indexing process to convert documents into structured data. This step uses LLMs and may take several minutes depending on the dataset size and hardware.</p> <pre><code>python3 -m graphrag index --no-cache --root data\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#utilize-tigergraphx-for-data-preprocessing","title":"Utilize TigerGraphX for Data Preprocessing","text":"<p>Transform the structured Parquet files generated by GraphRAG into CSV files that TigerGraph can import.</p>"},{"location":"graphrag/msft_graphrag_1/#convert-parquet-to-csv","title":"Convert Parquet to CSV","text":"<p>Run the script below to convert Parquet files into TigerGraph-compatible CSV files. You can find the Python script here.</p> <pre><code>python3 data_import/convert_parquet_to_tg_csv.py \\\n--input_dir data/output \\\n--output_dir data/tg_csv\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#export-data-from-lancedb-to-csv","title":"Export Data from LanceDB to CSV","text":"<p>Use the script below to export data from LanceDB into CSV files that are compatible with TigerGraph. You can access the Python script here.</p> <pre><code>python3 data_import/export_lancedb_to_csv.py \\\n--input_dir data/output/lancedb \\\n--output_dir data/tg_csv\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#transfer-csv-files-to-tigergraph-server","title":"Transfer CSV Files to TigerGraph Server","text":"<p>Transfer the generated CSV files to your TigerGraph server. Use the following command, replacing <code>username</code> and <code>tigergraph-server</code> with your server credentials:</p> <pre><code>scp data/tg_csv/* username@tigergraph-server:/home/tigergraph/data/graphrag\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#next-steps","title":"Next Steps","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 2: Use Jupyter Notebook to create the schema and load data into TigerGraph.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_2/","title":"Part 2","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph\nresource_dir = \"../../applications/msft_graphrag/query/resources/\"\ngraph_schema = resource_dir + \"graph_schema.yaml\"\n</pre> from tigergraphx import Graph resource_dir = \"../../applications/msft_graphrag/query/resources/\" graph_schema = resource_dir + \"graph_schema.yaml\" In\u00a0[2]: Copied! <pre>connection = {\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n}\n</pre> connection = {     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", } In\u00a0[3]: Copied! <pre>G = Graph(\n    graph_schema=graph_schema,\n    tigergraph_connection_config=connection,\n    drop_existing_graph=False,\n)\n</pre> G = Graph(     graph_schema=graph_schema,     tigergraph_connection_config=connection,     drop_existing_graph=False, ) <pre>2025-01-05 23:22:37,193 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph GraphRAG...\n2025-01-05 23:23:30,577 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n</pre> In\u00a0[4]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>0\n</pre> <p>After that, we will load data into the graph using a pre-defined loading job configuration. The configuration is stored in a YAML file. Note that loading the data may take several seconds.</p> In\u00a0[5]: Copied! <pre>loading_job_config = resource_dir + \"loading_job_config.yaml\"\nG.load_data(loading_job_config)\n</pre> loading_job_config = resource_dir + \"loading_job_config.yaml\" G.load_data(loading_job_config) <p>Now, let's check the total number of nodes in the graph again. We should observe that some nodes have been successfully loaded into the graph.</p> In\u00a0[6]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>371\n</pre>"},{"location":"graphrag/msft_graphrag_2/#supporting-microsofts-graphrag-part-2","title":"Supporting Microsoft\u2019s GraphRAG: Part 2\u00b6","text":"<p>In the previous section, we used Microsoft's GraphRAG to convert unstructured documents into Parquet files, and then used TigerGraphX to transform these files into CSV format.</p> <p>Now, let\u2019s use Jupyter Notebook to create the schema and load the CSV files into TigerGraph.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_2.ipynb.</p>"},{"location":"graphrag/msft_graphrag_2/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p>"},{"location":"graphrag/msft_graphrag_2/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>The graph schema can be defined using a YAML file, a JSON file, or a Python dictionary. In this example, we will initialize a graph using a schema defined in a YAML file. The schema structure is represented visually in the following image.</p> <p></p>"},{"location":"graphrag/msft_graphrag_2/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, you also need a connection configuration to establish communication with the TigerGraph server. You can connect using either a username/password, a secret, or a token. Below is an example of connecting to TigerGraph using a username and password.</p>"},{"location":"graphrag/msft_graphrag_2/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"graphrag/msft_graphrag_2/#load-data","title":"Load Data\u00b6","text":"<p>First, let's check the total number of nodes in the graph. As anticipated, the graph is currently empty.</p>"},{"location":"graphrag/msft_graphrag_2/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 3: Use Jupyter Notebook to explore graph data and perform Graph Analysis.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_3/","title":"Part 3","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph\nconnection = {\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n}\nG = Graph.from_db(\"GraphRAG\", connection)\n</pre> from tigergraphx import Graph connection = {     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", } G = Graph.from_db(\"GraphRAG\", connection) <pre>2025-01-05 23:30:15,203 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph GraphRAG...\n2025-01-05 23:30:15,223 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n</pre> In\u00a0[2]: Copied! <pre>schema = G.get_schema()\nprint(schema[\"graph_name\"])\n</pre> schema = G.get_schema() print(schema[\"graph_name\"]) <pre>GraphRAG\n</pre> In\u00a0[3]: Copied! <pre>for node in schema[\"nodes\"].items():\n    print(node)\n</pre> for node in schema[\"nodes\"].items():     print(node) <pre>('Document', {'primary_key': 'id', 'attributes': {'title': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}, 'vector_attributes': {}})\n('TextUnit', {'primary_key': 'id', 'attributes': {'text': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'n_tokens': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}, 'vector_attributes': {}})\n('Entity', {'primary_key': 'id', 'attributes': {'human_readable_id': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'name': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'entity_type': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'description': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}, 'vector_attributes': {}})\n('Relationship', {'primary_key': 'id', 'attributes': {'human_readable_id': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'rank': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'weight': {'data_type': &lt;DataType.DOUBLE: 'DOUBLE'&gt;, 'default_value': None}, 'description': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}, 'vector_attributes': {}})\n('Community', {'primary_key': 'id', 'attributes': {'level': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'rank': {'data_type': &lt;DataType.DOUBLE: 'DOUBLE'&gt;, 'default_value': None}, 'rank_explanation': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'title': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'full_content': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'summary': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}, 'vector_attributes': {}})\n</pre> In\u00a0[4]: Copied! <pre>for edge in schema[\"edges\"].items():\n    print(edge)\n</pre> for edge in schema[\"edges\"].items():     print(edge) <pre>('document_contains_text_unit', {'is_directed_edge': False, 'from_node_type': 'Document', 'to_node_type': 'TextUnit', 'edge_identifier': set(), 'attributes': {}})\n('text_unit_contains_entity', {'is_directed_edge': False, 'from_node_type': 'TextUnit', 'to_node_type': 'Entity', 'edge_identifier': set(), 'attributes': {}})\n('text_unit_contains_relationship', {'is_directed_edge': False, 'from_node_type': 'TextUnit', 'to_node_type': 'Relationship', 'edge_identifier': set(), 'attributes': {}})\n('relationship_source', {'is_directed_edge': False, 'from_node_type': 'Relationship', 'to_node_type': 'Entity', 'edge_identifier': set(), 'attributes': {}})\n('relationship_target', {'is_directed_edge': False, 'from_node_type': 'Relationship', 'to_node_type': 'Entity', 'edge_identifier': set(), 'attributes': {}})\n('community_contains_entity', {'is_directed_edge': False, 'from_node_type': 'Community', 'to_node_type': 'Entity', 'edge_identifier': set(), 'attributes': {}})\n('community_contains_relationship', {'is_directed_edge': False, 'from_node_type': 'Community', 'to_node_type': 'Relationship', 'edge_identifier': set(), 'attributes': {}})\n</pre> In\u00a0[5]: Copied! <pre>G.number_of_nodes()\n</pre> G.number_of_nodes() Out[5]: <pre>371</pre> In\u00a0[6]: Copied! <pre>for node_type in schema[\"nodes\"]:\n    print(f\"{node_type}: {G.number_of_nodes(node_type)}\")\n</pre> for node_type in schema[\"nodes\"]:     print(f\"{node_type}: {G.number_of_nodes(node_type)}\") <pre>Document: 1\nTextUnit: 42\nEntity: 138\nRelationship: 168\nCommunity: 22\n</pre> In\u00a0[7]: Copied! <pre>G.number_of_edges()\n</pre> G.number_of_edges() Out[7]: <pre>1545</pre> In\u00a0[8]: Copied! <pre>for edge_type in schema[\"edges\"]:\n    print(f\"{edge_type}: {G.number_of_edges(edge_type)}\")\n</pre> for edge_type in schema[\"edges\"]:     print(f\"{edge_type}: {G.number_of_edges(edge_type)}\") <pre>document_contains_text_unit: 42\ntext_unit_contains_entity: 274\ntext_unit_contains_relationship: 238\nrelationship_source: 168\nrelationship_target: 168\ncommunity_contains_entity: 236\ncommunity_contains_relationship: 419\n</pre> In\u00a0[9]: Copied! <pre>G.get_nodes(node_type=\"Entity\", limit=2)\n</pre> G.get_nodes(node_type=\"Entity\", limit=2) Out[9]: v_id v_type human_readable_id entity_type name description id 0 473502492d0a419981fed4fbc1493832 Entity 69 PERSON THE THREE MISS FEZZIWIGS Daughters of Mr. and Mrs. Fezziwig, described ... 473502492d0a419981fed4fbc1493832 1 6fb90dc954fe40d5969f7532a66376e9 Entity 108 PERSON WANT Want is depicted as a girl, symbolizing povert... 6fb90dc954fe40d5969f7532a66376e9 In\u00a0[10]: Copied! <pre>G.get_nodes(node_type=\"Relationship\", limit=2)\n</pre> G.get_nodes(node_type=\"Relationship\", limit=2) Out[10]: v_id v_type human_readable_id rank weight description id 0 9953ed9db4c5418e8bf9fee18032c0da Relationship 63 9 20 Fezziwig and Mrs. Fezziwig share a close perso... 9953ed9db4c5418e8bf9fee18032c0da 1 e9953a1648364e878d835bc6bcc0d3ef Relationship 37 5 1 The activities and cheer that the Ghost of Chr... e9953a1648364e878d835bc6bcc0d3ef In\u00a0[11]: Copied! <pre>G.get_nodes(node_type=\"Community\", limit=2)\n</pre> G.get_nodes(node_type=\"Community\", limit=2) Out[11]: v_id v_type summary level full_content rank id rank_explanation title 0 12 Community This report delves into the interconnected rel... 1 # The Transformation of Ebenezer Scrooge: A Ch... 8.5 12 The high impact severity rating reflects the p... Community 12 1 7 Community This report explores the network surrounding P... 0 # Project Gutenberg and the Digital Disseminat... 8.5 7 The high impact severity rating reflects Proje... Community 7"},{"location":"graphrag/msft_graphrag_3/#supporting-microsofts-graphrag-part-3","title":"Supporting Microsoft\u2019s GraphRAG: Part 3\u00b6","text":"<p>In the previous section, we have created a graph in TigerGraph, and loaded the CSV data into it.</p> <p>Now, let\u2019s use Jupyter Notebook to explore the graph data and perform graph analysis.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_3.ipynb.</p>"},{"location":"graphrag/msft_graphrag_3/#get-the-graph-from-tigergraph","title":"Get the Graph from TigerGraph\u00b6","text":"<p>Since the graph has already been created in TigerGraph, redefining its schema is unnecessary. Instead, you can provide the graph name to retrieve it. TigerGraphX will verify if the graph exists in TigerGraph and, if it does, will return the corresponding graph.</p>"},{"location":"graphrag/msft_graphrag_3/#display-the-graph-schema","title":"Display the Graph Schema\u00b6","text":"<p>Let's retrieve the graph schema using the <code>get_schema</code> method. The output is a Python dictionary containing three keys: <code>\"graph_name\"</code>, <code>\"nodes\"</code>, and <code>\"edges\"</code>. We'll print each of them individually to explore the schema details.</p>"},{"location":"graphrag/msft_graphrag_3/#retrieve-the-graph-schema-and-display-the-graph-name","title":"Retrieve the Graph Schema and Display the Graph Name\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-the-node-tyeps","title":"Display the Node Tyeps\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-the-edge-types","title":"Display the Edge Types\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-node-and-edge-counts","title":"Display Node and Edge Counts\u00b6","text":"<p>Gain deeper insights into the graph by exploring details such as the total number of nodes and the count of nodes for each node type.</p>"},{"location":"graphrag/msft_graphrag_3/#display-the-total-number-of-nodes","title":"Display the Total Number of Nodes\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-the-count-of-nodes-for-each-node-type","title":"Display the Count of Nodes for Each Node Type\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-the-total-number-of-edges","title":"Display the Total Number of Edges\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-the-count-of-edges-for-each-edge-type","title":"Display the Count of Edges for Each Edge Type\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#retrieve-sample-nodes-from-the-graph","title":"Retrieve Sample Nodes from the Graph\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#whats-next","title":"What\u2019s Next?\u00b6","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 4: Perform queries using GSQL and Python-native TigerGraphX, with global and local context builders.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_4/","title":"Part 4","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph, TigerGraphConnectionConfig\nconnection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\nG = Graph.from_db(\"GraphRAG\", connection)\n</pre> from tigergraphx import Graph, TigerGraphConnectionConfig connection = TigerGraphConnectionConfig.ensure_config({     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", }) G = Graph.from_db(\"GraphRAG\", connection) <pre>2025-01-05 23:51:06,143 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph GraphRAG...\n2025-01-05 23:51:06,152 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n</pre> In\u00a0[2]: Copied! <pre>G.get_nodes(\n    node_type=\"Entity\",\n    return_attributes=[\"id\", \"name\", \"entity_type\", \"description\"],\n    limit=2,\n)\n</pre> G.get_nodes(     node_type=\"Entity\",     return_attributes=[\"id\", \"name\", \"entity_type\", \"description\"],     limit=2, ) Out[2]: id name entity_type description 0 473502492d0a419981fed4fbc1493832 THE THREE MISS FEZZIWIGS PERSON Daughters of Mr. and Mrs. Fezziwig, described ... 1 6fb90dc954fe40d5969f7532a66376e9 WANT PERSON Want is depicted as a girl, symbolizing povert... In\u00a0[3]: Copied! <pre>start_nodes = [\"473502492d0a419981fed4fbc1493832\", \"6fb90dc954fe40d5969f7532a66376e9\"]\nG.get_neighbors(\n    start_nodes=start_nodes,\n    start_node_type=\"Entity\",\n    edge_types=\"community_contains_entity\",\n    return_attributes=[\"id\", \"title\", \"full_content\"],\n)\n</pre> start_nodes = [\"473502492d0a419981fed4fbc1493832\", \"6fb90dc954fe40d5969f7532a66376e9\"] G.get_neighbors(     start_nodes=start_nodes,     start_node_type=\"Entity\",     edge_types=\"community_contains_entity\",     return_attributes=[\"id\", \"title\", \"full_content\"], ) Out[3]: id title full_content 0 9 Community 9 # The Transformation of Ebenezer Scrooge: A St... 1 0 Community 0 # The Transformation Journey of Ebenezer Scroo... 2 19 Community 19 # The Transformation of Ebenezer Scrooge: A Ch... 3 1 Community 1 # Fezziwig's Christmas Celebration Community\\n... In\u00a0[4]: Copied! <pre>import random\nrandom_floats: list[float] = [random.random() for _ in range(1536)]\nresults = G.search(\n    data=random_floats,\n    vector_attribute_name=\"emb_description\",\n    node_type=\"Entity\",\n    limit=1,\n)\nprint(results)\n</pre> import random random_floats: list[float] = [random.random() for _ in range(1536)] results = G.search(     data=random_floats,     vector_attribute_name=\"emb_description\",     node_type=\"Entity\",     limit=1, ) print(results) <pre>[{'id': '9b24fbfeb0e94dd889c10700718b048f', 'distance': 0.9512004, 'human_readable_id': 83, 'name': 'GROCER', 'entity_type': '', 'description': ''}]\n</pre> In\u00a0[5]: Copied! <pre>import tiktoken\nfrom typing import Optional, List\nfrom tigergraphx.graphrag import BaseContextBuilder\nfrom tigergraphx.core import Graph\nclass GlobalContextBuilder(BaseContextBuilder):\n    def __init__(\n        self,\n        graph: Graph,\n        token_encoder: Optional[tiktoken.Encoding] = None,\n    ):\n        \"\"\"Initialize LocalContextBuilder with graph config and token encoder.\"\"\"\n        super().__init__(\n            graph=graph,\n            single_batch=False,\n            token_encoder=token_encoder,\n        )\n    async def build_context(self) -&gt; str | List[str]:\n        \"\"\"Build local context.\"\"\"\n        context: List[str] = []\n        config = {\n            \"max_tokens\": 12000,\n            \"section_name\": \"Communities\",\n            \"return_attributes\": [\"id\", \"rank\", \"title\", \"full_content\"],\n            \"limit\": 1000,\n        }\n        df = self.graph.get_nodes(\n            node_type=\"Community\",\n            return_attributes=config[\"return_attributes\"],\n            limit=config[\"limit\"],\n        )\n        if df is not None:\n            text_context = self.batch_and_convert_to_text(\n                graph_data=df,\n                max_tokens=config[\"max_tokens\"],\n                single_batch=self.single_batch,\n                section_name=config[\"section_name\"],\n            )\n            context.extend(\n                text_context if isinstance(text_context, list) else [text_context]\n            )\n        return context\n</pre> import tiktoken from typing import Optional, List from tigergraphx.graphrag import BaseContextBuilder from tigergraphx.core import Graph class GlobalContextBuilder(BaseContextBuilder):     def __init__(         self,         graph: Graph,         token_encoder: Optional[tiktoken.Encoding] = None,     ):         \"\"\"Initialize LocalContextBuilder with graph config and token encoder.\"\"\"         super().__init__(             graph=graph,             single_batch=False,             token_encoder=token_encoder,         )     async def build_context(self) -&gt; str | List[str]:         \"\"\"Build local context.\"\"\"         context: List[str] = []         config = {             \"max_tokens\": 12000,             \"section_name\": \"Communities\",             \"return_attributes\": [\"id\", \"rank\", \"title\", \"full_content\"],             \"limit\": 1000,         }         df = self.graph.get_nodes(             node_type=\"Community\",             return_attributes=config[\"return_attributes\"],             limit=config[\"limit\"],         )         if df is not None:             text_context = self.batch_and_convert_to_text(                 graph_data=df,                 max_tokens=config[\"max_tokens\"],                 single_batch=self.single_batch,                 section_name=config[\"section_name\"],             )             context.extend(                 text_context if isinstance(text_context, list) else [text_context]             )         return context <p>Here\u2019s how you can utilize the custom global context builder:</p> In\u00a0[6]: Copied! <pre>global_context_builder = GlobalContextBuilder(G)\ncontext_list = await global_context_builder.build_context()\n# Print the first 1000 characters for easier visualization of long text\nprint(context_list[0][:1000])\n</pre> global_context_builder = GlobalContextBuilder(G) context_list = await global_context_builder.build_context() # Print the first 1000 characters for easier visualization of long text print(context_list[0][:1000]) <pre>-----Communities-----\nid|rank|title|full_content\n18|8.5|Community 18|# Project Gutenberg Ecosystem\\n\\nThe Project Gutenberg ecosystem is a collaborative network focused on the free distribution of electronic literature. Central to this community are the Project Gutenberg Literary Archive Foundation, Project Gutenberg\u2122, and its electronic works, supported by a structure of copyright management, royalty fees, and the pioneering efforts of Michael S. Hart. This network facilitates the global dissemination of literature in digital formats, ensuring accessibility and promoting literary heritage.\\n\\n## The foundational role of the Project Gutenberg Literary Archive Foundation\\n\\nThe Project Gutenberg Literary Archive Foundation is pivotal in the Project Gutenberg ecosystem, managing copyrights and the Project Gutenberg trademark. It receives donations and royalties, supporting the mission to preserve and provide free access to electronic works. This foundation ensures the sustainability of P\n</pre>"},{"location":"graphrag/msft_graphrag_4/#supporting-microsofts-graphrag-part-4","title":"Supporting Microsoft\u2019s GraphRAG: Part 4\u00b6","text":"<p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_4.ipynb.</p>"},{"location":"graphrag/msft_graphrag_4/#get-the-graph-from-tigergraph","title":"Get the Graph from TigerGraph\u00b6","text":""},{"location":"graphrag/msft_graphrag_4/#hybrid-retrieval","title":"Hybrid Retrieval\u00b6","text":"<p>TigerGraph offers two flexible ways to perform hybrid retrieval, allowing you to extract relevant graph and vector data efficiently for GraphRAG workflows.</p>"},{"location":"graphrag/msft_graphrag_4/#using-tigergraphx","title":"Using TigerGraphX\u00b6","text":"<p>TigerGraphX offers an intuitive, Python-native interface for hybrid retrieval, ideal for developers seeking simplicity and ease of use.</p> <p>Key Advantage: Minimal learning curve with high-level Python APIs, seamlessly integrated with existing workflows.</p> <p>Below are some illustrative examples.</p>"},{"location":"graphrag/msft_graphrag_4/#retrieve-nodes-with-specific-attributes","title":"Retrieve Nodes with Specific Attributes\u00b6","text":"<p>You can use the following code to fetch up to two nodes of type \"Entity\" and display their \"id,\" \"entity_type,\" and \"description\" attributes.</p>"},{"location":"graphrag/msft_graphrag_4/#retrieve-neighbors-with-specific-attributes","title":"Retrieve Neighbors with Specific Attributes\u00b6","text":"<p>The following code demonstrates how to fetch neighbors of specific nodes. In this example, the query retrieves neighbors connected to the given <code>start_nodes</code> of type <code>\"Entity\"</code> through the edge type <code>\"community_contains_entity\"</code>. The attributes <code>\"id\"</code>, <code>\"title\"</code>, and <code>\"full_content\"</code> of the neighbors are returned.</p>"},{"location":"graphrag/msft_graphrag_4/#retrieve-top-k-using-tigervectors-vector-search-capability","title":"Retrieve Top-K Using TigerVector's Vector Search Capability\u00b6","text":"<p>The following code generates a random query vector of 1536 float values and uses it to perform a vector search on a TigerGraph instance. The search finds the most similar \"Entity\" nodes based on the \"emb_description\" vector attribute and returns the top result.</p>"},{"location":"graphrag/msft_graphrag_4/#using-gsql","title":"Using GSQL\u00b6","text":"<p>For developers seeking fine-grained control or complex retrieval logic, GSQL offers unmatched flexibility. As TigerGraph's built-in query language, GSQL empowers you to perform advanced graph data analysis. For more details, see the official documentation.</p> <p>Key Advantage: Supports complex logic, customization, and direct interaction with TigerGraph\u2019s powerful query engine.</p> <ol> <li>Use an LLM to convert the query into an embedding.</li> <li>Write a GSQL query to retrieve the top-K similar objects and their neighbors, combining structured and vector-based retrieval:</li> </ol> <pre>CREATE OR REPLACE QUERY query (List&lt;float&gt; embedding, int k) {\n  Nodes = TopKVectorSearch({Entity.entity_embedding}, embedding, k);\n\n  Neighbors =\n    SELECT t\n    FROM Nodes:s -(community_contains_entity:e)- :t;\n\n  PRINT Neighbors[Neighbors.id, Neighbors.title, Neighbors.full_content];\n}\n</pre>"},{"location":"graphrag/msft_graphrag_4/#context-building-writing-custom-context-builders","title":"Context Building: Writing Custom Context Builders\u00b6","text":"<p>Context builders play a vital role in graph-powered RAG workflows. They transform retrieved graph data into structured, meaningful contexts for tasks such as interactions with LLMs).</p> <p>TigerGraphX simplifies this process by offering the flexible <code>BaseContextBuilder</code> class, which allows developers to define custom logic for context building.</p>"},{"location":"graphrag/msft_graphrag_4/#key-features-of-basecontextbuilder","title":"Key Features of <code>BaseContextBuilder</code>\u00b6","text":"<p>The <code>BaseContextBuilder</code> class in TigerGraphX provides a strong foundation for creating custom context builders, offering:</p> <ul> <li>Core Abstraction: A reusable framework for building context logic.</li> <li>Customizable Design: Extensibility for implementing both global and query-specific context generation.</li> </ul>"},{"location":"graphrag/msft_graphrag_4/#key-components","title":"Key Components\u00b6","text":"<ol> <li><p>Abstract Method - <code>build_context</code>: Subclasses must implement this method to define the logic for constructing context.</p> <pre>@abstractmethod\nasync def build_context(self, *args, **kwargs) -&gt; str | List[str]:\n    \"\"\"Abstract method to build context.\"\"\"\n    pass\n</pre> </li> <li><p>Batching and Retrieval Methods:</p> <ul> <li><code>batch_and_convert_to_text</code>: Formats graph data into token-aware text.</li> <li><code>retrieve_top_k_objects</code>: Efficiently retrieves top-K objects for query-based context.</li> </ul> </li> </ol>"},{"location":"graphrag/msft_graphrag_4/#example-global-context-builder","title":"Example: Global Context Builder\u00b6","text":""},{"location":"graphrag/msft_graphrag_4/#example-local-context-builder","title":"Example: Local Context Builder\u00b6","text":"<p>To understand the functionality of the <code>LocalContextBuilder</code> class, let's review the key code from its <code>build_context</code> method.</p> <p></p> <pre><code># Retrieve top-k objects\ntop_k_objects: List[str] = await self.retrieve_top_k_objects(query, k=k)\n...\n# Iterate over different neighbor types\nfor neighbor in neighbor_types:\n    df = self.graph.get_neighbors(...)\n    if df is not None:\n        text_context = self.batch_and_convert_to_text(...)\n        context.extend(\n            text_context if isinstance(text_context, list) else [text_context]\n        )\nreturn \"\\n\\n\".join(context)\n</code></pre> <p>For full implementations of different context builders, refer to the following links:</p> <ul> <li>LocalContextBuilder Code</li> </ul> <p>Here\u2019s how you can utilize the custom local context builder:</p> <pre>local_builder = LocalContextBuilder(graph=graph, search_engine=search_engine)\nlocal_context = await local_builder.build_context(query=\"What are the main topics discussed in the article?\")\n</pre>"},{"location":"graphrag/msft_graphrag_4/#integrate-with-llm","title":"Integrate with LLM\u00b6","text":"<p>After successfully building context from TigerGraph, the final step is integrating it with LLMs, including chat models and embedding models.</p> <p>We have provided an example implementation, which you can find here: Example Code.</p>"},{"location":"graphrag/msft_graphrag_4/#workflow-overview","title":"Workflow Overview\u00b6","text":"<p>The integration process follows the workflow illustrated below:</p> <p></p>"},{"location":"graphrag/msft_graphrag_4/#whats-next","title":"What\u2019s Next?\u00b6","text":"<ul> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"reference/features_overview/","title":"Features Overview","text":"<p>TigerGraphX is designed to simplify complex workflows involving graph databases, vector search, and large language models (LLMs). This page provides an overview of the key features of TigerGraphX and serves as a roadmap to the detailed API documentation for each functionality.</p>"},{"location":"reference/features_overview/#1-schema-management-graph-db","title":"1. Schema Management (Graph DB)","text":"<p>TigerGraphX provides intuitive, Python-native APIs for defining and managing graph schemas. This feature includes:</p> <ul> <li>Programmatic creation and modification of vertices and edges.</li> <li>Support for attributes, primary keys, and schema constraints.</li> <li>Compatibility with YAML and JSON schema definitions.</li> </ul>"},{"location":"reference/features_overview/#2-data-loading-management-graph-db","title":"2. Data Loading Management (Graph DB)","text":"<p>Efficiently load data into TigerGraph from a variety of sources. Key capabilities include:</p> <ul> <li>Support for Parquet and CSV files for high-efficiency workflows.</li> <li>Automated loading jobs to streamline the data import process.</li> <li>Data transformation utilities for pre-processing and compatibility.</li> </ul>"},{"location":"reference/features_overview/#3-graph-library-interface-graph-db-graph-query-language","title":"3. Graph Library Interface (Graph DB, Graph Query Language)","text":"<p>Perform common graph operations using Python-native APIs, including:</p> <ul> <li>CRUD operations for vertices and edges.</li> <li>Multi-hop traversals to analyze relationships in the graph.</li> <li>Graph reporting for insights and analysis.</li> </ul>"},{"location":"reference/features_overview/#4-graph-query-interface-graph-db-graph-query-language","title":"4. Graph Query Interface (Graph DB, Graph Query Language)","text":"<p>Execute advanced queries on your TigerGraph database with ease. This feature includes:</p> <ul> <li>Simplified query execution with Python-based methods.</li> <li>Query results formatted as Pandas DataFrames for seamless integration with analytics workflows.</li> </ul>"},{"location":"reference/features_overview/#5-vector-search-capabilities-vector-db","title":"5. Vector Search Capabilities (Vector DB)","text":"<p>Enhance AI-driven applications with vector embedding support. Key functionalities include:</p> <ul> <li>Storing and querying vector embeddings alongside graph data.</li> <li>Top-K similarity searches for retrieving the most relevant entities.</li> <li>Hybrid retrieval workflows combining graph traversal and vector search.</li> </ul>"},{"location":"reference/features_overview/#6-llm-integration-and-support-llm","title":"6. LLM Integration and Support (LLM)","text":"<p>Enable advanced applications by integrating graph data with large language models (LLMs). Key features:</p> <ul> <li>Token-aware context building for LLM workflows.</li> <li>Hybrid retrieval combining graph, semantic, and vector-based searches.</li> <li>Direct API integration with LLM platforms like OpenAI.</li> </ul>"},{"location":"reference/features_overview/#7-configuration-management-graph-db-vector-db-llm","title":"7. Configuration Management (Graph DB, Vector DB, LLM)","text":"<p>Simplify configuration for various integrations and workflows:</p> <ul> <li>Manage graph database settings programmatically.</li> <li>Configure vector search parameters for efficient retrieval.</li> <li>Customize LLM settings for seamless API interaction.</li> </ul>"},{"location":"reference/features_overview/#8-graphrag-support-graph-db-vector-db-llm","title":"8. GraphRAG Support (Graph DB, Vector DB, LLM)","text":"<p>TigerGraphX simplifies Graph-Retrieval Augmented Generation (GraphRAG) workflows. This feature includes:</p> <ul> <li>Schema definition and data preparation for GraphRAG.</li> <li>Hybrid retrieval methods optimized for GraphRAG use cases.</li> <li>Python-native APIs for context building and LLM integration.</li> </ul>"},{"location":"reference/features_overview/#next-steps","title":"Next Steps","text":"<p>To dive deeper into TigerGraphX\u2019s features, explore the detailed API documentation for each section. Start building powerful graph applications today!</p>"},{"location":"reference/01_core/digraph/","title":"DiGraph","text":""},{"location":"reference/01_core/digraph/#tigergraphx.core.graph.DiGraph","title":"<code>DiGraph</code>","text":"<p>               Bases: <code>HomoGraph</code></p> <p>Represents a directed graph with a single node and edge type.</p>"},{"location":"reference/01_core/digraph/#tigergraphx.core.graph.DiGraph.__init__","title":"<code>__init__(graph_name, node_type='MyNode', edge_type='MyEdge', node_primary_key='id', node_attributes={'id': 'STRING', 'entity_type': 'STRING', 'description': 'STRING'}, edge_attributes={'weight': 'DOUBLE', 'description': 'STRING'}, tigergraph_connection_config=None, drop_existing_graph=False)</code>","text":"<p>Initialize a DiGraph instance.</p> <p>Parameters:</p> <ul> <li> <code>graph_name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>'MyNode'</code> )           \u2013            <p>The type of nodes in the graph. Defaults to \"MyNode\".</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>'MyEdge'</code> )           \u2013            <p>The type of edges in the graph. Defaults to \"MyEdge\".</p> </li> <li> <code>node_primary_key</code>               (<code>str</code>, default:                   <code>'id'</code> )           \u2013            <p>The primary key for nodes. Defaults to \"id\".</p> </li> <li> <code>node_attributes</code>               (<code>AttributesType</code>, default:                   <code>{'id': 'STRING', 'entity_type': 'STRING', 'description': 'STRING'}</code> )           \u2013            <p>Attributes for nodes. Defaults to: {     \"id\": \"STRING\",     \"entity_type\": \"STRING\",     \"description\": \"STRING\", }</p> </li> <li> <code>edge_attributes</code>               (<code>AttributesType</code>, default:                   <code>{'weight': 'DOUBLE', 'description': 'STRING'}</code> )           \u2013            <p>Attributes for edges. Defaults to: {     \"weight\": \"DOUBLE\",     \"description\": \"STRING\", }</p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig | Dict | str | Path]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration for TigerGraph connection. Defaults to None.</p> </li> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to drop the existing graph if it exists. Defaults to False.</p> </li> </ul>"},{"location":"reference/01_core/graph/","title":"Graph","text":""},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph","title":"<code>Graph</code>","text":"<p>Represents a graph structure supporting both homogeneous and heterogeneous graphs.</p> <p>This class handles:</p> <ul> <li>Undirected Homogeneous Graphs</li> <li>Directed Homogeneous Graphs</li> <li>Heterogeneous Graphs with multiple node and edge types</li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.__init__","title":"<code>__init__(graph_schema, tigergraph_connection_config=None, drop_existing_graph=False)</code>","text":"<p>Initialize the Graph instance.</p> <p>Parameters:</p> <ul> <li> <code>graph_schema</code>               (<code>GraphSchema | Dict | str | Path</code>)           \u2013            <p>Graph schema.</p> </li> <li> <code>tigergraph_connection_config</code>               (<code>(optional, TigerGraphConnectionConfig | Dict | str | Path)</code>, default:                   <code>None</code> )           \u2013            <p>TigerGraph connection configuration. Defaults to None.</p> </li> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to drop the existing graph. Defaults to False.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.add_node","title":"<code>add_node(node_id, node_type='', **attr)</code>","text":"<p>Add a node to the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> <li> <code>**attr</code>           \u2013            <p>Additional attributes for the node.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.add_nodes_from","title":"<code>add_nodes_from(nodes_for_adding, node_type='', **attr)</code>","text":"<p>Add nodes from the given list, with each node being either an ID or a tuple of ID and attributes.</p> <p>Parameters:</p> <ul> <li> <code>nodes_for_adding</code>               (<code>List[str] | List[Tuple[str, Dict[str, Any]]]</code>)           \u2013            <p>List of node IDs or tuples of node ID and attribute dictionaries.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Type of the node (e.g., \"MyNode\").</p> </li> <li> <code>**attr</code>           \u2013            <p>Common attributes to be added to all nodes.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>None if there was an error; otherwise, it calls <code>upsertVertices</code> on the connection.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.remove_node","title":"<code>remove_node(node_id, node_type='')</code>","text":"<p>Remove a node from the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the node was removed, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.has_node","title":"<code>has_node(node_id, node_type='')</code>","text":"<p>Check if a node exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the node exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.get_node_data","title":"<code>get_node_data(node_id, node_type='')</code>","text":"<p>Get data of a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>Dict | None: The node data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.get_node_edges","title":"<code>get_node_edges(node_id, node_type='', edge_types=[], num_edge_samples=1000)</code>","text":"<p>Get edges connected to a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> <li> <code>edge_types</code>               (<code>List | str</code>, default:                   <code>[]</code> )           \u2013            <p>Types of edges to include. Defaults to [].</p> </li> <li> <code>num_edge_samples</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Number of edge samples to retrieve. Defaults to 1000.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List</code> (              <code>List</code> )          \u2013            <p>A list of edges.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.add_edge","title":"<code>add_edge(src_node_id, tgt_node_id, src_node_type='', edge_type='', tgt_node_type='', **attr)</code>","text":"<p>Add an edge to the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source node type. Defaults to \"\".</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Type of the edge. Defaults to \"\".</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Target node type. Defaults to \"\".</p> </li> <li> <code>**attr</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional attributes for the edge.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.add_edges_from","title":"<code>add_edges_from(ebunch_to_add, src_node_type, edge_type, tgt_node_type, **attr)</code>","text":"<p>Adds edges to the graph from a list of edge tuples.</p> <p>Parameters:</p> <ul> <li> <code>ebunch_to_add</code>               (<code>List[Tuple[str, str]] | List[Tuple[str, str, Dict[str, Any]]]</code>)           \u2013            <p>List of edges to add, where each edge is a tuple of source and target node IDs, optionally with attributes.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>)           \u2013            <p>The source node type for the edges.</p> </li> <li> <code>edge_type</code>               (<code>str</code>)           \u2013            <p>The type of the edge being added.</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>)           \u2013            <p>The target node type for the edges.</p> </li> <li> <code>**attr</code>           \u2013            <p>Additional attributes to add to all edges.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The result of adding the edges to the graph.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.has_edge","title":"<code>has_edge(src_node_id, tgt_node_id, src_node_type='', edge_type='', tgt_node_type='')</code>","text":"<p>Check if an edge exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str | int</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str | int</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source node type. Defaults to \"\".</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Type of the edge. Defaults to \"\".</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Target node type. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the edge exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.get_edge_data","title":"<code>get_edge_data(src_node_id, tgt_node_id, src_node_type='', edge_type='', tgt_node_type='')</code>","text":"<p>Get data of a specific edge.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source node type. Defaults to \"\".</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Type of the edge. Defaults to \"\".</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Target node type. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>Dict | None: The edge data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.degree","title":"<code>degree(node_id, node_type='', edge_types=[])</code>","text":"<p>Get the degree of a node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> <li> <code>edge_types</code>               (<code>List</code>, default:                   <code>[]</code> )           \u2013            <p>Types of edges to consider. Defaults to [].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The degree of the node.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.number_of_nodes","title":"<code>number_of_nodes(node_type=None)</code>","text":"<p>Get the number of nodes in the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of nodes to count. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of nodes.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.number_of_edges","title":"<code>number_of_edges(edge_type=None)</code>","text":"<p>Get the number of edges in the graph.</p> <p>Parameters:</p> <ul> <li> <code>edge_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of edges to count. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of edges.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.get_nodes","title":"<code>get_nodes(node_type='', filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Retrieve nodes from the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of nodes to retrieve. Defaults to \"\".</p> </li> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression. Defaults to None.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Limit the number of results. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>pd.DataFrame | None: DataFrame of nodes or None.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.get_neighbors","title":"<code>get_neighbors(start_nodes, start_node_type='', edge_types=None, target_node_types=None, filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Get neighbors of specified nodes.</p> <p>Parameters:</p> <ul> <li> <code>start_nodes</code>               (<code>str | List[str]</code>)           \u2013            <p>Starting node(s).</p> </li> <li> <code>start_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Type of starting nodes. Defaults to \"\".</p> </li> <li> <code>edge_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Types of edges to consider. Defaults to None.</p> </li> <li> <code>target_node_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Types of target nodes. Defaults to None.</p> </li> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression. Defaults to None.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of neighbors to retrieve. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>pd.DataFrame | None: DataFrame of neighbors or None.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.upsert","title":"<code>upsert(data, node_type)</code>","text":"<p>Upsert nodes to the specified node type in the graph. If data is a Dict, it processes one record, otherwise if it's a List, it processes multiple records.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Dict | List[Dict]</code>)           \u2013            <p>Data to be upserted, can either be a single record (Dict) or multiple records (List[Dict]).</p> </li> <li> <code>node_type</code>               (<code>str</code>)           \u2013            <p>The node type for the upsert operation.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The result of the upsert operation or None if an error occurs.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.search","title":"<code>search(data, vector_attribute_name, node_type='', limit=10)</code>","text":"<p>Perform a vector search to find the nearest nodes based on a query vector.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>List[float]</code>)           \u2013            <p>The query vector to use for the search.</p> </li> <li> <code>vector_attribute_name</code>               (<code>str</code>)           \u2013            <p>The name of the vector attribute to search against.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of node to search. Defaults to an empty string.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of nearest neighbors to return. Defaults to 10.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Dict]</code>           \u2013            <p>List[Dict]: A list of dictionaries, where each dictionary contains: - 'id': The node ID. - 'distance': The distance between the node and the query vector. - Any other attributes associated with the node.</p> </li> </ul>"},{"location":"reference/01_core/homograph/","title":"HomoGraph","text":""},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph","title":"<code>HomoGraph</code>","text":"<p>Represents a homogeneous graph with a single node and edge type.</p>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.__init__","title":"<code>__init__(graph_name, node_type, node_schema, edge_type, edge_schema, tigergraph_connection_config=None, drop_existing_graph=False)</code>","text":"<p>Initialize a HomoGraph instance.</p> <p>Parameters:</p> <ul> <li> <code>graph_name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>node_type</code>               (<code>str</code>)           \u2013            <p>The type of nodes in the graph.</p> </li> <li> <code>node_schema</code>               (<code>NodeSchema</code>)           \u2013            <p>The schema for the nodes.</p> </li> <li> <code>edge_type</code>               (<code>str</code>)           \u2013            <p>The type of edges in the graph.</p> </li> <li> <code>edge_schema</code>               (<code>EdgeSchema</code>)           \u2013            <p>The schema for the edges.</p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration for TigerGraph connection. Defaults to None.</p> </li> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to drop the existing graph if it exists. Defaults to False.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.add_node","title":"<code>add_node(node_id, **attr)</code>","text":"<p>Add a node to the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>**attr</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional attributes for the node.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.add_nodes_from","title":"<code>add_nodes_from(nodes_for_adding, **attr)</code>","text":"<p>Add nodes from the given list, with each node being either an ID or a tuple of ID and attributes.</p> <p>Parameters:</p> <ul> <li> <code>nodes_for_adding</code>               (<code>List[str] | List[Tuple[str, Dict[str, Any]]]</code>)           \u2013            <p>List of node IDs or tuples of node ID and attribute dictionaries.</p> </li> <li> <code>**attr</code>           \u2013            <p>Common attributes to be added to all nodes.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>None if there was an error; otherwise, it calls <code>upsertVertices</code> on the connection.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.remove_node","title":"<code>remove_node(node_id)</code>","text":"<p>Remove a node from the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the node was removed, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.has_node","title":"<code>has_node(node_id)</code>","text":"<p>Check if a node exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the node exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.get_node_data","title":"<code>get_node_data(node_id)</code>","text":"<p>Retrieve data of a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>Dict | None: The node data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.get_node_edges","title":"<code>get_node_edges(node_id, num_edge_samples=1000)</code>","text":"<p>Get edges connected to a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>num_edge_samples</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Number of edge samples to retrieve. Defaults to 1000.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List</code> (              <code>List</code> )          \u2013            <p>A list of edges as tuples.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.add_edge","title":"<code>add_edge(src_node_id, tgt_node_id, **attr)</code>","text":"<p>Add an edge to the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>**attr</code>           \u2013            <p>Additional attributes for the edge.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.add_edges_from","title":"<code>add_edges_from(ebunch_to_add, **attr)</code>","text":"<p>Adds edges to the graph from a list of edge tuples.</p> <p>Parameters:</p> <ul> <li> <code>ebunch_to_add</code>               (<code>List[Tuple[str, str]] | List[Tuple[str, str, Dict[str, Any]]]</code>)           \u2013            <p>List of edges to add, where each edge is a tuple of source and target node IDs, optionally with attributes.</p> </li> <li> <code>**attr</code>           \u2013            <p>Additional attributes to add to all edges.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The result of adding the edges to the graph.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.has_edge","title":"<code>has_edge(src_node_id, tgt_node_id)</code>","text":"<p>Check if an edge exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str | int</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str | int</code>)           \u2013            <p>Target node identifier.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the edge exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.get_edge_data","title":"<code>get_edge_data(src_node_id, tgt_node_id)</code>","text":"<p>Retrieve data of a specific edge.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>Dict | None: The edge data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.degree","title":"<code>degree(node_id)</code>","text":"<p>Get the degree of a node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The degree of the node.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.number_of_nodes","title":"<code>number_of_nodes()</code>","text":"<p>Get the total number of nodes in the graph.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of nodes.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.number_of_edges","title":"<code>number_of_edges()</code>","text":"<p>Get the total number of edges in the graph.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of edges.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.get_nodes","title":"<code>get_nodes(filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Retrieve nodes from the graph.</p> <p>Parameters:</p> <ul> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression to apply. Defaults to None.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of nodes to retrieve. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>pd.DataFrame | None: DataFrame of nodes or None.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.get_neighbors","title":"<code>get_neighbors(start_nodes, edge_types=None, target_node_types=None, filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Get neighbors of specified nodes.</p> <p>Parameters:</p> <ul> <li> <code>start_nodes</code>               (<code>str | List[str]</code>)           \u2013            <p>Starting node(s).</p> </li> <li> <code>edge_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Types of edges to consider. Defaults to None.</p> </li> <li> <code>target_node_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Types of target nodes. Defaults to None.</p> </li> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression to apply. Defaults to None.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of neighbors to retrieve. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>pd.DataFrame | None: DataFrame of neighbors or None.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.upsert","title":"<code>upsert(data)</code>","text":"<p>Upsert nodes the graph. If data is a Dict, it processes one record, otherwise if it's a List, it processes multiple records.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Dict | List[Dict]</code>)           \u2013            <p>Data to be upserted, can either be a single record (Dict) or multiple records (List[Dict]).</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The result of the upsert operation or None if an error occurs.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.search","title":"<code>search(data, vector_attribute_name, limit=10)</code>","text":"<p>Perform a vector search to find the nearest nodes based on a query vector.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>List[float]</code>)           \u2013            <p>The query vector to use for the search.</p> </li> <li> <code>vector_attribute_name</code>               (<code>str</code>)           \u2013            <p>The name of the vector attribute to search against.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of nearest neighbors to return. Defaults to 10.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Dict]</code>           \u2013            <p>List[Dict]: A list of dictionaries, where each dictionary contains: - 'id': The node ID. - 'distance': The distance between the node and the query vector. - Any other attributes associated with the node.</p> </li> </ul>"},{"location":"reference/01_core/nodeview/","title":"NodeView","text":""},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView","title":"<code>NodeView</code>","text":""},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve specific node data. - For homogeneous graphs: key is <code>node_id</code>. - For heterogeneous graphs: key is <code>(node_type, node_id)</code>.</p>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if a node exists.</p>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over all nodes. For homogeneous: return node_id. For heterogeneous: return (node_type, node_id).</p>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of nodes.</p>"},{"location":"reference/01_core/undigraph/","title":"UndiGraph","text":""},{"location":"reference/01_core/undigraph/#tigergraphx.core.graph.UndiGraph","title":"<code>UndiGraph</code>","text":"<p>               Bases: <code>HomoGraph</code></p> <p>Represents an undirected graph with a single node and edge type.</p>"},{"location":"reference/01_core/undigraph/#tigergraphx.core.graph.UndiGraph.__init__","title":"<code>__init__(graph_name, node_type='MyNode', edge_type='MyEdge', node_primary_key='id', node_attributes={'id': 'STRING', 'entity_type': 'STRING', 'description': 'STRING'}, edge_attributes={'weight': 'DOUBLE', 'description': 'STRING'}, tigergraph_connection_config=None, drop_existing_graph=False)</code>","text":"<p>Initialize an UndiGraph instance.</p> <p>Parameters:</p> <ul> <li> <code>graph_name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>'MyNode'</code> )           \u2013            <p>The type of nodes in the graph. Defaults to \"MyNode\".</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>'MyEdge'</code> )           \u2013            <p>The type of edges in the graph. Defaults to \"MyEdge\".</p> </li> <li> <code>node_primary_key</code>               (<code>str</code>, default:                   <code>'id'</code> )           \u2013            <p>The primary key for nodes. Defaults to \"id\".</p> </li> <li> <code>node_attributes</code>               (<code>AttributesType</code>, default:                   <code>{'id': 'STRING', 'entity_type': 'STRING', 'description': 'STRING'}</code> )           \u2013            <p>Attributes for nodes. Defaults to: <pre><code>{\n    \"id\": \"STRING\",\n    \"entity_type\": \"STRING\",\n    \"description\": \"STRING\",\n}\n</code></pre></p> </li> <li> <code>edge_attributes</code>               (<code>AttributesType</code>, default:                   <code>{'weight': 'DOUBLE', 'description': 'STRING'}</code> )           \u2013            <p>Attributes for edges. Defaults to: <pre><code>{\n    \"weight\": \"DOUBLE\",\n    \"description\": \"STRING\",\n}\n</code></pre></p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig | Dict | str | Path]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration for TigerGraph connection. Defaults to None.</p> </li> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to drop the existing graph if it exists. Defaults to False.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/","title":"BaseVectorDB","text":""},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB","title":"<code>BaseVectorDB</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for managing vector database connections.</p>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the base vector DB manager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseVectorDBConfig</code>)           \u2013            <p>Configuration for the vector database connection.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.insert_data","title":"<code>insert_data(data)</code>  <code>abstractmethod</code>","text":"<p>Insert data into the vector database.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>The data to be inserted.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.query","title":"<code>query(query_embedding, k=10)</code>  <code>abstractmethod</code>","text":"<p>Perform a similarity search by vector and return results in the desired format.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>The embedding vector to query.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of nearest neighbors to return. Defaults to 10.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: List of result identifiers.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/","title":"LanceDBManager","text":""},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager","title":"<code>LanceDBManager</code>","text":"<p>               Bases: <code>BaseVectorDB</code></p> <p>Implementation of LanceDB vector database management.</p>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the LanceDB manager by connecting and setting up schema.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>LanceDBConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for LanceDB, either as a config object, dictionary, string, or path to configuration file.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.connect","title":"<code>connect(uri, **kwargs)</code>","text":"<p>Connect to LanceDB and initialize or open the specified table.</p> <p>Parameters:</p> <ul> <li> <code>uri</code>               (<code>str | Path</code>)           \u2013            <p>The URI to connect to the LanceDB database.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional connection parameters.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.get_table","title":"<code>get_table()</code>","text":"<p>Retrieve the current table.</p> <p>Returns:</p> <ul> <li> <code>Table</code> (              <code>Table</code> )          \u2013            <p>The LanceDB table object.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.insert_data","title":"<code>insert_data(data)</code>","text":"<p>Insert data into the LanceDB table.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame containing the data to be inserted.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.query","title":"<code>query(query_embedding, k=10, **kwargs)</code>","text":"<p>Perform a similarity search by vector and return results as a list of IDs.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>The query vector for similarity search.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of top results to retrieve. Defaults to 10.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters for the search.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: List of IDs from the search results.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the table is not initialized or no results are found.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/","title":"NanoVectorDBManager","text":""},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager","title":"<code>NanoVectorDBManager</code>","text":"<p>               Bases: <code>BaseVectorDB</code></p> <p>A wrapper class for NanoVectorDB that implements BaseVectorDB.</p>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the NanoVectorDBWrapper.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>NanoVectorDBConfig</code>)           \u2013            <p>Configuration for NanoVectorDB.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.insert_data","title":"<code>insert_data(data)</code>","text":"<p>Insert data into NanoVectorDB.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame containing the data to insert.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.query","title":"<code>query(query_embedding, k=10)</code>","text":"<p>Perform a similarity search and return results.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>Query embedding vector for similarity search.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of top results to retrieve. Defaults to 10.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: List of IDs from the search results.</p> </li> </ul>"},{"location":"reference/02_vector_search/02_embedding/base_embedding/","title":"BaseEmbedding","text":""},{"location":"reference/02_vector_search/02_embedding/base_embedding/#tigergraphx.vector_search.embedding.BaseEmbedding","title":"<code>BaseEmbedding</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for text embedding models.</p>"},{"location":"reference/02_vector_search/02_embedding/base_embedding/#tigergraphx.vector_search.embedding.BaseEmbedding.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the base embedding model.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseEmbeddingConfig</code>)           \u2013            <p>Configuration for the embedding model.</p> </li> </ul>"},{"location":"reference/02_vector_search/02_embedding/base_embedding/#tigergraphx.vector_search.embedding.BaseEmbedding.generate_embedding","title":"<code>generate_embedding(text)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Asynchronously generate embeddings for a given text.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The input text to generate embeddings for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>List[float]: A list of floats representing the text embedding.</p> </li> </ul>"},{"location":"reference/02_vector_search/02_embedding/openai_embedding/","title":"OpenAIEmbedding","text":""},{"location":"reference/02_vector_search/02_embedding/openai_embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding","title":"<code>OpenAIEmbedding</code>","text":"<p>               Bases: <code>BaseEmbedding</code>, <code>RetryMixin</code></p> <p>OpenAI Embedding model wrapper with async embedding generation and robust retries.</p>"},{"location":"reference/02_vector_search/02_embedding/openai_embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding.__init__","title":"<code>__init__(llm_manager, config)</code>","text":"<p>Initialize the OpenAI Embedding wrapper.</p> <p>Parameters:</p> <ul> <li> <code>llm_manager</code>               (<code>OpenAIManager</code>)           \u2013            <p>Manager for OpenAI LLM interactions.</p> </li> <li> <code>config</code>               (<code>OpenAIEmbeddingConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for the embedding model.</p> </li> </ul>"},{"location":"reference/02_vector_search/02_embedding/openai_embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding.generate_embedding","title":"<code>generate_embedding(text)</code>  <code>async</code>","text":"<p>Generate embedding asynchronously with retry for robustness.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The input text to generate embeddings for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>List[float]: The normalized embedding vector.</p> </li> </ul>"},{"location":"reference/02_vector_search/03_search/base_search_engine/","title":"BaseSearchEngine","text":""},{"location":"reference/02_vector_search/03_search/base_search_engine/#tigergraphx.vector_search.search.BaseSearchEngine","title":"<code>BaseSearchEngine</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for a search engine that performs text-to-vector searches in a vector store.</p>"},{"location":"reference/02_vector_search/03_search/base_search_engine/#tigergraphx.vector_search.search.BaseSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the search engine with an embedding model and a vector database.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>BaseEmbedding</code>)           \u2013            <p>The model used to generate text embeddings.</p> </li> <li> <code>vector_db</code>               (<code>BaseVectorDB</code>)           \u2013            <p>The vector database for storing and querying embeddings.</p> </li> </ul>"},{"location":"reference/02_vector_search/03_search/base_search_engine/#tigergraphx.vector_search.search.BaseSearchEngine.search","title":"<code>search(text, k=10, **kwargs)</code>  <code>async</code>","text":"<p>Convert text to embedding and search in the vector database.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The input text to search.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of top results to return. Defaults to 10.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments for the vector database query.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of IDs corresponding to the search results.</p> </li> </ul>"},{"location":"reference/02_vector_search/03_search/lancedb_search_engine/","title":"LanceDBSearchEngine","text":""},{"location":"reference/02_vector_search/03_search/lancedb_search_engine/#tigergraphx.vector_search.search.LanceDBSearchEngine","title":"<code>LanceDBSearchEngine</code>","text":"<p>               Bases: <code>BaseSearchEngine</code></p> <p>Search engine that performs text embedding and similarity search using OpenAI and LanceDB.</p>"},{"location":"reference/02_vector_search/03_search/lancedb_search_engine/#tigergraphx.vector_search.search.LanceDBSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the LanceDBSearchEngine.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>OpenAIEmbedding</code>)           \u2013            <p>The embedding model used for text-to-vector conversion.</p> </li> <li> <code>vector_db</code>               (<code>LanceDBManager</code>)           \u2013            <p>The vector database for similarity search.</p> </li> </ul>"},{"location":"reference/02_vector_search/03_search/nano_vectordb_search_engine/","title":"NanoVectorDBSearchEngine","text":""},{"location":"reference/02_vector_search/03_search/nano_vectordb_search_engine/#tigergraphx.vector_search.search.NanoVectorDBSearchEngine","title":"<code>NanoVectorDBSearchEngine</code>","text":"<p>               Bases: <code>BaseSearchEngine</code></p> <p>Search engine that performs text embedding and similarity search using OpenAI and NanoVectorDB.</p>"},{"location":"reference/02_vector_search/03_search/nano_vectordb_search_engine/#tigergraphx.vector_search.search.NanoVectorDBSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the NanoVectorDBSearchEngine.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>OpenAIEmbedding</code>)           \u2013            <p>The embedding model used for text-to-vector conversion.</p> </li> <li> <code>vector_db</code>               (<code>NanoVectorDBManager</code>)           \u2013            <p>The vector database for similarity search.</p> </li> </ul>"},{"location":"reference/03_llm/base_llm_manager/","title":"BaseLLMManager","text":""},{"location":"reference/03_llm/base_llm_manager/#tigergraphx.llm.BaseLLMManager","title":"<code>BaseLLMManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for LLM implementations.</p>"},{"location":"reference/03_llm/base_llm_manager/#tigergraphx.llm.BaseLLMManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the base LLM manager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseLLMConfig</code>)           \u2013            <p>Configuration for the LLM.</p> </li> </ul>"},{"location":"reference/03_llm/base_llm_manager/#tigergraphx.llm.BaseLLMManager.get_llm","title":"<code>get_llm()</code>  <code>abstractmethod</code>","text":"<p>Retrieve the initialized LLM instance.</p> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The initialized LLM instance.</p> </li> </ul>"},{"location":"reference/03_llm/openai_manager/","title":"OpenAIManager","text":""},{"location":"reference/03_llm/openai_manager/#tigergraphx.llm.OpenAIManager","title":"<code>OpenAIManager</code>","text":"<p>               Bases: <code>BaseLLMManager</code></p> <p>Manages an asynchronous OpenAI instance for LLM operations.</p>"},{"location":"reference/03_llm/openai_manager/#tigergraphx.llm.OpenAIManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize OpenAIManager with OpenAI settings.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>OpenAIConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for OpenAI settings.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the API key is not provided in the configuration.</p> </li> </ul>"},{"location":"reference/03_llm/openai_manager/#tigergraphx.llm.OpenAIManager.get_llm","title":"<code>get_llm()</code>","text":"<p>Retrieve the initialized async OpenAI instance.</p> <p>Returns:</p> <ul> <li> <code>AsyncOpenAI</code> (              <code>AsyncOpenAI</code> )          \u2013            <p>The initialized OpenAI instance.</p> </li> </ul>"},{"location":"reference/03_llm/01_chat/base_chat/","title":"BaseChat","text":""},{"location":"reference/03_llm/01_chat/base_chat/#tigergraphx.llm.chat.BaseChat","title":"<code>BaseChat</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for chat models.</p>"},{"location":"reference/03_llm/01_chat/base_chat/#tigergraphx.llm.chat.BaseChat.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the chat model with the given configuration.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseChatConfig</code>)           \u2013            <p>Configuration for the chat model.</p> </li> </ul>"},{"location":"reference/03_llm/01_chat/base_chat/#tigergraphx.llm.chat.BaseChat.chat","title":"<code>chat(messages)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Asynchronously process the messages and return the generated response.</p> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>List[Any]</code>)           \u2013            <p>A list of messages to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The generated response.</p> </li> </ul>"},{"location":"reference/03_llm/01_chat/openai_chat/","title":"OpenAIChat","text":""},{"location":"reference/03_llm/01_chat/openai_chat/#tigergraphx.llm.chat.OpenAIChat","title":"<code>OpenAIChat</code>","text":"<p>               Bases: <code>BaseChat</code>, <code>RetryMixin</code></p> <p>Implementation of BaseChat for OpenAI models.</p>"},{"location":"reference/03_llm/01_chat/openai_chat/#tigergraphx.llm.chat.OpenAIChat.__init__","title":"<code>__init__(llm_manager, config)</code>","text":"<p>Initialize the OpenAIChat with the provided LLM manager and configuration.</p> <p>Parameters:</p> <ul> <li> <code>llm_manager</code>               (<code>OpenAIManager</code>)           \u2013            <p>Manager for OpenAI LLM interactions.</p> </li> <li> <code>config</code>               (<code>OpenAIChatConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for OpenAI chat.</p> </li> </ul>"},{"location":"reference/03_llm/01_chat/openai_chat/#tigergraphx.llm.chat.OpenAIChat.chat","title":"<code>chat(messages)</code>  <code>async</code>","text":"<p>Asynchronously process the messages and return the generated response.</p> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>List[ChatCompletionMessageParam]</code>)           \u2013            <p>List of messages for chat completion.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The generated response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RetryError</code>             \u2013            <p>If retry attempts are exhausted.</p> </li> <li> <code>Exception</code>             \u2013            <p>For any unexpected errors during processing.</p> </li> </ul>"},{"location":"reference/04_config/base_config/","title":"BaseConfig","text":""},{"location":"reference/04_config/base_config/#tigergraphx.config.BaseConfig","title":"<code>BaseConfig</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Base configuration class that extends Pydantic's BaseSettings. Provides utility methods to load configurations from various sources.</p>"},{"location":"reference/04_config/base_config/#tigergraphx.config.BaseConfig.ensure_config","title":"<code>ensure_config(config)</code>  <code>classmethod</code>","text":"<p>Ensure the config is an instance of the current config class.</p> <p>If the input is a dictionary, string, or path to a YAML/JSON file, it is loaded and converted into an instance of the class.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>T | Path | str | Dict</code>)           \u2013            <p>The input configuration, which can be an instance of the config class, a dictionary, a file path, or a string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>An instance of the current configuration class.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the provided file path does not exist.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the file type is unsupported.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If the input type is not supported.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/loading_job_config/","title":"Loading Job Configuration","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig","title":"<code>LoadingJobConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for a loading job consisting of multiple files.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.loading_job_name","title":"<code>loading_job_name = Field(description='The name of the loading job.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.files","title":"<code>files = Field(description='A list of files included in the loading job.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.validate_file_aliases","title":"<code>validate_file_aliases(values)</code>","text":"<p>Ensure that all file_alias values are unique.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig","title":"<code>FileConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for a single file used in a loading job.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.file_alias","title":"<code>file_alias = Field(description='An alias for the file, used as a reference.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.file_path","title":"<code>file_path = Field(default=None, description='The path to the file on disk.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.csv_parsing_options","title":"<code>csv_parsing_options = Field(default_factory=CsvParsingOptions, description='Options for parsing the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.node_mappings","title":"<code>node_mappings = Field(default=[], description='Node mappings defined for this file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.edge_mappings","title":"<code>edge_mappings = Field(default=[], description='Edge mappings defined for this file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.validate_mappings","title":"<code>validate_mappings(values)</code>","text":"<p>Ensure that at least one mapping (node or edge) exists.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions","title":"<code>CsvParsingOptions</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration options for CSV parsing.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.separator","title":"<code>separator = Field(default=',', description='The separator used in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.header","title":"<code>header = Field(default=True, description='Whether the CSV file contains a header row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.EOL","title":"<code>EOL = Field(default='\\\\n', description='The end-of-line character in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.quote","title":"<code>quote = Field(default=QuoteType.DOUBLE, description='The type of quote used in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig","title":"<code>NodeMappingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for mapping node attributes from a file to the target schema.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig.target_name","title":"<code>target_name = Field(description='The name of the target node type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig.attribute_column_mappings","title":"<code>attribute_column_mappings = Field(default={}, description='Mapping file columns to node attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig","title":"<code>EdgeMappingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for mapping edge attributes from a file to the target schema.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.target_name","title":"<code>target_name = Field(description='The target edge type name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.source_node_column","title":"<code>source_node_column = Field(description='The column representing the source node in the file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.target_node_column","title":"<code>target_node_column = Field(description='The column representing the target node in the file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.attribute_column_mappings","title":"<code>attribute_column_mappings = Field(default={}, description='Mappings between file columns and edge attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/","title":"Schema Configuration","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema","title":"<code>GraphSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph, including nodes and edges.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.graph_name","title":"<code>graph_name = Field(description='The name of the graph.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.nodes","title":"<code>nodes = Field(description='A dictionary of node type names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.edges","title":"<code>edges = Field(description='A dictionary of edge type names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.validate_edge_references","title":"<code>validate_edge_references(values)</code>","text":"<p>Ensure all edges reference existing nodes in the graph schema.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema","title":"<code>NodeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph node type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.primary_key","title":"<code>primary_key = Field(description='The primary key for the node type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.attributes","title":"<code>attributes = Field(default_factory=dict, description='A dictionary of attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.vector_attributes","title":"<code>vector_attributes = Field(default_factory=dict, description='A dictionary of vector attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.parse_attributes","title":"<code>parse_attributes(values)</code>","text":"<p>Parse shorthand attributes into full AttributeSchema.</p> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Input values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: Parsed values with attributes as AttributeSchema.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.validate_primary_key_and_attributes","title":"<code>validate_primary_key_and_attributes(values)</code>","text":"<p>Validate that the primary key is present in attributes.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema","title":"<code>EdgeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph edge type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.is_directed_edge","title":"<code>is_directed_edge = Field(default=False, description='Whether the edge is directed.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.from_node_type","title":"<code>from_node_type = Field(description='The type of the source node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.to_node_type","title":"<code>to_node_type = Field(description='The type of the target node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.edge_identifier","title":"<code>edge_identifier = Field(default_factory=set, description='An attribute or set of attributes that uniquely identifies an edge in a graph,distinguishing it from other edges with the same source and target.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.attributes","title":"<code>attributes = Field(default_factory=dict, description='A dictionary of attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.parse_attributes","title":"<code>parse_attributes(values)</code>","text":"<p>Parse shorthand attributes into full AttributeSchema.</p> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Input values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: Parsed values with attributes as AttributeSchema.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.validate_edge_identifier_and_attributes","title":"<code>validate_edge_identifier_and_attributes(values)</code>","text":"<p>Validate that the every edge_identifier is present in attributes.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema","title":"<code>AttributeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph attribute.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.data_type","title":"<code>data_type = Field(description='The data type of the attribute.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.default_value","title":"<code>default_value = Field(default=None, description='The default value for the attribute.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.PYTHON_TYPES","title":"<code>PYTHON_TYPES = {DataType.INT: int, DataType.UINT: int, DataType.FLOAT: (float, int), DataType.DOUBLE: (float, int), DataType.BOOL: bool, DataType.STRING: str, DataType.DATETIME: str}</code>  <code>class-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.validate_default_value","title":"<code>validate_default_value()</code>","text":"<p>Validate that the default value matches the expected data type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema","title":"<code>VectorAttributeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a vector attribute.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.dimension","title":"<code>dimension = Field(ge=1, default=1536, description='The dimension of the vector attribute. Must be at least 1.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.index_type","title":"<code>index_type = Field(default='HNSW', description='The index type for the vector attribute. Currently only \"HNSW\" is supported.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.data_type","title":"<code>data_type = Field(default='FLOAT', description='The data type of the attribute. Currently only \"FLOAT\" is supported. Future types may include \"DOUBLE\", \"HALF\", or \"BYTE\".')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.metric","title":"<code>metric = Field(default='COSINE', description='The metric used for distance calculations. Can be \"COSINE\", \"IP\" (inner product), or \"L2\".')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType","title":"<code>DataType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported data types.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.INT","title":"<code>INT = 'INT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.UINT","title":"<code>UINT = 'UINT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.FLOAT","title":"<code>FLOAT = 'FLOAT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.DOUBLE","title":"<code>DOUBLE = 'DOUBLE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.BOOL","title":"<code>BOOL = 'BOOL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.STRING","title":"<code>STRING = 'STRING'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.DATETIME","title":"<code>DATETIME = 'DATETIME'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/","title":"TigerGraphConnectionConfig","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig","title":"<code>TigerGraphConnectionConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for connecting to a TigerGraph instance.</p> <p>This class supports: 1. User/password authentication 2. Secret-based authentication 3. Token-based authentication</p>"},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.host","title":"<code>host = Field(default=HttpUrl('http://127.0.0.1'), description='The host URL for the TigerGraph connection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.restpp_port","title":"<code>restpp_port = Field(default='14240', description='The port for REST++ API.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.gsql_port","title":"<code>gsql_port = Field(default='14240', description='The port for GSQL.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.username","title":"<code>username = Field(default='tigergraph', description='The username for TigerGraph authentication. Use only for user/password authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.password","title":"<code>password = Field(default='tigergraph', description='The password for TigerGraph authentication. Use only for user/password authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.secret","title":"<code>secret = Field(default=None, description='The secret for TigerGraph authentication. Use only for secret-based authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.token","title":"<code>token = Field(default=None, description='The API token for TigerGraph authentication. Use only for token-based authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.check_exclusive_authentication","title":"<code>check_exclusive_authentication(values)</code>","text":"<p>Ensure that exactly one authentication method is provided: - username/password together, or - secret, or - token. If all fields are empty, username/password will default.</p>"},{"location":"reference/04_config/02_query/neighbor_spec/","title":"NeighborSpec","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec","title":"<code>NeighborSpec</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Specification for selecting neighbors in a graph query.</p>"},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.start_nodes","title":"<code>start_nodes = Field(..., description='List of starting node IDs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.start_node_type","title":"<code>start_node_type = Field(..., description='The type of the start node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.edge_types","title":"<code>edge_types = Field(None, description='List of allowed edge types for traversal.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.target_node_types","title":"<code>target_node_types = Field(None, description='List of allowed target node types.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.filter_expression","title":"<code>filter_expression = Field(None, description='A string defining complex filtering logic.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.return_attributes","title":"<code>return_attributes = Field(None, description='List of attributes to include in the results.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.limit","title":"<code>limit = Field(None, description='Maximum number of results to return.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/","title":"NodeSpec","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec","title":"<code>NodeSpec</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Specification for selecting nodes in a graph query.</p>"},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.node_type","title":"<code>node_type = Field(..., description='The type of nodes to select.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.filter_expression","title":"<code>filter_expression = Field(None, description='A string defining filtering logic for the node selection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.return_attributes","title":"<code>return_attributes = Field(None, description='List of attributes to include in the output.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.limit","title":"<code>limit = Field(None, description='Maximum number of nodes to select.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/","title":"Chat Settings","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.BaseChatConfig","title":"<code>BaseChatConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for chat models.</p>"},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.BaseChatConfig.type","title":"<code>type = Field(description='Mandatory base type; derived classes can override or set a default.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig","title":"<code>OpenAIChatConfig</code>","text":"<p>               Bases: <code>BaseChatConfig</code></p> <p>Configuration class for OpenAI Chat models.</p>"},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.type","title":"<code>type = Field(default='OpenAI', description='Default type for OpenAIChatConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.model","title":"<code>model = Field(default='gpt-4o-mini', description='Default OpenAI model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.max_retries","title":"<code>max_retries = Field(default=10, description='Maximum number of retries for API calls.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/","title":"Embedding Settings","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.BaseEmbeddingConfig","title":"<code>BaseEmbeddingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for embedding models.</p>"},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.BaseEmbeddingConfig.type","title":"<code>type = Field(description='Mandatory base type; derived classes can override or set a default.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig","title":"<code>OpenAIEmbeddingConfig</code>","text":"<p>               Bases: <code>BaseEmbeddingConfig</code></p> <p>Configuration class for OpenAI Embedding models.</p>"},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.type","title":"<code>type = Field(default='OpenAI', description='Default type for OpenAIEmbeddingConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.model","title":"<code>model = Field(default='text-embedding-3-small', description='Default OpenAI embedding model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.max_tokens","title":"<code>max_tokens = Field(default=8191, description='Maximum number of tokens supported.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.max_retries","title":"<code>max_retries = Field(default=10, description='Maximum number of retries for API calls.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.encoding_name","title":"<code>encoding_name = Field(default='cl100k_base', description='Token encoding name used by the model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/","title":"LLM Settings","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.BaseLLMConfig","title":"<code>BaseLLMConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for LLM.</p>"},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.BaseLLMConfig.type","title":"<code>type = Field(description='Mandatory type field for identifying the LLM type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig","title":"<code>OpenAIConfig</code>","text":"<p>               Bases: <code>BaseLLMConfig</code></p> <p>Configuration class for OpenAI.</p>"},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.type","title":"<code>type = Field(default='OpenAI', description='Default type for OpenAIConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.api_key","title":"<code>api_key = Field(alias='OPENAI_API_KEY', description='API key for authentication with OpenAI.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.base_url","title":"<code>base_url = Field(default=None, description='Custom base URL for OpenAI API.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.organization","title":"<code>organization = Field(default=None, description='OpenAI organization ID (if applicable).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.max_retries","title":"<code>max_retries = Field(default=10, description='Maximum number of retries for failed API requests.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.request_timeout","title":"<code>request_timeout = Field(default=180.0, description='Request timeout in seconds.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/","title":"Settings","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Application settings, including configurations for vector databases, LLMs, embeddings, and chat models.</p>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.vector_db","title":"<code>vector_db = Field(description='Configuration for the vector database.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.llm","title":"<code>llm = Field(description='Configuration for the language model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.embedding","title":"<code>embedding = Field(description='Configuration for the embedding model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.chat","title":"<code>chat = Field(description='Configuration for the chat model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_vector_db","title":"<code>validate_vector_db(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the vector_db field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the vector database.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseVectorDBConfig</code> (              <code>BaseVectorDBConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of vector database is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_llm","title":"<code>validate_llm(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the llm field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the language model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseLLMConfig</code> (              <code>BaseLLMConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of language model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_embedding","title":"<code>validate_embedding(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the embedding field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the embedding model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseEmbeddingConfig</code> (              <code>BaseEmbeddingConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of embedding model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_chat","title":"<code>validate_chat(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the chat field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the chat model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseChatConfig</code> (              <code>BaseChatConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of chat model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/vector_db_settings/","title":"Vector DB Settings","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.BaseVectorDBConfig","title":"<code>BaseVectorDBConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for vector databases.</p>"},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.BaseVectorDBConfig.type","title":"<code>type = Field(description='Mandatory type field to identify the database type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig","title":"<code>LanceDBConfig</code>","text":"<p>               Bases: <code>BaseVectorDBConfig</code></p> <p>Configuration class for LanceDB.</p>"},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.type","title":"<code>type = Field(default='LanceDB', description='Default type for LanceDBConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.table_name","title":"<code>table_name = Field(default='entity_description_embeddings', description='Default table name for embeddings.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.uri","title":"<code>uri = Field(description='URI or path to the LanceDB resource.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.api_key","title":"<code>api_key = Field(default=None, description='API key for authentication, if required.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.region","title":"<code>region = Field(default='us-east-1', description='Default region for LanceDB.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.host_override","title":"<code>host_override = Field(default=None, description='Host override for custom LanceDB endpoints.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.read_consistency_interval","title":"<code>read_consistency_interval = Field(default=None, description='Read consistency interval for queries.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.request_thread_pool","title":"<code>request_thread_pool = Field(default=None, description='Thread pool for managing requests.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig","title":"<code>NanoVectorDBConfig</code>","text":"<p>               Bases: <code>BaseVectorDBConfig</code></p> <p>Configuration class for NanoVectorDB.</p>"},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.type","title":"<code>type = Field(default='NanoVectorDB', description='Default type for NanoVectorDBConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.storage_file","title":"<code>storage_file = Field(default='nano-vectordb.json', description='Path to the storage file for NanoVectorDB.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.embedding_dim","title":"<code>embedding_dim = Field(default=1536, description='Default embedding dimension for NanoVectorDB.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/05_graphrag/base_context_builder/","title":"BaseContextBuilder","text":""},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder","title":"<code>BaseContextBuilder</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for building context using graph data and a search engine.</p> <p>Attributes:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>The graph object.</p> </li> <li> <code>single_batch</code>               (<code>bool</code>)           \u2013            <p>Whether to process data in a single batch.</p> </li> <li> <code>search_engine</code>               (<code>Optional[BaseSearchEngine]</code>)           \u2013            <p>The search engine for retrieving top-k objects.</p> </li> <li> <code>token_encoder</code>               (<code>Encoding</code>)           \u2013            <p>Token encoder for text tokenization.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.__init__","title":"<code>__init__(graph, single_batch, search_engine=None, token_encoder=None)</code>","text":"<p>Initialize the BaseContextBuilder.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>The graph object.</p> </li> <li> <code>single_batch</code>               (<code>bool</code>)           \u2013            <p>Whether to process data in a single batch.</p> </li> <li> <code>search_engine</code>               (<code>Optional[BaseSearchEngine]</code>, default:                   <code>None</code> )           \u2013            <p>The search engine for similarity searches.</p> </li> <li> <code>token_encoder</code>               (<code>Optional[Encoding]</code>, default:                   <code>None</code> )           \u2013            <p>Token encoder for text tokenization. Defaults to \"cl100k_base\".</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.build_context","title":"<code>build_context(*args, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to build context.</p> <p>Returns:</p> <ul> <li> <code>str | List[str]</code>           \u2013            <p>str | List[str]: The generated context as a string or list of strings.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.batch_and_convert_to_text","title":"<code>batch_and_convert_to_text(graph_data, section_name, single_batch=False, max_tokens=12000)</code>","text":"<p>Convert graph data to a formatted string or list of strings in batches based on token count.</p> <p>Parameters:</p> <ul> <li> <code>graph_data</code>               (<code>DataFrame</code>)           \u2013            <p>The graph data to convert.</p> </li> <li> <code>section_name</code>               (<code>str</code>)           \u2013            <p>The section name for the header.</p> </li> <li> <code>single_batch</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to process data in a single batch. Defaults to False.</p> </li> <li> <code>max_tokens</code>               (<code>int</code>, default:                   <code>12000</code> )           \u2013            <p>Maximum number of tokens per batch. Defaults to 12000.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | List[str]</code>           \u2013            <p>str | List[str]: The formatted graph data as a string or list of strings.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.retrieve_top_k_objects","title":"<code>retrieve_top_k_objects(query, k=10, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the top-k objects most similar to the query.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>str</code>)           \u2013            <p>The query string.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of top results to retrieve. Defaults to 10.</p> </li> <li> <code>**kwargs</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters for the search engine.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of the top-k results.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>k</code> is less than or equal to 0 or if the search engine is not initialized.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/","title":"ParquetProcessor","text":""},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor","title":"<code>ParquetProcessor</code>","text":"<p>A class to process Parquet files and generate CSV files with custom transformations.</p>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.__init__","title":"<code>__init__(input_dir, output_dir)</code>","text":"<p>Initialize the ParquetProcessor with input and output directories.</p> <p>Parameters:</p> <ul> <li> <code>input_dir</code>               (<code>str | Path</code>)           \u2013            <p>Directory containing the input Parquet files.</p> </li> <li> <code>output_dir</code>               (<code>str | Path</code>)           \u2013            <p>Directory to save the output CSV files.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.save_dataframe_to_csv","title":"<code>save_dataframe_to_csv(df, csv_file_name)</code>","text":"<p>Save a DataFrame or Series to a CSV file with specific formatting.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame | Series</code>)           \u2013            <p>The DataFrame or Series to save.</p> </li> <li> <code>csv_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.convert_parquet_to_csv","title":"<code>convert_parquet_to_csv(parquet_file_name, columns, csv_file_name)</code>","text":"<p>Convert a Parquet file to a CSV file with specific columns.</p> <p>Parameters:</p> <ul> <li> <code>parquet_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the input Parquet file.</p> </li> <li> <code>columns</code>               (<code>List[str]</code>)           \u2013            <p>List of columns to include in the output CSV.</p> </li> <li> <code>csv_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.create_relationship_file","title":"<code>create_relationship_file(df, element_list_name, element_name, collection_name, collection_new_name, output_name)</code>","text":"<p>Generate a CSV file for relationship mapping based on input DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>Input DataFrame containing relationship data.</p> </li> <li> <code>element_list_name</code>               (<code>str</code>)           \u2013            <p>Name of the column containing element lists.</p> </li> <li> <code>element_name</code>               (<code>str</code>)           \u2013            <p>Name of the element to map.</p> </li> <li> <code>collection_name</code>               (<code>str</code>)           \u2013            <p>Name of the collection column.</p> </li> <li> <code>collection_new_name</code>               (<code>str</code>)           \u2013            <p>New name for the collection in the output.</p> </li> <li> <code>output_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.process_parquet_files","title":"<code>process_parquet_files(configs)</code>","text":"<p>Process a list of Parquet file configurations and convert them to CSV.</p> <p>Parameters:</p> <ul> <li> <code>configs</code>               (<code>List[Dict[str, Any]]</code>)           \u2013            <p>List of configuration dictionaries for processing Parquet files.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.process_relationship_files","title":"<code>process_relationship_files(configs)</code>","text":"<p>Process a list of relationship file configurations and generate CSV files.</p> <p>Parameters:</p> <ul> <li> <code>configs</code>               (<code>List[Dict[str, Any]]</code>)           \u2013            <p>List of configuration dictionaries for generating relationship files.</p> </li> </ul>"},{"location":"reference/07_utils/retry_mixin/","title":"RetryMixin","text":""},{"location":"reference/07_utils/retry_mixin/#tigergraphx.utils.RetryMixin","title":"<code>RetryMixin</code>","text":"<p>Mixin for initializing a retry mechanism.</p>"},{"location":"reference/07_utils/retry_mixin/#tigergraphx.utils.RetryMixin.initialize_retryer","title":"<code>initialize_retryer(max_retries, max_wait)</code>","text":"<p>Initialize the retry mechanism.</p> <p>Parameters:</p> <ul> <li> <code>max_retries</code>               (<code>int</code>)           \u2013            <p>Maximum number of retry attempts.</p> </li> <li> <code>max_wait</code>               (<code>int</code>)           \u2013            <p>Maximum wait time between retries in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncRetrying</code> (              <code>AsyncRetrying</code> )          \u2013            <p>Configured retrying instance.</p> </li> </ul>"}]}