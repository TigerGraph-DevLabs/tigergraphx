{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to TigerGraphX","text":"<p>TigerGraphX is a high-level Python library offering a unified, Python-native interface for graph databases, advanced analytics, and GraphRAG workflows. Combining the simplicity of NetworkX with the advanced capabilities of TigerGraph, including tgCloud, it empowers Python developers to harness the power of graphs without the need to learn query languages like Cypher or GSQL.</p> <p>TigerGraphX is designed for two main audiences, catering to different use cases while maintaining an easy-to-use, developer-friendly experience:</p>"},{"location":"#who-should-use-tigergraphx","title":"Who Should Use TigerGraphX?","text":""},{"location":"#1-python-developers-for-graph-analytics-with-tigergraph","title":"1. Python Developers for Graph Analytics with TigerGraph","text":"<p>If you\u2019re a Python developer interested in performing graph analytics with TigerGraph, TigerGraphX provides:</p> <ul> <li>Python-Native APIs: No need to learn complex query languages like GSQL or Cypher.</li> <li>Seamless Integration: Easily perform CRUD operations, multi-hop queries, and advanced analytics directly from Python.</li> <li>Scalability: Leverage the powerful performance of TigerGraph for large-scale graph processing.</li> </ul> <p>Start here:</p> <ul> <li>Introduction to TigerGraphX: Discover the features and benefits of using TigerGraphX for graph database management and analytics.</li> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>Quick Start Guide: Quickly set up TigerGraphX and build your first graph with this step-by-step guide.</li> </ul>"},{"location":"#2-python-developers-for-graphrag-workflows","title":"2. Python Developers for GraphRAG Workflows","text":"<p>If you\u2019re a Python developer building GraphRAG applications, TigerGraphX enables you to:</p> <ul> <li>Use TigerGraph as a scalable database for storing and retrieving graph and vector data generated by GraphRAG algorithms.</li> <li>Build token-aware LLM workflows for advanced AI applications.</li> <li>Utilize context builders to streamline data preparation for large language models.</li> </ul> <p>Start here:</p> <ul> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>GraphRAG Overview: Explore how TigerGraphX integrates with GraphRAG workflows.</li> <li>Supporting Microsoft\u2019s GraphRAG: An example of using TigerGraphX for GraphRAG workflows.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"introduction/","title":"TigerGraphX: Unified Graph Solutions for Python Developers","text":""},{"location":"introduction/#what-is-tigergraphx","title":"What is TigerGraphX?","text":"<p>TigerGraphX is a high-level Python library offering a unified, Python-native interface for graph databases, advanced analytics, and GraphRAG workflows. Combining the simplicity of NetworkX with the advanced capabilities of TigerGraph, including tgCloud, it empowers Python developers to harness the power of graphs without the need to learn query languages like Cypher or GSQL.</p>"},{"location":"introduction/#core-mission","title":"Core Mission","text":"<p>TigerGraphX seeks to democratize graph technology by providing an intuitive, all-encompassing framework that integrates and provides direct connection to:</p> <ul> <li>TigerGraph Database capabilities</li> <li>TigerGraph Vector Database functionality</li> <li>Large Language Model (LLM) integration</li> <li>TigerGraph\u2019s GraphRAG support for intelligent workflow</li> </ul>"},{"location":"introduction/#key-features","title":"Key Features","text":""},{"location":"introduction/#1-schema-management","title":"1. Schema Management","text":"<ul> <li>Easily create and modify schemas using YAML, JSON, or Python dictionaries.</li> <li>No GSQL knowledge is required.</li> <li>Pythonic tools for designing database structures effortlessly.</li> </ul>"},{"location":"introduction/#2-data-loading","title":"2. Data Loading","text":"<ul> <li>Automated loading jobs for streamlined data imports.</li> <li>High-efficiency workflows with support for Parquet files.</li> <li>Simplified data ingestion processes for faster setup.</li> </ul>"},{"location":"introduction/#3-graph-library-interface","title":"3. Graph Library Interface","text":"<ul> <li>Python-native APIs for CRUD operations.</li> <li>Comprehensive tools for graph reporting and visualization.</li> <li>Built-in graph algorithms including centrality, community detection, and path analysis algorithms</li> </ul>"},{"location":"introduction/#4-graph-query-interface","title":"4. Graph Query Interface","text":"<ul> <li>Simplified advanced querying with intuitive APIs.</li> <li>Seamless integration into analytics workflows via DataFrame outputs.</li> <li>Support for advanced multi-hop query traversal and manipulation</li> </ul>"},{"location":"introduction/#5-vector-search-capabilities","title":"5. Vector Search Capabilities","text":"<ul> <li>AI-driven applications with integrated vector embeddings.</li> <li>Efficient top-K entity retrieval for enhanced intelligence.</li> <li>Ideal for recommendation systems and contextual analysis.</li> </ul>"},{"location":"introduction/#6-llm-integration-and-graphrag-support","title":"6. LLM Integration and GraphRAG support","text":"<ul> <li>Full support for GraphRAG workflows.</li> <li>Flexible, token-aware context builders for advanced applications.</li> <li>Tools for token optimization and seamless LLM integration.</li> </ul>"},{"location":"introduction/#7-machine-learning-ready-planned-feature","title":"7. Machine Learning Ready [Planned Feature]","text":"<ul> <li>Seamless integration with popular ML libraries</li> <li>Graph feature extraction</li> <li>Native support for graph neural networks (GNNs)</li> </ul>"},{"location":"introduction/#why-choose-tigergraphx","title":"Why Choose TigerGraphX?","text":"<p>TigerGraphX redefines graph technology by making advanced and powerful graph operations accessible and intuitive for Python developers. With its unified, user-friendly interface, TigerGraphX bridges the gap between simplicity and scalability, enabling developers to:</p> <ul> <li>Leverage TigerGraph\u2019s unmatched scalability for high-performance graph processing.  </li> <li>Enjoy the familiarity of tools like NetworkX while unlocking enterprise-grade graph capabilities.  </li> <li>Access advanced graph analytics with ease, reducing the learning curve and technical barriers.  </li> <li>Develop intelligent, context-aware GraphRAG applications effortlessly with token-aware workflows and streamlined context builders.</li> </ul> <p>TigerGraphX empowers developers to explore, analyze, and build with graphs like never before\u2014efficiently and effectively.</p>"},{"location":"introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>GraphRAG Overview: Explore how TigerGraphX integrates with GraphRAG workflows.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/installation/","title":"Installation Guide","text":"<p>Follow this guide to install and set up TigerGraphX in your environment.</p>"},{"location":"getting_started/installation/#requirements","title":"Requirements","text":"<p>This project requires Python 3.10, 3.11 or 3.12 and TigerGraph. Ensure you meet the following prerequisites before proceeding:</p>"},{"location":"getting_started/installation/#1-python","title":"1. Python","text":"<ul> <li>Please ensure Python 3.10, 3.11 or 3.12 is installed on your system.</li> <li>You can download and install it from the official Python website.</li> </ul>"},{"location":"getting_started/installation/#2-tigergraph","title":"2. TigerGraph","text":"<p>TigerGraph is required for this project and can be set up in one of the following ways:</p> <ul> <li>TigerGraph DB: Install and configure a local instance of TigerGraph.</li> <li>TigerGraph Cloud: Use a cloud-hosted instance of TigerGraph.</li> <li>TigerGraph Docker: Use a Docker container to run TigerGraph.</li> </ul> <p>It is recommended to use TigerGraph LTS (Long-Term Support) Versions, which can be downloaded from the TigerGraph Downloads page. To enable support for TigerVector and leverage advanced features like hybrid retrieval, ensure you are using TigerGraph 4.2 or above.</p> <p>Refer to the official TigerGraph Documentation for detailed installation and configuration instructions.</p>"},{"location":"getting_started/installation/#installation-steps","title":"Installation Steps","text":""},{"location":"getting_started/installation/#option-1-install-from-pypi","title":"Option 1: Install from PyPI","text":"<p>The simplest way to get started with TigerGraphX is by installing it directly from PyPI. Using a virtual environment is recommended to ensure a clean and isolated setup.</p> <p>To install TigerGraphX, run: <pre><code>pip install tigergraphx\n</code></pre></p> <p>This allows you to quickly start using the library without needing the source code.</p>"},{"location":"getting_started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installing, verify that TigerGraphX is installed correctly by running: <pre><code>python -c 'import tigergraphx; print(\"TigerGraphX installed successfully!\")'\n</code></pre></p> <p>If the installation was successful, you will see: <pre><code>TigerGraphX installed successfully!\n</code></pre></p> <p>This ensures that the library is properly installed and ready for use.</p>"},{"location":"getting_started/installation/#option-2-build-from-source-code","title":"Option 2: Build from Source Code","text":"<p>If you want to modify or explore the source code, you can install TigerGraphX from its GitHub repository. The source code is available here: TigerGraphX on GitHub.</p> <p>This project uses Poetry to manage dependencies. If you don\u2019t have Poetry installed, follow the instructions on the Poetry website.</p> <p>Once Poetry is installed, clone the repository, navigate to the project\u2019s root directory, and use one of the following commands to install dependencies based on your needs:</p>"},{"location":"getting_started/installation/#core-installation","title":"Core Installation","text":"<p>If you need only the core functionality of TigerGraphX (without running application examples like GraphRAG, unit tests, or integration tests), run: <pre><code>poetry install --without dev\n</code></pre></p> <p>This command will:</p> <ul> <li>Install only the dependencies required for the core features of TigerGraphX.</li> </ul>"},{"location":"getting_started/installation/#development-installation","title":"Development Installation","text":"<p>If you\u2019re contributing to the project or want to use advanced features like running the GraphRAG examples or test cases, run: <pre><code>poetry install --with dev\n</code></pre></p> <p>This command will:</p> <ul> <li>Install all core dependencies.</li> <li>Include development dependencies defined under <code>[tool.poetry.group.dev.dependencies]</code> in <code>pyproject.toml</code>.</li> </ul>"},{"location":"getting_started/installation/#verify-your-installation","title":"Verify Your Installation","text":"<p>After installing dependencies, verify your setup by listing the installed packages: <pre><code>poetry show --with dev\n</code></pre></p> <p>This ensures all required dependencies (including optional ones) are successfully installed.</p>"},{"location":"getting_started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>TigerGraphX Quick Start: Learn how to build your first graph with TigerGraphX.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/quick_start_both/","title":"Using TigerGraph for Graph and Vector Database","text":"In\u00a0[1]: Copied! <pre>graph_schema = {\n    \"graph_name\": \"FinancialGraph\",\n    \"nodes\": {\n        \"Account\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n                \"isBlocked\": \"BOOL\",\n            },\n            \"vector_attributes\": {\"emb1\": 3},\n        },\n        \"City\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n            },\n        },\n        \"Phone\": {\n            \"primary_key\": \"number\",\n            \"attributes\": {\n                \"number\": \"STRING\",\n                \"isBlocked\": \"BOOL\",\n            },\n            \"vector_attributes\": {\"emb1\": 3},\n        },\n    },\n    \"edges\": {\n        \"transfer\": {\n            \"is_directed_edge\": True,\n            \"from_node_type\": \"Account\",\n            \"to_node_type\": \"Account\",\n            \"discriminator\": \"date\",\n            \"attributes\": {\n                \"date\": \"DATETIME\",\n                \"amount\": \"INT\",\n            },\n        },\n        \"hasPhone\": {\n            \"is_directed_edge\": False,\n            \"from_node_type\": \"Account\",\n            \"to_node_type\": \"Phone\",\n        },\n        \"isLocatedIn\": {\n            \"is_directed_edge\": True,\n            \"from_node_type\": \"Account\",\n            \"to_node_type\": \"City\",\n        },\n    },\n}\n</pre> graph_schema = {     \"graph_name\": \"FinancialGraph\",     \"nodes\": {         \"Account\": {             \"primary_key\": \"name\",             \"attributes\": {                 \"name\": \"STRING\",                 \"isBlocked\": \"BOOL\",             },             \"vector_attributes\": {\"emb1\": 3},         },         \"City\": {             \"primary_key\": \"name\",             \"attributes\": {                 \"name\": \"STRING\",             },         },         \"Phone\": {             \"primary_key\": \"number\",             \"attributes\": {                 \"number\": \"STRING\",                 \"isBlocked\": \"BOOL\",             },             \"vector_attributes\": {\"emb1\": 3},         },     },     \"edges\": {         \"transfer\": {             \"is_directed_edge\": True,             \"from_node_type\": \"Account\",             \"to_node_type\": \"Account\",             \"discriminator\": \"date\",             \"attributes\": {                 \"date\": \"DATETIME\",                 \"amount\": \"INT\",             },         },         \"hasPhone\": {             \"is_directed_edge\": False,             \"from_node_type\": \"Account\",             \"to_node_type\": \"Phone\",         },         \"isLocatedIn\": {             \"is_directed_edge\": True,             \"from_node_type\": \"Account\",             \"to_node_type\": \"City\",         },     }, } In\u00a0[2]: Copied! <pre>connection = {\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n}\n</pre> connection = {     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", } In\u00a0[3]: Copied! <pre>from tigergraphx import Graph\nG = Graph(graph_schema, connection)\n</pre> from tigergraphx import Graph G = Graph(graph_schema, connection) <pre>2025-01-15 10:46:38,762 - tigergraphx.core.managers.schema_manager - INFO - Graph existence check for FinancialGraph: does not exist\n2025-01-15 10:46:38,763 - tigergraphx.core.managers.schema_manager - INFO - Creating schema for graph: FinancialGraph...\n2025-01-15 10:47:36,104 - tigergraphx.core.managers.schema_manager - INFO - Graph schema created successfully.\n</pre> In\u00a0[4]: Copied! <pre>nodes_for_adding = [\n    (\"Scott\", {\"isBlocked\": False, \"emb1\": [-0.017733968794345856, -0.01019224338233471, -0.016571875661611557]}),\n    (\"Jenny\", {\"isBlocked\": False, \"emb1\": [-0.019265105947852135, 0.0004929182468913496, 0.006711316294968128]}),\n    (\"Steven\", {\"isBlocked\": True, \"emb1\": [-0.01505514420568943, -0.016819344833493233, -0.0221870020031929]}),\n    (\"Paul\", {\"isBlocked\": False, \"emb1\": [0.0011193430982530117, -0.001038988004438579, -0.017158523201942444]}),\n    (\"Ed\", {\"isBlocked\": False, \"emb1\": [-0.003692442551255226, 0.010494389571249485, -0.004631792660802603]}),\n]\nprint(\"Number of Account Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"Account\"))\n\nnodes_for_adding = [\n    (\"718-245-5888\", {\"isBlocked\": False, \"emb1\": [0.0023173028603196144, 0.018836047500371933, 0.03107452765107155]}),\n    (\"650-658-9867\", {\"isBlocked\": True, \"emb1\": [0.01969221793115139, 0.018642477691173553, 0.05322211980819702]}),\n    (\"352-871-8978\", {\"isBlocked\": False, \"emb1\": [-0.003442931454628706, 0.016562696546316147, 0.012876809574663639]}),\n]\nprint(\"Number of Phone Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"Phone\"))\n\nnodes_for_adding = [\"New York\", \"Gainesville\", \"San Francisco\"]\nprint(\"Number of City Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"City\"))\n</pre> nodes_for_adding = [     (\"Scott\", {\"isBlocked\": False, \"emb1\": [-0.017733968794345856, -0.01019224338233471, -0.016571875661611557]}),     (\"Jenny\", {\"isBlocked\": False, \"emb1\": [-0.019265105947852135, 0.0004929182468913496, 0.006711316294968128]}),     (\"Steven\", {\"isBlocked\": True, \"emb1\": [-0.01505514420568943, -0.016819344833493233, -0.0221870020031929]}),     (\"Paul\", {\"isBlocked\": False, \"emb1\": [0.0011193430982530117, -0.001038988004438579, -0.017158523201942444]}),     (\"Ed\", {\"isBlocked\": False, \"emb1\": [-0.003692442551255226, 0.010494389571249485, -0.004631792660802603]}), ] print(\"Number of Account Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"Account\"))  nodes_for_adding = [     (\"718-245-5888\", {\"isBlocked\": False, \"emb1\": [0.0023173028603196144, 0.018836047500371933, 0.03107452765107155]}),     (\"650-658-9867\", {\"isBlocked\": True, \"emb1\": [0.01969221793115139, 0.018642477691173553, 0.05322211980819702]}),     (\"352-871-8978\", {\"isBlocked\": False, \"emb1\": [-0.003442931454628706, 0.016562696546316147, 0.012876809574663639]}), ] print(\"Number of Phone Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"Phone\"))  nodes_for_adding = [\"New York\", \"Gainesville\", \"San Francisco\"] print(\"Number of City Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"City\")) <pre>Number of Account Nodes Inserted: 5\nNumber of Phone Nodes Inserted: 3\nNumber of City Nodes Inserted: 3\n</pre> In\u00a0[5]: Copied! <pre>ebunch_to_add = [\n    (\"Scott\", \"718-245-5888\"),\n    (\"Jenny\", \"718-245-5888\"),\n    (\"Jenny\", \"650-658-9867\"),\n    (\"Paul\", \"650-658-9867\"),\n    (\"Ed\", \"352-871-8978\"),\n]\nprint(\"Number of hasPhone Edges Inserted:\", G.add_edges_from(ebunch_to_add, \"Account\", \"hasPhone\", \"Phone\"))\n\nebunch_to_add = [\n    (\"Scott\", \"New York\"),\n    (\"Jenny\", \"San Francisco\"),\n    (\"Steven\", \"San Francisco\"),\n    (\"Paul\", \"Gainesville\"),\n    (\"Ed\", \"Gainesville\"),\n]\nprint(\"Number of isLocatedIn Edges Inserted:\", G.add_edges_from(ebunch_to_add, \"Account\", \"isLocatedIn\", \"City\"))\n\nebunch_to_add = [\n    (\"Scott\", \"Ed\", {\"date\": \"2024-01-04\", \"amount\": 20000}),\n    (\"Scott\", \"Ed\", {\"date\": \"2024-02-01\", \"amount\": 800}),\n    (\"Scott\", \"Ed\", {\"date\": \"2024-02-14\", \"amount\": 500}),\n    (\"Jenny\", \"Scott\", {\"date\": \"2024-04-04\", \"amount\": 1000}),\n    (\"Paul\", \"Jenny\", {\"date\": \"2024-02-01\", \"amount\": 653}),\n    (\"Steven\", \"Jenny\", {\"date\": \"2024-05-01\", \"amount\": 8560}),\n    (\"Ed\", \"Paul\", {\"date\": \"2024-01-04\", \"amount\": 1500}),\n    (\"Paul\", \"Steven\", {\"date\": \"2023-05-09\", \"amount\": 20000}),\n]\nprint(\"Number of transfer Edges Inserted:\", G.add_edges_from(ebunch_to_add, \"Account\", \"transfer\", \"Account\"))\n</pre> ebunch_to_add = [     (\"Scott\", \"718-245-5888\"),     (\"Jenny\", \"718-245-5888\"),     (\"Jenny\", \"650-658-9867\"),     (\"Paul\", \"650-658-9867\"),     (\"Ed\", \"352-871-8978\"), ] print(\"Number of hasPhone Edges Inserted:\", G.add_edges_from(ebunch_to_add, \"Account\", \"hasPhone\", \"Phone\"))  ebunch_to_add = [     (\"Scott\", \"New York\"),     (\"Jenny\", \"San Francisco\"),     (\"Steven\", \"San Francisco\"),     (\"Paul\", \"Gainesville\"),     (\"Ed\", \"Gainesville\"), ] print(\"Number of isLocatedIn Edges Inserted:\", G.add_edges_from(ebunch_to_add, \"Account\", \"isLocatedIn\", \"City\"))  ebunch_to_add = [     (\"Scott\", \"Ed\", {\"date\": \"2024-01-04\", \"amount\": 20000}),     (\"Scott\", \"Ed\", {\"date\": \"2024-02-01\", \"amount\": 800}),     (\"Scott\", \"Ed\", {\"date\": \"2024-02-14\", \"amount\": 500}),     (\"Jenny\", \"Scott\", {\"date\": \"2024-04-04\", \"amount\": 1000}),     (\"Paul\", \"Jenny\", {\"date\": \"2024-02-01\", \"amount\": 653}),     (\"Steven\", \"Jenny\", {\"date\": \"2024-05-01\", \"amount\": 8560}),     (\"Ed\", \"Paul\", {\"date\": \"2024-01-04\", \"amount\": 1500}),     (\"Paul\", \"Steven\", {\"date\": \"2023-05-09\", \"amount\": 20000}), ] print(\"Number of transfer Edges Inserted:\", G.add_edges_from(ebunch_to_add, \"Account\", \"transfer\", \"Account\")) <pre>Number of hasPhone Edges Inserted: 5\nNumber of isLocatedIn Edges Inserted: 5\nNumber of transfer Edges Inserted: 8\n</pre> In\u00a0[6]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>11\n</pre> In\u00a0[7]: Copied! <pre>results = G.search(\n    data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n    vector_attribute_name=\"emb1\",\n    node_type=\"Account\",\n    limit=3\n)\nfor result in results:\n    print(result)\n</pre> results = G.search(     data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],     vector_attribute_name=\"emb1\",     node_type=\"Account\",     limit=3 ) for result in results:     print(result) <pre>{'id': 'Scott', 'distance': 0, 'name': 'Scott', 'isBlocked': False}\n{'id': 'Paul', 'distance': 0.393388, 'name': 'Paul', 'isBlocked': False}\n{'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}\n</pre> <p>After performing the vector search, the following code retrieves the detailed embeddings of the top-k nodes identified in the search. This is achieved by using their IDs and the specified vector attribute. The results are then printed for each node.</p> In\u00a0[8]: Copied! <pre>node_ids = {item['id'] for item in results}\nnodes = G.fetch_nodes(node_ids, vector_attribute_name=\"emb1\", node_type=\"Account\")\nfor node in nodes.items():\n    print(node)\n</pre> node_ids = {item['id'] for item in results} nodes = G.fetch_nodes(node_ids, vector_attribute_name=\"emb1\", node_type=\"Account\") for node in nodes.items():     print(node) <pre>('Scott', [-0.01773397, -0.01019224, -0.01657188])\n('Paul', [0.001119343, -0.001038988, -0.01715852])\n('Steven', [-0.01505514, -0.01681934, -0.022187])\n</pre> In\u00a0[9]: Copied! <pre>results = G.search_multi_vector_attributes(\n    data=[-0.003442931454628706, 0.016562696546316147, 0.012876809574663639],\n    vector_attribute_names=[\"emb1\", \"emb1\"],\n    node_types=[\"Account\", \"Phone\"],\n    limit=5,\n    return_attributes_list=[[\"isBlocked\"], [\"isBlocked\"]]\n)\nfor result in results:\n    print(result)\n</pre> results = G.search_multi_vector_attributes(     data=[-0.003442931454628706, 0.016562696546316147, 0.012876809574663639],     vector_attribute_names=[\"emb1\", \"emb1\"],     node_types=[\"Account\", \"Phone\"],     limit=5,     return_attributes_list=[[\"isBlocked\"], [\"isBlocked\"]] ) for result in results:     print(result) <pre>{'id': '352-871-8978', 'distance': 1.788139e-07, 'isBlocked': False}\n{'id': '718-245-5888', 'distance': 0.09038806, 'isBlocked': False}\n{'id': '650-658-9867', 'distance': 0.2705743, 'isBlocked': True}\n{'id': 'Ed', 'distance': 0.5047379, 'isBlocked': False}\n{'id': 'Jenny', 'distance': 0.6291004, 'isBlocked': False}\n</pre> In\u00a0[10]: Copied! <pre>G.search_top_k_similar_nodes(\n    node_id=\"Scott\",\n    vector_attribute_name=\"emb1\",\n    node_type=\"Account\",\n    limit=2\n)\n</pre> G.search_top_k_similar_nodes(     node_id=\"Scott\",     vector_attribute_name=\"emb1\",     node_type=\"Account\",     limit=2 ) Out[10]: <pre>[{'id': 'Paul', 'distance': 0.3933879, 'name': 'Paul', 'isBlocked': False},\n {'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}]</pre> In\u00a0[11]: Copied! <pre>results = G.search(\n    data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n    vector_attribute_name=\"emb1\",\n    node_type=\"Account\",\n    limit=2,\n    candidate_ids=[\"Jenny\", \"Steven\", \"Ed\"]\n)\nfor result in results:\n    print(result)\n</pre> results = G.search(     data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],     vector_attribute_name=\"emb1\",     node_type=\"Account\",     limit=2,     candidate_ids=[\"Jenny\", \"Steven\", \"Ed\"] ) for result in results:     print(result) <pre>{'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}\n{'id': 'Jenny', 'distance': 0.5804119, 'name': 'Jenny', 'isBlocked': False}\n</pre> In\u00a0[12]: Copied! <pre>nodes_df = G.get_nodes(\n    node_type=\"Account\",\n    filter_expression=\"s.isBlocked == False\",\n    return_attributes=[\"name\"],\n)\nprint(nodes_df)\n</pre> nodes_df = G.get_nodes(     node_type=\"Account\",     filter_expression=\"s.isBlocked == False\",     return_attributes=[\"name\"], ) print(nodes_df) <pre>    name\n0   Paul\n1     Ed\n2  Jenny\n3  Scott\n</pre> <p>Then convert the name column of the retrieved DataFrame into a set of candidate IDs and performs a top-2 vector search on the \"Account\" node type using the \"emb1\" embedding attribute, restricted to the specified candidate IDs.</p> In\u00a0[13]: Copied! <pre>candidate_ids = set(nodes_df['name'])\nresults = G.search(\n    data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n    vector_attribute_name=\"emb1\",\n    node_type=\"Account\",\n    limit=2,\n    candidate_ids=candidate_ids\n)\nfor result in results:\n    print(result)\n</pre> candidate_ids = set(nodes_df['name']) results = G.search(     data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],     vector_attribute_name=\"emb1\",     node_type=\"Account\",     limit=2,     candidate_ids=candidate_ids ) for result in results:     print(result) <pre>{'id': 'Paul', 'distance': 0.393388, 'name': 'Paul', 'isBlocked': False}\n{'id': 'Scott', 'distance': 0, 'name': 'Scott', 'isBlocked': False}\n</pre> In\u00a0[14]: Copied! <pre>print(G.clear())\n</pre> print(G.clear()) <pre>True\n</pre> <p>Afterwards, you can confirm that there are no nodes in the graph by checking:</p> In\u00a0[15]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>0\n</pre> In\u00a0[16]: Copied! <pre>G.drop_graph()\n</pre> G.drop_graph() <pre>2025-01-15 10:51:24,014 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: FinancialGraph...\n2025-01-15 10:51:27,134 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n</pre>"},{"location":"getting_started/quick_start_both/#tigergraphx-quick-start-using-tigergraph-for-graph-and-vector-database","title":"TigerGraphX Quick Start: Using TigerGraph for Graph and Vector Database\u00b6","text":"<p>Follow this guide to quickly get started with TigerGraph for storing both graph data and vectors. This guide assumes that you have already installed TigerGraphX and its dependencies, as outlined in the Installation Guide.</p> <p>To run this Jupyter Notebook, download the original <code>.ipynb</code> file from quick_start_both.ipynb.</p> <p>In this quick start guide, we will work with the following graph:</p> <p></p>"},{"location":"getting_started/quick_start_both/#create-a-graph","title":"Create a Graph\u00b6","text":""},{"location":"getting_started/quick_start_both/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we create a graph called \"FinancialGraph\" with three node types: \"Account,\" \"City,\" and \"Phone,\" and three edge types: \"transfer,\" \"hasPhone,\" and \"isLocatedIn.\"</p> <ul> <li><p>Nodes:</p> <ul> <li>Account: Primary key <code>name</code>, attributes <code>name</code> (string) and <code>isBlocked</code> (boolean), vector attribute <code>emb1</code> (3).</li> <li>City: Primary key <code>name</code>, attribute <code>name</code> (string).</li> <li>Phone: Primary key <code>number</code>, attributes <code>number</code> (string) and <code>isBlocked</code> (boolean), vector attribute <code>emb1</code> (3).</li> </ul> </li> <li><p>Edges:</p> <ul> <li>transfer: Directed multi-edge between \"Account\" nodes, identified by <code>date</code> (datetime) as the unique identifier for each edge between a pair of source and target nodes. The edge has an attribute <code>amount</code> (integer).</li> <li>hasPhone: Undirected edge between \"Account\" and \"Phone\" nodes.</li> <li>isLocatedIn: Directed edge between \"Account\" and \"City\" nodes.</li> </ul> </li> </ul> <p>This schema defines the structure of the \"FinancialGraph\" with nodes and edges and their respective attributes.</p>"},{"location":"getting_started/quick_start_both/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p>"},{"location":"getting_started/quick_start_both/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"getting_started/quick_start_both/#add-nodes-and-edges","title":"Add Nodes and Edges\u00b6","text":"<p>Note: This example demonstrates how to easily add nodes and edges using the API. However, adding nodes and edges individually may not be efficient for large-scale operations. For better performance when loading data into TigerGraph, it is recommended to use a loading job. Nonetheless, these examples are ideal for quickly getting started.</p>"},{"location":"getting_started/quick_start_both/#add-nodes","title":"Add Nodes\u00b6","text":"<p>This code adds three types of nodes to the graph:</p> <ul> <li><p>Account Nodes: Each account node is identified by a name and includes two attributes:</p> <ul> <li><code>isBlocked</code>: A boolean indicating if the account is blocked.</li> <li><code>emb1</code>: A three-dimensional embedding vector.</li> </ul> </li> <li><p>Phone Nodes: Each phone node is identified by a phone number and has the same attributes as account nodes (<code>isBlocked</code> and <code>emb1</code>).</p> </li> <li><p>City Nodes: City nodes are added using just their name.</p> </li> </ul> <p>For each node type, the code prints the number of nodes inserted.</p>"},{"location":"getting_started/quick_start_both/#add-edges","title":"Add Edges\u00b6","text":"<p>This section adds edges between nodes for different relationships:</p> <ul> <li><p>hasPhone Edges: Connects account nodes to phone nodes. Each tuple represents an edge from an account to a phone number.</p> </li> <li><p>isLocatedIn Edges: Connects account nodes to city nodes. Each tuple represents an edge from an account to its city.</p> </li> <li><p>transfer Edges: Connects account nodes to account nodes to represent a transfer relationship. Each tuple includes additional attributes:</p> <ul> <li><code>date</code>: The date of the transfer.</li> <li><code>amount</code>: The transfer amount.</li> </ul> </li> </ul> <p>For each relationship type, the code prints the number of edges inserted.</p>"},{"location":"getting_started/quick_start_both/#display-the-number-of-nodes","title":"Display the Number of Nodes\u00b6","text":"<p>Next, let's verify that the data has been inserted into the graph by using the following command. As expected, the number of nodes is 11.</p>"},{"location":"getting_started/quick_start_both/#perform-vector-search","title":"Perform Vector Search\u00b6","text":""},{"location":"getting_started/quick_start_both/#top-k-vector-search-on-a-given-vertex-types-vector-attribute","title":"Top-k Vector Search on a Given Vertex Type's Vector Attribute\u00b6","text":"<p>To find the top 3 most similar accounts to \"Scott\" based on the embedding, we use the following code. As expected, \"Scott\" will appear in the list with a distance of 0.</p>"},{"location":"getting_started/quick_start_both/#top-k-vector-search-on-a-set-of-vertex-types-vector-attributes","title":"Top-k Vector Search on a Set of Vertex Types' Vector Attributes\u00b6","text":"<p>The code below performs a multi-vector attribute search on \"Account\" and \"Phone\" node types using two vector attributes (emb1). It retrieves the top 5 similar nodes and fetches the isBlocked attribute for each result.</p>"},{"location":"getting_started/quick_start_both/#top-k-vector-search-using-a-vertex-embedding-as-the-query-vector","title":"Top-k Vector Search Using a Vertex Embedding as the Query Vector\u00b6","text":"<p>This code performs a top-k vector search for similar nodes to a specified node \"Scott\". It searches within the \"Account\" node type using the \"emb1\" embedding attribute and retrieves the top 2 similar node.</p>"},{"location":"getting_started/quick_start_both/#top-k-vector-search-with-specified-candidates","title":"Top-k Vector Search with Specified Candidates\u00b6","text":"<p>This code performs a top-2 vector search on the \"Account\" node type using the \"emb1\" embedding attribute. It limits the search to the specified candidate nodes: \"Jenny\", \"Steven\", and \"Ed\".</p>"},{"location":"getting_started/quick_start_both/#filtered-vector-search","title":"Filtered Vector Search\u00b6","text":"<p>Let's first retrieves all \"Account\" nodes where the isBlocked attribute is False and returns their name attributes in a Pandas DataFrame.</p>"},{"location":"getting_started/quick_start_both/#clear-and-drop-a-graph","title":"Clear and Drop a Graph\u00b6","text":""},{"location":"getting_started/quick_start_both/#clear-the-graph","title":"Clear the Graph\u00b6","text":"<p>To clear the data in the graph without dropping it, use the following code:</p>"},{"location":"getting_started/quick_start_both/#drop-the-graph","title":"Drop the Graph\u00b6","text":"<p>To clear the data and completely remove the graph\u2014including schema, loading jobs, and queries\u2014use the following code:</p>"},{"location":"getting_started/quick_start_both/#whats-next","title":"What\u2019s Next?\u00b6","text":"<p>Now that you've learned how to use TigerGraph for storing both graph data and vectors, you can dive into more advanced features of TigerGraphX:</p> <ul> <li>GraphRAG Overview: Learn about integrating graphs with LLMs.</li> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/quick_start_graph/","title":"Using TigerGraph as Graph Database","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph\ngraph_schema = {\n    \"graph_name\": \"Social\",\n    \"nodes\": {\n        \"Person\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n                \"age\": \"UINT\",\n            },\n        },\n    },\n    \"edges\": {\n        \"Friendship\": {\n            \"is_directed_edge\": False,\n            \"from_node_type\": \"Person\",\n            \"to_node_type\": \"Person\",\n            \"attributes\": {\n                \"closeness\": \"DOUBLE\",\n            },\n        },\n    },\n}\n</pre> from tigergraphx import Graph graph_schema = {     \"graph_name\": \"Social\",     \"nodes\": {         \"Person\": {             \"primary_key\": \"name\",             \"attributes\": {                 \"name\": \"STRING\",                 \"age\": \"UINT\",             },         },     },     \"edges\": {         \"Friendship\": {             \"is_directed_edge\": False,             \"from_node_type\": \"Person\",             \"to_node_type\": \"Person\",             \"attributes\": {                 \"closeness\": \"DOUBLE\",             },         },     }, } In\u00a0[2]: Copied! <pre>connection = {\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n}\n</pre> connection = {     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", } In\u00a0[3]: Copied! <pre>G = Graph(graph_schema, connection)\n</pre> G = Graph(graph_schema, connection) <pre>2025-01-15 10:13:31,508 - tigergraphx.core.managers.schema_manager - INFO - Graph existence check for Social: does not exist\n2025-01-15 10:13:34,866 - tigergraphx.core.managers.schema_manager - INFO - Creating schema for graph: Social...\n2025-01-15 10:13:34,866 - tigergraphx.core.managers.schema_manager - INFO - Graph schema created successfully.\n</pre> In\u00a0[4]: Copied! <pre>G.add_node(\"Alice\", \"Person\", age=25)\nG.add_node(\"Michael\", \"Person\", age=28)\nG.add_edge(\"Alice\", \"Michael\", closeness=0.98)\n</pre> G.add_node(\"Alice\", \"Person\", age=25) G.add_node(\"Michael\", \"Person\", age=28) G.add_edge(\"Alice\", \"Michael\", closeness=0.98) In\u00a0[5]: Copied! <pre>print(G.has_node(\"Alice\"))\n</pre> print(G.has_node(\"Alice\")) <pre>True\n</pre> In\u00a0[6]: Copied! <pre>print(G.has_node(\"Michael\"))\n</pre> print(G.has_node(\"Michael\")) <pre>True\n</pre> <p>Since the 'Friendship' edge is undirected, both 'Alice -&gt; Michael' and 'Michael -&gt; Alice' are valid and accessible.</p> In\u00a0[7]: Copied! <pre>print(G.has_edge(\"Alice\", \"Michael\"))\n</pre> print(G.has_edge(\"Alice\", \"Michael\")) <pre>True\n</pre> In\u00a0[8]: Copied! <pre>print(G.has_edge(\"Michael\", \"Alice\"))\n</pre> print(G.has_edge(\"Michael\", \"Alice\")) <pre>True\n</pre> In\u00a0[9]: Copied! <pre>print(G.get_node_data(\"Alice\"))\n</pre> print(G.get_node_data(\"Alice\")) <pre>{'name': 'Alice', 'age': 25}\n</pre> In\u00a0[10]: Copied! <pre>print(G.get_edge_data(\"Alice\", \"Michael\"))\n</pre> print(G.get_edge_data(\"Alice\", \"Michael\")) <pre>{'closeness': 0.98}\n</pre> In\u00a0[11]: Copied! <pre>print(G.nodes[\"Alice\"])\n</pre> print(G.nodes[\"Alice\"]) <pre>{'name': 'Alice', 'age': 25}\n</pre> In\u00a0[12]: Copied! <pre>print(G.nodes[\"Michael\"][\"age\"])\n</pre> print(G.nodes[\"Michael\"][\"age\"]) <pre>28\n</pre> <p>Note: The Edge View feature is planned for future releases.</p> In\u00a0[13]: Copied! <pre>print(G.degree(\"Alice\"))\n</pre> print(G.degree(\"Alice\")) <pre>1\n</pre> In\u00a0[14]: Copied! <pre>neighbors = G.get_neighbors(\"Alice\")\nprint(neighbors)\n</pre> neighbors = G.get_neighbors(\"Alice\") print(neighbors) <pre>      name  age\n0  Michael   28\n</pre> In\u00a0[15]: Copied! <pre>print(type(neighbors))\n</pre> print(type(neighbors)) <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\n</pre> In\u00a0[16]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>2\n</pre> In\u00a0[17]: Copied! <pre>print(G.number_of_edges())\n</pre> print(G.number_of_edges()) <pre>2\n</pre> In\u00a0[18]: Copied! <pre>print(G.clear())\n</pre> print(G.clear()) <pre>True\n</pre> <p>Afterwards, you can confirm that there are no nodes in the graph by checking:</p> In\u00a0[19]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>0\n</pre> In\u00a0[20]: Copied! <pre>G.drop_graph()\n</pre> G.drop_graph() <pre>2025-01-15 10:13:54,022 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: Social...\n2025-01-15 10:13:56,223 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n</pre>"},{"location":"getting_started/quick_start_graph/#tigergraphx-quick-start-using-tigergraph-as-graph-database","title":"TigerGraphX Quick Start: Using TigerGraph as Graph Database\u00b6","text":"<p>Follow this guide to quickly set up TigerGraphX and build your first graph. This guide assumes that you have already installed TigerGraphX and its dependencies as described in the Installation Guide.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from quick_start_graph.ipynb.</p>"},{"location":"getting_started/quick_start_graph/#create-a-graph","title":"Create a Graph\u00b6","text":""},{"location":"getting_started/quick_start_graph/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we will create a graph named \"Social\" that includes one node type, \"Person,\" and one directed edge type, \"Friendship.\" Note that you must define the primary key for each node type, indicate whether an edge type is directed or undirected, and specify the source and target node types for each edge type.</p>"},{"location":"getting_started/quick_start_graph/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p>"},{"location":"getting_started/quick_start_graph/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"getting_started/quick_start_graph/#nodes-and-edges","title":"Nodes and Edges\u00b6","text":""},{"location":"getting_started/quick_start_graph/#add-nodes-and-edges","title":"Add Nodes and Edges\u00b6","text":"<p>Note: This example demonstrates how to easily add nodes and edges using the API. However, adding nodes and edges individually may not be efficient for large-scale operations. For better performance when loading data into TigerGraph, it is recommended to use a loading job. Nonetheless, these examples are ideal for quickly getting started.</p>"},{"location":"getting_started/quick_start_graph/#check-if-nodes-and-edges-exist","title":"Check if Nodes and Edges Exist\u00b6","text":""},{"location":"getting_started/quick_start_graph/#display-node-and-edge-attributes","title":"Display Node and Edge Attributes\u00b6","text":""},{"location":"getting_started/quick_start_graph/#using-get_node_data-and-get_edge_data-functions","title":"Using <code>get_node_data</code> and <code>get_edge_data</code> Functions\u00b6","text":""},{"location":"getting_started/quick_start_graph/#using-node-view","title":"Using Node View\u00b6","text":""},{"location":"getting_started/quick_start_graph/#display-the-degree-of-nodes","title":"Display the Degree of Nodes\u00b6","text":""},{"location":"getting_started/quick_start_graph/#retrieve-the-neighbors-of-a-node","title":"Retrieve the Neighbors of a Node\u00b6","text":""},{"location":"getting_started/quick_start_graph/#graph-statistics","title":"Graph Statistics\u00b6","text":""},{"location":"getting_started/quick_start_graph/#display-the-number-of-nodes","title":"Display the Number of Nodes\u00b6","text":""},{"location":"getting_started/quick_start_graph/#display-the-number-of-edges","title":"Display the Number of Edges\u00b6","text":""},{"location":"getting_started/quick_start_graph/#clear-and-drop-a-graph","title":"Clear and Drop a Graph\u00b6","text":""},{"location":"getting_started/quick_start_graph/#clear-the-graph","title":"Clear the Graph\u00b6","text":"<p>To clear the data in the graph without dropping it, use the following code:</p>"},{"location":"getting_started/quick_start_graph/#drop-the-graph","title":"Drop the Graph\u00b6","text":"<p>To clear the data and completely remove the graph\u2014including schema, loading jobs, and queries\u2014use the following code:</p>"},{"location":"getting_started/quick_start_graph/#whats-next","title":"What\u2019s Next?\u00b6","text":"<p>Now that you've set up your graph storage and performed basic operations, you can explore more advanced features of TigerGraphX:</p> <ul> <li>TigerGraph Quick Start Guide for Vector Storage: Quickly get started with TigerGraph for storing vector data.</li> <li>API Reference: Dive deeper into TigerGraphX APIs to understand its full capabilities.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/quick_start_vector/","title":"Using TigerGraph as Vector Database","text":"In\u00a0[1]: Copied! <pre>graph_schema = {\n    \"graph_name\": \"FinancialGraph\",\n    \"nodes\": {\n        \"Account\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n                \"isBlocked\": \"BOOL\",\n            },\n            \"vector_attributes\": {\"emb1\": 3},\n        },\n    },\n    \"edges\": {}\n}\n</pre> graph_schema = {     \"graph_name\": \"FinancialGraph\",     \"nodes\": {         \"Account\": {             \"primary_key\": \"name\",             \"attributes\": {                 \"name\": \"STRING\",                 \"isBlocked\": \"BOOL\",             },             \"vector_attributes\": {\"emb1\": 3},         },     },     \"edges\": {} } In\u00a0[2]: Copied! <pre>connection = {\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n}\n</pre> connection = {     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", } In\u00a0[3]: Copied! <pre>from tigergraphx import Graph\nG = Graph(graph_schema, connection)\n</pre> from tigergraphx import Graph G = Graph(graph_schema, connection) <pre>2025-01-15 10:36:43,412 - tigergraphx.core.managers.schema_manager - INFO - Graph existence check for FinancialGraph: does not exist\n2025-01-15 10:36:43,412 - tigergraphx.core.managers.schema_manager - INFO - Creating schema for graph: FinancialGraph...\n2025-01-15 10:37:32,449 - tigergraphx.core.managers.schema_manager - INFO - Graph schema created successfully.\n</pre> In\u00a0[4]: Copied! <pre>nodes_for_adding = [\n    (\"Scott\", {\"isBlocked\": False, \"emb1\": [-0.017733968794345856, -0.01019224338233471, -0.016571875661611557]}),\n    (\"Jenny\", {\"isBlocked\": False, \"emb1\": [-0.019265105947852135, 0.0004929182468913496, 0.006711316294968128]}),\n    (\"Steven\", {\"isBlocked\": True, \"emb1\": [-0.01505514420568943, -0.016819344833493233, -0.0221870020031929]}),\n    (\"Paul\", {\"isBlocked\": False, \"emb1\": [0.0011193430982530117, -0.001038988004438579, -0.017158523201942444]}),\n    (\"Ed\", {\"isBlocked\": False, \"emb1\": [-0.003692442551255226, 0.010494389571249485, -0.004631792660802603]}),\n]\nprint(\"Number of Account Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"Account\"))\n</pre> nodes_for_adding = [     (\"Scott\", {\"isBlocked\": False, \"emb1\": [-0.017733968794345856, -0.01019224338233471, -0.016571875661611557]}),     (\"Jenny\", {\"isBlocked\": False, \"emb1\": [-0.019265105947852135, 0.0004929182468913496, 0.006711316294968128]}),     (\"Steven\", {\"isBlocked\": True, \"emb1\": [-0.01505514420568943, -0.016819344833493233, -0.0221870020031929]}),     (\"Paul\", {\"isBlocked\": False, \"emb1\": [0.0011193430982530117, -0.001038988004438579, -0.017158523201942444]}),     (\"Ed\", {\"isBlocked\": False, \"emb1\": [-0.003692442551255226, 0.010494389571249485, -0.004631792660802603]}), ] print(\"Number of Account Nodes Inserted:\", G.add_nodes_from(nodes_for_adding, node_type=\"Account\")) <pre>Number of Account Nodes Inserted: 5\n</pre> In\u00a0[5]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>5\n</pre> In\u00a0[7]: Copied! <pre>results = G.search(\n    data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],\n    vector_attribute_name=\"emb1\",\n    node_type=\"Account\",\n    limit=2\n)\nfor result in results:\n    print(result)\n</pre> results = G.search(     data=[-0.017733968794345856, -0.01019224338233471, -0.016571875661611557],     vector_attribute_name=\"emb1\",     node_type=\"Account\",     limit=2 ) for result in results:     print(result) <pre>{'id': 'Scott', 'distance': 0, 'name': 'Scott', 'isBlocked': False}\n{'id': 'Steven', 'distance': 0.0325563, 'name': 'Steven', 'isBlocked': True}\n</pre> In\u00a0[8]: Copied! <pre>print(G.clear())\n</pre> print(G.clear()) <pre>True\n</pre> <p>Afterwards, you can confirm that there are no nodes in the graph by checking:</p> In\u00a0[9]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>0\n</pre> In\u00a0[10]: Copied! <pre>G.drop_graph()\n</pre> G.drop_graph() <pre>2025-01-15 10:38:27,708 - tigergraphx.core.managers.schema_manager - INFO - Dropping graph: FinancialGraph...\n2025-01-15 10:38:30,869 - tigergraphx.core.managers.schema_manager - INFO - Graph dropped successfully.\n</pre>"},{"location":"getting_started/quick_start_vector/#tigergraphx-quick-start-using-tigergraph-as-vector-database","title":"TigerGraphX Quick Start: Using TigerGraph as Vector Database\u00b6","text":"<p>TigerGraph has supported vector storage since version 4.2. In this guide, we will demonstrate how to use TigerGraph as a pure vector database, without storing edges. This setup can be useful when you want to leverage TigerGraph solely as a vector database. However, to fully unlock the potential of TigerGraph, you can also use it as both a graph and vector storage solution. For more details, refer to the next guide.</p> <p>This guide assumes that you have already installed TigerGraphX and its dependencies, as outlined in the Installation Guide.</p> <p>To run this Jupyter Notebook, download the original <code>.ipynb</code> file from quick_start_vector.ipynb.</p>"},{"location":"getting_started/quick_start_vector/#create-a-graph","title":"Create a Graph\u00b6","text":""},{"location":"getting_started/quick_start_vector/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. A typical schema includes the graph name, nodes (vertices), edges (relationships), and their respective attributes. However, when using TigerGraph as a pure vector database, you only need to define the graph name, the node (vertex) type, and its attributes, including vector attributes.</p> <p>In this example, we create a graph called \"FinancialGraph\" with one node type: \"Account.\" This node type has a primary key <code>name</code>, attributes <code>name</code> (string) and <code>isBlocked</code> (boolean), and a vector attribute <code>emb1</code> (3-dimensional).</p>"},{"location":"getting_started/quick_start_vector/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p>"},{"location":"getting_started/quick_start_vector/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"getting_started/quick_start_vector/#add-nodes","title":"Add Nodes\u00b6","text":"<p>In this example, we add multiple nodes representing accounts to the graph. Each node is uniquely identified by a name and comes with two attributes:</p> <ul> <li>isBlocked: A Boolean indicating whether the account is blocked.</li> <li>emb1: A three-dimensional embedding vector.</li> </ul>"},{"location":"getting_started/quick_start_vector/#display-the-number-of-nodes","title":"Display the Number of Nodes\u00b6","text":"<p>Next, let's verify that the data has been inserted into the graph by using the following command. As expected, the number of nodes is 5.</p>"},{"location":"getting_started/quick_start_vector/#perform-vector-search","title":"Perform Vector Search\u00b6","text":"<p>To find the top 2 most similar accounts to \"Scott\" based on the embedding, we use the following code. As expected, \"Scott\" will appear in the list with a distance of 0.</p>"},{"location":"getting_started/quick_start_vector/#clear-and-drop-a-graph","title":"Clear and Drop a Graph\u00b6","text":""},{"location":"getting_started/quick_start_vector/#clear-the-graph","title":"Clear the Graph\u00b6","text":"<p>To clear the data in the graph without dropping it, use the following code:</p>"},{"location":"getting_started/quick_start_vector/#drop-the-graph","title":"Drop the Graph\u00b6","text":"<p>To clear the data and completely remove the graph\u2014including schema, loading jobs, and queries\u2014use the following code:</p>"},{"location":"getting_started/quick_start_vector/#whats-next","title":"What\u2019s Next?\u00b6","text":"<p>Now that you've learned how to use TigerGraph for storing both graph data and vectors, you can dive into more advanced features of TigerGraphX:</p> <ul> <li>GraphRAG Overview: Learn about integrating graphs with LLMs.</li> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"graphrag/graphrag_overview/","title":"TigerGraph: Unlocking the Potential of GraphRAG","text":""},{"location":"graphrag/graphrag_overview/#overview","title":"Overview","text":"<p>TigerGraph is a highly scalable and efficient graph database, making it the ideal foundation for advanced GraphRAG workflows. It excels in handling both graph and vector data, enabling seamless integration and performance at scale. With built-in support for complex queries, multi-hop traversals, and real-time analytics, TigerGraph ensures fast and reliable results. Its versatility and performance make it the ideal choice for powering data-intensive workflows, while TigerGraphX simplifies access with a Python-native interface.</p> <p></p>"},{"location":"graphrag/graphrag_overview/#why-tigergraph-for-graphrag","title":"Why TigerGraph for GraphRAG?","text":""},{"location":"graphrag/graphrag_overview/#1-scalability-and-performance","title":"1. Scalability and Performance","text":"<p>TigerGraph excels in handling massive datasets with high-speed multi-hop queries and vector search capabilities. It is ideal for real-world GraphRAG applications that demand extensive and efficient data processing.</p>"},{"location":"graphrag/graphrag_overview/#2-unified-graph-and-vector-data-support","title":"2. Unified Graph and Vector Data Support","text":"<p>With native support for schema-defined nodes, edges, and vectors, TigerGraph streamlines data integration. Its advanced query optimization enables efficient graph traversal and vector-based retrieval, which is perfectly suited for LLM workflows.</p>"},{"location":"graphrag/graphrag_overview/#3-cost-effectiveness","title":"3. Cost-Effectiveness","text":"<p>TigerGraph reduces computational overhead through optimized queries and highly efficient storage, significantly cutting infrastructure costs while maintaining top-tier performance.</p>"},{"location":"graphrag/graphrag_overview/#4-flexibility-and-hybrid-integration","title":"4. Flexibility and Hybrid Integration","text":"<p>Seamlessly combines structured, semantic, and vector-based retrieval methods in one unified platform. Its compatibility with vector search and LLMs enables advanced hybrid retrieval strategies, unlocking new possibilities for GraphRAG workflows.</p>"},{"location":"graphrag/graphrag_overview/#graphrag-workflow-with-tigergraph","title":"GraphRAG Workflow with TigerGraph","text":""},{"location":"graphrag/graphrag_overview/#1-schema-design","title":"1. Schema Design","text":"<p>Define the graph schema with nodes, edges, and attributes tailored to your application, leveraging TigerGraph\u2019s native support for structured graph data.</p>"},{"location":"graphrag/graphrag_overview/#2-data-preparation-and-loading","title":"2. Data Preparation and Loading","text":"<p>Transform raw data into TigerGraph-compatible formats, including graph structures and embeddings, and load it efficiently into TigerGraph using TigerGraphX.</p>"},{"location":"graphrag/graphrag_overview/#3-knowledge-graph-management-and-analysis","title":"3. Knowledge Graph Management and Analysis","text":"<p>Maintain and enhance the knowledge graph to ensure data quality, relevance, and scalability. Perform in-depth analysis to uncover patterns, infer insights, and optimize data retrieval strategies; ensure the knowledge graph remains a dynamic, accurate, and actionable source of information, enriching context for LLMs while supporting explainability and scalability in the GraphRAG workflow.</p>"},{"location":"graphrag/graphrag_overview/#4-hybrid-retrieval","title":"4. Hybrid Retrieval","text":"<p>Combine structured queries, semantic search, and vector-based methods to fetch relevant data and embeddings from TigerGraph for context construction.</p>"},{"location":"graphrag/graphrag_overview/#5-context-building","title":"5. Context Building","text":"<p>Use TigerGraphX to process retrieved data, making it token-aware and formatted to meet the requirements of LLMs.</p>"},{"location":"graphrag/graphrag_overview/#6-llm-integration","title":"6. LLM Integration","text":"<p>Pass the context to an LLM to generate responses, enabling advanced GraphRAG workflows with seamless data flow and high efficiency.</p>"},{"location":"graphrag/graphrag_overview/#two-options-for-implementing-graphrag-with-tigergraph","title":"Two Options for Implementing GraphRAG with TigerGraph","text":"<p>There are two approaches to implementing GraphRAG with TigerGraph.</p>"},{"location":"graphrag/graphrag_overview/#1-tigergraph-as-a-storage-and-retrieval-engine","title":"1. TigerGraph as a Storage and Retrieval Engine","text":"<p>The first approach primarily utilizes TigerGraph for storing and retrieving graph/vector data. TigerGraphX provides interfaces similar to NetworkX, allowing seamless integration with GraphRAG applications. This approach is recommended for GraphRAG solutions like LightRAG and Nano-GraphRAG, which abstract their storage layers (e.g., graph storage, key-value storage, and vector storage). Here, you only need to implement these layers in a way that aligns with TigerGraph.</p>"},{"location":"graphrag/graphrag_overview/#2-tigergraph-for-storage-and-retrieval-tigergraphx-for-llm-tasks","title":"2. TigerGraph for Storage and Retrieval; TigerGraphX for LLM Tasks","text":"<p>The second approach extends beyond storage and retrieval by leveraging TigerGraphX for tasks related to large language models (LLMs), such as chat or embedding generation. This approach is suitable for complex projects like Microsoft's GraphRAG. As of December 2024, Microsoft's GraphRAG has not yet abstracted its storage layer, making it challenging to replace the indexing process. However, TigerGraphX can be used to convert the results of the indexing process (e.g., Parquet files) into a format supported by TigerGraph. These results can then be imported into TigerGraph, and TigerGraphX can handle the querying process without relying on Microsoft\u2019s GraphRAG.</p>"},{"location":"graphrag/graphrag_overview/#demonstrations","title":"Demonstrations","text":"<p>Both methods are demonstrated on the following pages, each with a real-world project:</p> <ul> <li>LightRAG: Refer to LightRAG for the first approach.</li> <li>Microsoft's GraphRAG: Refer to Microsoft GraphRAG: Part 1 for the second approach.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/lightrag/","title":"Supporting LightRAG","text":"<p>LightRAG is an open-source RAG system that enhances LLMs by integrating graph-based structures into text indexing and retrieval. It overcomes the limitations of traditional RAG systems, such as fragmented answers and weak contextual awareness, by enabling dual-level retrieval for more comprehensive knowledge discovery. With support for incremental data updates, LightRAG ensures timely integration of new information while delivering improved retrieval accuracy and efficiency.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from lightrag.ipynb.</p> In\u00a0[1]: Copied! <pre>import os\nfrom dataclasses import dataclass\nfrom typing import Any, Dict\nimport numpy as np\n\nfrom lightrag.base import BaseGraphStorage\nfrom lightrag.utils import logger\n\nfrom tigergraphx import Graph\n\n\n@dataclass\nclass TigerGraphStorage(BaseGraphStorage):\n    def __post_init__(self):\n        try:\n            # Define the graph schema\n            graph_schema = {\n                \"graph_name\": \"LightRAG\",\n                \"nodes\": {\n                    \"Entity\": {\n                        \"primary_key\": \"id\",\n                        \"attributes\": {\n                            \"id\": \"STRING\",\n                            \"entity_type\": \"STRING\",\n                            \"description\": \"STRING\",\n                            \"source_id\": \"STRING\",\n                        },\n                    }\n                },\n                \"edges\": {\n                    \"relationship\": {\n                        \"is_directed_edge\": False,\n                        \"from_node_type\": \"Entity\",\n                        \"to_node_type\": \"Entity\",\n                        \"attributes\": {\n                            \"weight\": \"DOUBLE\",\n                            \"description\": \"STRING\",\n                            \"keywords\": \"STRING\",\n                            \"source_id\": \"STRING\",\n                        },\n                    }\n                },\n            }\n\n            # Retrieve connection configuration from environment variables\n            connection_config = {\n                \"host\": os.environ.get(\"TG_HOST\", \"http://127.0.0.1\"),\n                \"restpp_port\": os.environ.get(\"TG_RESTPP_PORT\", \"14240\"),\n                \"gsql_port\": os.environ.get(\"TG_GSQL_PORT\", \"14240\"),\n                # Option 1: User/password authentication\n                \"username\": os.environ.get(\"TG_USERNAME\"),\n                \"password\": os.environ.get(\"TG_PASSWORD\"),\n                # Option 2: Secret-based authentication\n                \"secret\": os.environ.get(\"TG_SECRET\"),\n                # Option 3: Token-based authentication\n                \"token\": os.environ.get(\"TG_TOKEN\"),\n            }\n\n            # Initialize the graph\n            self._graph = Graph(graph_schema, connection_config)\n        except Exception as e:\n            logger.error(f\"An error occurred during initialization: {e}\")\n            raise\n\n    @staticmethod\n    def clean_quotes(value: str) -&gt; str:\n        \"\"\"Remove leading and trailing &amp;quot; from a string if present.\"\"\"\n        if value.startswith('\"') and value.endswith('\"'):\n            return value[1:-1]\n        return value\n\n    async def has_node(self, node_id: str) -&gt; bool:\n        return self._graph.has_node(self.clean_quotes(node_id))\n\n    async def has_edge(self, source_node_id: str, target_node_id: str) -&gt; bool:\n        return self._graph.has_edge(\n            self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)\n        )\n\n    async def node_degree(self, node_id: str) -&gt; int:\n        result = self._graph.degree(self.clean_quotes(node_id))\n        return result\n\n    async def edge_degree(self, src_id: str, tgt_id: str) -&gt; int:\n        return self._graph.degree(self.clean_quotes(src_id)) + self._graph.degree(\n            self.clean_quotes(tgt_id)\n        )\n\n    async def get_node(self, node_id: str) -&gt; dict | None:\n        result = self._graph.get_node_data(self.clean_quotes(node_id))\n        return result\n\n    async def get_edge(self, source_node_id: str, target_node_id: str) -&gt; dict | None:\n        result = self._graph.get_edge_data(\n            self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)\n        )\n        return result\n\n    async def get_node_edges(self, source_node_id: str) -&gt; list[tuple[str, str]] | None:\n        source_node_id = self.clean_quotes(source_node_id)\n        if self._graph.has_node(source_node_id):\n            edges = self._graph.get_node_edges(source_node_id)\n            return list(edges)\n        return None\n\n    async def upsert_node(self, node_id: str, node_data: Dict[str, Any]):\n        node_id = self.clean_quotes(node_id)\n        self._graph.add_node(node_id, **node_data)\n\n    async def upsert_edge(\n        self, source_node_id: str, target_node_id: str, edge_data: Dict[str, Any]\n    ):\n        source_node_id = self.clean_quotes(source_node_id)\n        target_node_id = self.clean_quotes(target_node_id)\n        self._graph.add_edge(source_node_id, target_node_id, **edge_data)\n\n    async def delete_node(self, node_id: str):\n        if self._graph.has_node(node_id):\n            self._graph.remove_node(node_id)\n            logger.info(f\"Node {node_id} deleted from the graph.\")\n        else:\n            logger.warning(f\"Node {node_id} not found in the graph for deletion.\")\n\n    async def embed_nodes(self, algorithm: str) -&gt; tuple[np.ndarray, list[str]]:\n        return np.array([]), []\n\n    def drop_graph(self) -&gt; None:\n        self._graph.drop_graph()\n</pre> import os from dataclasses import dataclass from typing import Any, Dict import numpy as np  from lightrag.base import BaseGraphStorage from lightrag.utils import logger  from tigergraphx import Graph   @dataclass class TigerGraphStorage(BaseGraphStorage):     def __post_init__(self):         try:             # Define the graph schema             graph_schema = {                 \"graph_name\": \"LightRAG\",                 \"nodes\": {                     \"Entity\": {                         \"primary_key\": \"id\",                         \"attributes\": {                             \"id\": \"STRING\",                             \"entity_type\": \"STRING\",                             \"description\": \"STRING\",                             \"source_id\": \"STRING\",                         },                     }                 },                 \"edges\": {                     \"relationship\": {                         \"is_directed_edge\": False,                         \"from_node_type\": \"Entity\",                         \"to_node_type\": \"Entity\",                         \"attributes\": {                             \"weight\": \"DOUBLE\",                             \"description\": \"STRING\",                             \"keywords\": \"STRING\",                             \"source_id\": \"STRING\",                         },                     }                 },             }              # Retrieve connection configuration from environment variables             connection_config = {                 \"host\": os.environ.get(\"TG_HOST\", \"http://127.0.0.1\"),                 \"restpp_port\": os.environ.get(\"TG_RESTPP_PORT\", \"14240\"),                 \"gsql_port\": os.environ.get(\"TG_GSQL_PORT\", \"14240\"),                 # Option 1: User/password authentication                 \"username\": os.environ.get(\"TG_USERNAME\"),                 \"password\": os.environ.get(\"TG_PASSWORD\"),                 # Option 2: Secret-based authentication                 \"secret\": os.environ.get(\"TG_SECRET\"),                 # Option 3: Token-based authentication                 \"token\": os.environ.get(\"TG_TOKEN\"),             }              # Initialize the graph             self._graph = Graph(graph_schema, connection_config)         except Exception as e:             logger.error(f\"An error occurred during initialization: {e}\")             raise      @staticmethod     def clean_quotes(value: str) -&gt; str:         \"\"\"Remove leading and trailing \" from a string if present.\"\"\"         if value.startswith('\"') and value.endswith('\"'):             return value[1:-1]         return value      async def has_node(self, node_id: str) -&gt; bool:         return self._graph.has_node(self.clean_quotes(node_id))      async def has_edge(self, source_node_id: str, target_node_id: str) -&gt; bool:         return self._graph.has_edge(             self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)         )      async def node_degree(self, node_id: str) -&gt; int:         result = self._graph.degree(self.clean_quotes(node_id))         return result      async def edge_degree(self, src_id: str, tgt_id: str) -&gt; int:         return self._graph.degree(self.clean_quotes(src_id)) + self._graph.degree(             self.clean_quotes(tgt_id)         )      async def get_node(self, node_id: str) -&gt; dict | None:         result = self._graph.get_node_data(self.clean_quotes(node_id))         return result      async def get_edge(self, source_node_id: str, target_node_id: str) -&gt; dict | None:         result = self._graph.get_edge_data(             self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)         )         return result      async def get_node_edges(self, source_node_id: str) -&gt; list[tuple[str, str]] | None:         source_node_id = self.clean_quotes(source_node_id)         if self._graph.has_node(source_node_id):             edges = self._graph.get_node_edges(source_node_id)             return list(edges)         return None      async def upsert_node(self, node_id: str, node_data: Dict[str, Any]):         node_id = self.clean_quotes(node_id)         self._graph.add_node(node_id, **node_data)      async def upsert_edge(         self, source_node_id: str, target_node_id: str, edge_data: Dict[str, Any]     ):         source_node_id = self.clean_quotes(source_node_id)         target_node_id = self.clean_quotes(target_node_id)         self._graph.add_edge(source_node_id, target_node_id, **edge_data)      async def delete_node(self, node_id: str):         if self._graph.has_node(node_id):             self._graph.remove_node(node_id)             logger.info(f\"Node {node_id} deleted from the graph.\")         else:             logger.warning(f\"Node {node_id} not found in the graph for deletion.\")      async def embed_nodes(self, algorithm: str) -&gt; tuple[np.ndarray, list[str]]:         return np.array([]), []      def drop_graph(self) -&gt; None:         self._graph.drop_graph() <p>This code defines the <code>TigerGraphStorage</code> class, which interacts with TigerGraphX to manage graph data in TigerGraph.</p> In\u00a0[2]: Copied! <pre>import os\nfrom dataclasses import dataclass\nimport numpy as np\nfrom tqdm.asyncio import tqdm as tqdm_async\nimport asyncio\n\nfrom lightrag.base import BaseVectorStorage\nfrom lightrag.utils import logger\n\nfrom tigergraphx import Graph\n\n\n@dataclass\nclass TigerVectorStorage(BaseVectorStorage):\n    def __post_init__(self):\n        try:\n            # Define the graph schema\n            graph_schema = {\n                \"graph_name\": f\"Vector_{self.namespace}\",\n                \"nodes\": {\n                    \"Table\": {\n                        \"primary_key\": \"id\",\n                        \"attributes\": {\n                            \"id\": \"STRING\",\n                            **{field: \"STRING\" for field in self.meta_fields},\n                        },\n                        \"vector_attributes\": {\n                            \"vector_attribute\": self.embedding_func.embedding_dim,\n                        },\n                    }\n                },\n                \"edges\": {},\n            }\n\n            # Retrieve connection configuration from environment variables\n            connection_config = {\n                \"host\": os.environ.get(\"TG_HOST\", \"http://127.0.0.1\"),\n                \"restpp_port\": os.environ.get(\"TG_RESTPP_PORT\", \"14240\"),\n                \"gsql_port\": os.environ.get(\"TG_GSQL_PORT\", \"14240\"),\n                # Option 1: User/password authentication\n                \"username\": os.environ.get(\"TG_USERNAME\"),\n                \"password\": os.environ.get(\"TG_PASSWORD\"),\n                # Option 2: Secret-based authentication\n                \"secret\": os.environ.get(\"TG_SECRET\"),\n                # Option 3: Token-based authentication\n                \"token\": os.environ.get(\"TG_TOKEN\"),\n            }\n\n            # Initialize the graph\n            self._graph = Graph(graph_schema, connection_config)\n            self._max_batch_size = self.global_config[\"embedding_batch_num\"]\n        except Exception as e:\n            logger.error(f\"An error occurred during initialization: {e}\")\n            raise\n\n    async def upsert(self, data: dict[str, dict]):\n        \"\"\"\n        Insert or update data in the TigerGraph vector storage.\n        \"\"\"\n        logger.info(f\"Inserting {len(data)} vectors to {self.namespace}\")\n        if not len(data):\n            logger.warning(\"No data to insert into the vector DB.\")\n            return []\n\n        # Preparing the data for insertion\n        list_data = [\n            {\n                \"id\": k,\n                **{k1: v1 for k1, v1 in v.items() if k1 in self.meta_fields},\n            }\n            for k, v in data.items()\n        ]\n\n        contents = [v[\"content\"] for v in data.values()]\n\n        # Batch the data for embedding\n        batches = [\n            contents[i : i + self._max_batch_size]\n            for i in range(0, len(contents), self._max_batch_size)\n        ]\n\n        async def wrapped_task(batch):\n            result = await self.embedding_func(batch)\n            pbar.update(1)\n            return result\n\n        embedding_tasks = [wrapped_task(batch) for batch in batches]\n        pbar = tqdm_async(\n            total=len(embedding_tasks), desc=\"Generating embeddings\", unit=\"batch\"\n        )\n        embeddings_list = await asyncio.gather(*embedding_tasks)\n\n        embeddings = np.concatenate(embeddings_list)\n        if len(embeddings) == len(list_data):\n            for i, d in enumerate(list_data):\n                d[\"vector_attribute\"] = embeddings[i].tolist()\n            results = self._graph.upsert(data=list_data, node_type=\"Table\")\n            return results\n        else:\n            # sometimes the embedding is not returned correctly. just log it.\n            logger.error(\n                f\"embedding is not 1-1 with data, {len(embeddings)} != {len(list_data)}\"\n            )\n\n    async def query(self, query: str, top_k=5):\n        \"\"\"\n        Perform a vector search to find the most similar nodes based on the query vector.\n        \"\"\"\n        embedding = await self.embedding_func([query])\n        embedding = embedding[0].tolist()\n        results = self._graph.search(\n            data=embedding,\n            vector_attribute_name=\"vector_attribute\",\n            node_type=\"Table\",  # Specify the node type\n            limit=top_k,  # Retrieve the top_k closest nodes\n        )\n        return results\n</pre> import os from dataclasses import dataclass import numpy as np from tqdm.asyncio import tqdm as tqdm_async import asyncio  from lightrag.base import BaseVectorStorage from lightrag.utils import logger  from tigergraphx import Graph   @dataclass class TigerVectorStorage(BaseVectorStorage):     def __post_init__(self):         try:             # Define the graph schema             graph_schema = {                 \"graph_name\": f\"Vector_{self.namespace}\",                 \"nodes\": {                     \"Table\": {                         \"primary_key\": \"id\",                         \"attributes\": {                             \"id\": \"STRING\",                             **{field: \"STRING\" for field in self.meta_fields},                         },                         \"vector_attributes\": {                             \"vector_attribute\": self.embedding_func.embedding_dim,                         },                     }                 },                 \"edges\": {},             }              # Retrieve connection configuration from environment variables             connection_config = {                 \"host\": os.environ.get(\"TG_HOST\", \"http://127.0.0.1\"),                 \"restpp_port\": os.environ.get(\"TG_RESTPP_PORT\", \"14240\"),                 \"gsql_port\": os.environ.get(\"TG_GSQL_PORT\", \"14240\"),                 # Option 1: User/password authentication                 \"username\": os.environ.get(\"TG_USERNAME\"),                 \"password\": os.environ.get(\"TG_PASSWORD\"),                 # Option 2: Secret-based authentication                 \"secret\": os.environ.get(\"TG_SECRET\"),                 # Option 3: Token-based authentication                 \"token\": os.environ.get(\"TG_TOKEN\"),             }              # Initialize the graph             self._graph = Graph(graph_schema, connection_config)             self._max_batch_size = self.global_config[\"embedding_batch_num\"]         except Exception as e:             logger.error(f\"An error occurred during initialization: {e}\")             raise      async def upsert(self, data: dict[str, dict]):         \"\"\"         Insert or update data in the TigerGraph vector storage.         \"\"\"         logger.info(f\"Inserting {len(data)} vectors to {self.namespace}\")         if not len(data):             logger.warning(\"No data to insert into the vector DB.\")             return []          # Preparing the data for insertion         list_data = [             {                 \"id\": k,                 **{k1: v1 for k1, v1 in v.items() if k1 in self.meta_fields},             }             for k, v in data.items()         ]          contents = [v[\"content\"] for v in data.values()]          # Batch the data for embedding         batches = [             contents[i : i + self._max_batch_size]             for i in range(0, len(contents), self._max_batch_size)         ]          async def wrapped_task(batch):             result = await self.embedding_func(batch)             pbar.update(1)             return result          embedding_tasks = [wrapped_task(batch) for batch in batches]         pbar = tqdm_async(             total=len(embedding_tasks), desc=\"Generating embeddings\", unit=\"batch\"         )         embeddings_list = await asyncio.gather(*embedding_tasks)          embeddings = np.concatenate(embeddings_list)         if len(embeddings) == len(list_data):             for i, d in enumerate(list_data):                 d[\"vector_attribute\"] = embeddings[i].tolist()             results = self._graph.upsert(data=list_data, node_type=\"Table\")             return results         else:             # sometimes the embedding is not returned correctly. just log it.             logger.error(                 f\"embedding is not 1-1 with data, {len(embeddings)} != {len(list_data)}\"             )      async def query(self, query: str, top_k=5):         \"\"\"         Perform a vector search to find the most similar nodes based on the query vector.         \"\"\"         embedding = await self.embedding_func([query])         embedding = embedding[0].tolist()         results = self._graph.search(             data=embedding,             vector_attribute_name=\"vector_attribute\",             node_type=\"Table\",  # Specify the node type             limit=top_k,  # Retrieve the top_k closest nodes         )         return results <p>This code defines the <code>TigerVectorStorage</code> class, which is used for storing and querying vector data (like embeddings) in a TigerGraph database using TigerGraphX.</p> In\u00a0[3]: Copied! <pre>from lightrag import LightRAG\n\n\n# Define a subclass to include your custom graph storage in the storage mapping\nclass CustomLightRAG(LightRAG):\n    def _get_storage_class(self):\n        # Extend the default storage mapping with your custom storage\n        base_mapping = super()._get_storage_class()\n        base_mapping[\"TigerGraphStorage\"] = TigerGraphStorage\n        base_mapping[\"TigerVectorStorage\"] = TigerVectorStorage\n        return base_mapping\n</pre> from lightrag import LightRAG   # Define a subclass to include your custom graph storage in the storage mapping class CustomLightRAG(LightRAG):     def _get_storage_class(self):         # Extend the default storage mapping with your custom storage         base_mapping = super()._get_storage_class()         base_mapping[\"TigerGraphStorage\"] = TigerGraphStorage         base_mapping[\"TigerVectorStorage\"] = TigerVectorStorage         return base_mapping In\u00a0[4]: Copied! <pre>import logging\nimport nest_asyncio\n# Use the nest_asyncio package to allow running nested event loops in Jupyter Notebook without conflicts.\nnest_asyncio.apply()\n\n\nworking_dir = \"../../applications/lightrag/data\"\n\ncustom_rag = CustomLightRAG(\n    working_dir=working_dir,\n    graph_storage=\"TigerGraphStorage\",\n    # Use TigerGraph for storing vectors.\n    # To switch to the default vector database in LightRAG, comment out the line below.\n    vector_storage=\"TigerVectorStorage\",\n)\n\nwith open(working_dir + \"/input/book.txt\") as f:\n    custom_rag.insert(f.read())\n</pre> import logging import nest_asyncio # Use the nest_asyncio package to allow running nested event loops in Jupyter Notebook without conflicts. nest_asyncio.apply()   working_dir = \"../../applications/lightrag/data\"  custom_rag = CustomLightRAG(     working_dir=working_dir,     graph_storage=\"TigerGraphStorage\",     # Use TigerGraph for storing vectors.     # To switch to the default vector database in LightRAG, comment out the line below.     vector_storage=\"TigerVectorStorage\", )  with open(working_dir + \"/input/book.txt\") as f:     custom_rag.insert(f.read()) <pre>2025-01-09 17:01:20,891 - lightrag - INFO - Logger initialized for working directory: ../../applications/lightrag/data\n2025-01-09 17:01:20,893 - lightrag - INFO - Load KV llm_response_cache with 2 data\n2025-01-09 17:01:20,896 - lightrag - INFO - Load KV full_docs with 1 data\n2025-01-09 17:01:20,900 - lightrag - INFO - Load KV text_chunks with 42 data\n2025-01-09 17:01:21,017 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph LightRAG...\n2025-01-09 17:01:21,052 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n2025-01-09 17:01:21,054 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph Vector_entities...\n2025-01-09 17:01:21,064 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n2025-01-09 17:01:21,066 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph Vector_relationships...\n2025-01-09 17:01:21,076 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n2025-01-09 17:01:21,078 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph Vector_chunks...\n2025-01-09 17:01:21,105 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n2025-01-09 17:01:21,108 - lightrag - WARNING - All docs are already in the storage\n</pre> <p>Please note that the output has been cleared here due to its length, as most of the content consists of logs.</p> <p>Additionally, TigerVector is supported only in TigerGraph version 4.2.0 and later. If you're using a version prior to 4.2.0, you can comment out the line <code>vector_storage=\"TigerVectorStorage\",</code> to use the default vector database in LightRAG.</p> In\u00a0[5]: Copied! <pre>from lightrag import QueryParam\n\nquery = \"What are the top themes in this story?\"\n\nresult = custom_rag.query(query=query, param=QueryParam(mode=\"hybrid\"))\n\nprint(\"------------------- Query Result:  -------------------\")\nprint(result)\n</pre> from lightrag import QueryParam  query = \"What are the top themes in this story?\"  result = custom_rag.query(query=query, param=QueryParam(mode=\"hybrid\"))  print(\"------------------- Query Result:  -------------------\") print(result) <pre>2025-01-09 17:01:24,700 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2025-01-09 17:01:24,709 - lightrag - INFO - kw_prompt result:\n{\n  \"high_level_keywords\": [\"Themes\", \"Story analysis\"],\n  \"low_level_keywords\": [\"Character development\", \"Conflict\", \"Symbolism\", \"Plot\", \"Setting\"]\n}\n2025-01-09 17:01:25,732 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-01-09 17:03:32,444 - lightrag - INFO - Local query uses 60 entites, 80 relations, 3 text units\n2025-01-09 17:03:33,135 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2025-01-09 17:04:46,561 - lightrag - INFO - Global query uses 47 entites, 60 relations, 3 text units\n2025-01-09 17:05:01,598 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n------------------- Query Result:  -------------------\nIn Charles Dickens' \"A Christmas Carol,\" several prominent themes intertwine within the narrative, reflecting the transformative journey of the central character, Ebenezer Scrooge. These themes serve as moral lessons that resonate deeply with readers and highlight the societal issues of Dickens' time.\n\n### Redemption and Transformation\n\nThe theme of redemption stands out as one of the most significant aspects of Scrooge's character arc. Initially portrayed as a miserly and cold-hearted individual, Scrooge\u2019s encounters with various spirits\u2014most notably the Spirit of Christmas Past, the Spirit of Christmas Present, and the Spirit of Christmas Yet to Come\u2014underscore his potential for change. Through these supernatural visitations, Scrooge comes to realize the consequences of his actions and attitudes toward others, particularly his neglect of the less fortunate. This realization serves as a catalyst for his transformation from a figure of disdain to one of generosity and kindness, ultimately embodying the spirit of Christmas.\n\n### The Spirit of Christmas\n\nAnother essential theme revolves around the essence of Christmas itself, characterized by joy, goodwill, and communal spirit. Christmas is portrayed as a time of reflection, compassion, and generosity, contrasting sharply with Scrooge\u2019s initial cynicism. Dickens emphasizes that the holiday season is an opportunity for individuals to reconnect with their humanity, fostering relationships and nurturing feelings of empathy. Instances within the story, such as the Cratchit family's humble Christmas dinner, reveal how love and celebration can thrive even amidst hardship, highlighting the importance of community and kind-heartedness.\n\n### Compassion and Social Responsibility\n\nCompassion emerges as a vital theme, urging recognition of the struggles faced by the less fortunate. Scrooge\u2019s initial apathy towards the needy epitomizes societal indifference, reflected in his dismissive responses to the pleas for charitable contributions. In stark contrast, the Cratchit family, particularly through the character of Tiny Tim, embodies the spirit of resilience and hope despite their economic hardships. Dickens employs Tiny Tim's situation to showcase the impact of poverty, advocating for social responsibility and awareness of those less fortunate. Scrooge's eventual embracing of compassion signifies a shift from self-interest to a broader understanding that one\u2019s moral obligations extend to the community at large.\n\n### The Consequences of Isolation\n\nThe narrative also explores the repercussions of isolation and disconnection. Scrooge, who initially chooses solitude over companionship, experiences profound loneliness, which blinds him to the joys of life and the importance of human connections. His relationships with characters such as his nephew Fred, who embodies the spirit of family and celebration, illustrate the positive impact of social ties. The evolution of Scrooge's character highlights the essential human need for connection, revealing that true wealth lies not in material possessions but in shared experiences and relationships.\n\n### Time and Reflection\n\nLastly, the theme of time plays a critical role in Scrooge's transformation. His encounters with the spirits allow him to reflect on his past choices, current realities, and potential futures. The narrative demonstrates how reflecting on one's life can prompt significant personal growth and ultimately shape one's destiny. This exploration of time serves as a reminder that it is never too late to change one's path, advocating for mindfulness in one's actions and their implications.\n\n### Conclusion\n\nIn summary, \"A Christmas Carol\" is rich with themes of redemption, the spirit of Christmas, compassion, the effects of isolation, and the significance of time. Together, these themes contribute to a timeless narrative that not only entertains but also imparts profound moral lessons about the nature of humanity and the transformative power of kindness and generosity. Through Scrooge\u2019s journey, Dickens encourages readers to embrace the festive spirit and recognize their roles as members of a compassionate community.\n</pre>"},{"location":"graphrag/lightrag/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Before proceeding, ensure you\u2019ve completed the installation and setup steps outlined in the Installation Guide, including:</p> <ul> <li><p>Setting up Python and TigerGraph. For more details, refer to the Requirements section.</p> </li> <li><p>Install TigerGraphX along with its development dependencies. For more details, refer to the Development Installation section.</p> </li> <li><p>Set the environment variables <code>TG_HOST</code>, <code>TG_USERNAME</code>, and <code>TG_PASSWORD</code>, which are required to connect to the TigerGraph server, as well as <code>OPENAI_API_KEY</code> for connecting to OpenAI. Use a command like the following to set these variables:</p> <pre>export TG_HOST=https://127.0.0.1\nexport TG_USERNAME=tigergraph\nexport TG_PASSWORD=tigergraph\nexport OPENAI_API_KEY=&lt;your_key&gt;\n</pre> </li> </ul>"},{"location":"graphrag/lightrag/#implement-graph-and-vector-storage-with-tigergraph","title":"Implement Graph and Vector Storage with TigerGraph\u00b6","text":"<p>In LightRAG, storage layers are abstracted into components such as graph storage, key-value storage, and vector storage. You can explore the base classes BaseGraphStorage, BaseVectorStorage, and BaseKVStorage in the source code.</p> <p>In this section, we will demonstrate how to use TigerGraphX to implement the <code>BaseGraphStorage</code> class for storing and retrieving graph data in TigerGraph. Additionally, we will show how to implement the <code>BaseVectorStorage</code> class for storing vector data and performing vector searches using the TigerVector feature in TigerGraph.</p>"},{"location":"graphrag/lightrag/#implement-graph-storage-with-tigergraph","title":"Implement Graph Storage with TigerGraph\u00b6","text":""},{"location":"graphrag/lightrag/#key-features","title":"Key Features:\u00b6","text":"<ol> <li><p>Graph Schema</p> <ul> <li>Defines a node type <code>\"Entity\"</code> with attributes like <code>id</code>, <code>entity_type</code>, <code>description</code>, and <code>source_id</code>.</li> <li>Defines an edge type <code>\"relationship\"</code> with attributes like <code>weight</code>, <code>description</code>, and <code>source_id</code>.</li> </ul> </li> <li><p>Graph Initialization</p> <ul> <li>Initializes the graph with the schema using TigerGraphX.</li> <li>Connection details (host, ports, authentication) are fetched from environment variables.</li> </ul> </li> <li><p>Node and Edge Operations</p> <ul> <li>Node Operations:<ul> <li><code>has_node</code>: Checks if a node exists.</li> <li><code>get_node</code>: Gets data for a node.</li> <li><code>upsert_node</code>: Adds or updates a node.</li> <li><code>delete_node</code>: Deletes a node.</li> </ul> </li> <li>Edge Operations:<ul> <li><code>has_edge</code>: Checks if an edge exists.</li> <li><code>get_edge</code>: Gets data for an edge.</li> <li><code>upsert_edge</code>: Adds or updates an edge.</li> </ul> </li> </ul> </li> <li><p>Graph Metrics</p> <ul> <li><code>node_degree</code>: Returns the number of connections a node has.</li> <li><code>edge_degree</code>: Calculates the combined degrees of two nodes.</li> </ul> </li> <li><p>Additional Functions</p> <ul> <li><code>clean_quotes</code>: Strips quotes from strings.</li> <li><code>drop_graph</code>: Deletes the entire graph.</li> </ul> </li> </ol>"},{"location":"graphrag/lightrag/#conclusion","title":"Conclusion:\u00b6","text":"<p>The <code>TigerGraphStorage</code> class helps manage and interact with graph data in TigerGraph by offering simple methods for storing, retrieving, and managing nodes, edges, and graph metrics.</p>"},{"location":"graphrag/lightrag/#implement-vector-storage-with-tigergraph","title":"Implement Vector Storage with TigerGraph\u00b6","text":""},{"location":"graphrag/lightrag/#key-features","title":"Key Features:\u00b6","text":"<ol> <li><p>Graph Schema</p> <ul> <li>The graph schema defines a node type called <code>\"Table\"</code>, which has attributes including an <code>id</code> and a vector attribute for storing embeddings. The vector attribute's dimension is based on the <code>embedding_func</code>.</li> </ul> </li> <li><p>Upsert Method</p> <ul> <li>The <code>upsert</code> method inserts or updates vector data in the TigerGraph database. It batches the data and generates embeddings asynchronously using <code>embedding_func</code>, then stores these embeddings in the graph.</li> </ul> </li> <li><p>Query Method</p> <ul> <li>The <code>query</code> method performs a vector search in the TigerGraph database to find the most similar nodes based on a query vector. It uses the <code>embedding_func</code> to generate the query vector and then queries the database for the closest nodes.</li> </ul> </li> </ol>"},{"location":"graphrag/lightrag/#conclusion","title":"Conclusion:\u00b6","text":"<p><code>TigerVectorStorage</code> enables the use of vector embeddings in TigerGraph, allowing for efficient storage and search of vector data.</p>"},{"location":"graphrag/lightrag/#integrating-custom-graph-and-vector-storage-with-lightrag","title":"Integrating Custom Graph and Vector Storage with LightRAG\u00b6","text":"<p>After defining the <code>TigerGraphStorage</code> and <code>TigerVectorStorage</code> classes, we integrate them into LightRAG. By subclassing LightRAG and extending its storage mapping, you can easily replace or augment the default storage backends with your custom solutions.</p> <p>While modifying the LightRAG source code is another option, this example demonstrates how to achieve the integration without altering the original source code.</p> <p>Below is the code for creating a <code>CustomLightRAG</code> class that incorporates both <code>TigerGraphStorage</code> and <code>TigerVectorStorage</code> into its storage mapping.</p>"},{"location":"graphrag/lightrag/#indexing","title":"Indexing\u00b6","text":""},{"location":"graphrag/lightrag/#data-preparation","title":"Data Preparation\u00b6","text":""},{"location":"graphrag/lightrag/#set-up-working-directory","title":"Set Up Working Directory\u00b6","text":"<p>Create a folder to serve as the working directory. For this demo, we will use <code>applications/lightrag/data</code>.</p> <p>Next, create an <code>input</code> folder inside the <code>data</code> directory to store the documents you want to index:</p> <pre>mkdir -p applications/lightrag/data/input\n</pre>"},{"location":"graphrag/lightrag/#add-documents-to-the-input-folder","title":"Add Documents to the Input Folder\u00b6","text":"<p>Copy your documents (e.g., <code>fin.txt</code>) into the <code>applications/lightrag/data/input</code> folder. Ensure that the JSON files in the <code>applications/lightrag/data</code> folder are removed before rerunning the Jupyter Notebook.</p>"},{"location":"graphrag/lightrag/#indexing","title":"Indexing\u00b6","text":"<p>The following code sets up a working directory and demonstrates how to index a given document using LightRAG.</p>"},{"location":"graphrag/lightrag/#querying","title":"Querying\u00b6","text":"<p>The following code demonstrates how to perform a query in LightRAG using the TigerGraph graph storage implementation.</p>"},{"location":"graphrag/msft_graphrag_1/","title":"Supporting Microsoft\u2019s GraphRAG: Part 1 - Setup and Data Preparation","text":"<p>Microsoft's GraphRAG is a method for creating structured knowledge graphs from raw text, enhancing Retrieval Augmented Generation (RAG) tasks. By organizing information hierarchically, it enables more efficient data retrieval and summarization.</p>"},{"location":"graphrag/msft_graphrag_1/#what-youll-learn-in-this-guide","title":"What You\u2019ll Learn in This Guide","text":"<ul> <li>Indexing: Utilize Microsoft's GraphRAG to convert unstructured documents into Parquet files.</li> <li>Data Preprocessing: Learn how to use utility methods provided by TigerGraphX to transform Parquet files into CSV files compatible with TigerGraph.</li> </ul>"},{"location":"graphrag/msft_graphrag_1/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you\u2019ve completed the installation and setup steps outlined in the Installation Guide, including:</p> <ul> <li>Setting up Python and TigerGraph. For more details, refer to the Requirements section.</li> <li>Install TigerGraphX along with its development dependencies. For more details, refer to the Development Installation section.</li> </ul>"},{"location":"graphrag/msft_graphrag_1/#utilize-microsoft-graphrag-for-indexing","title":"Utilize Microsoft GraphRAG for Indexing","text":"<p>The indexing process transforms raw documents into structured data using Microsoft\u2019s GraphRAG. Follow these steps to prepare your data:</p>"},{"location":"graphrag/msft_graphrag_1/#data-preparation","title":"Data Preparation","text":""},{"location":"graphrag/msft_graphrag_1/#create-an-input-folder","title":"Create an Input Folder","text":"<p>Create an <code>input</code> folder in the <code>data</code> directory under <code>applications/msft_graphrag</code> to store the documents you want to index. You can specify a different directory by replacing <code>data</code> with your desired path.</p> <pre><code>mkdir -p data/input\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#add-documents-to-the-input-folder","title":"Add Documents to the Input Folder","text":"<p>Copy your documents into the <code>data/input</code> folder.</p> <p>For this demo, we will use the dataset A Christmas Carol by Charles Dickens.</p> <pre><code>curl https://www.gutenberg.org/cache/epub/24022/pg24022.txt -o data/input/book.txt\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#initialization","title":"Initialization","text":"<p>Initialize the indexing system in the <code>data</code> directory.</p> <pre><code>python3 -m graphrag init --root data\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#set-up-openai-api-key","title":"Set Up OpenAI API Key","text":"<p>GraphRAG requires an OpenAI API key. To configure it:</p> <ol> <li>Open the <code>.env</code> file in the <code>data</code> directory:    <pre><code>vi data/.env\n</code></pre></li> <li>Add your API key:    <pre><code>GRAPHRAG_API_KEY=&lt;Your OpenAI API Key&gt;\n</code></pre></li> </ol>"},{"location":"graphrag/msft_graphrag_1/#optional-switch-to-a-cost-effective-model","title":"Optional: Switch to a Cost-Effective Model","text":"<p>GraphRAG uses the <code>gpt-4-turbo-preview</code> model by default. To reduce costs, switch to the <code>gpt-4o-mini</code> model by editing the <code>settings.yaml</code> file in the <code>data</code> directory:</p> <pre><code>llm:\n  api_key: ${GRAPHRAG_API_KEY}\n  type: openai_chat # or azure_openai_chat\n  model: gpt-4o-mini # Use a cost-effective model\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#indexing","title":"Indexing","text":"<p>Run the indexing process to convert documents into structured data. This step uses LLMs and may take several minutes depending on the dataset size and hardware.</p> <pre><code>python3 -m graphrag index --no-cache --root data\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#utilize-tigergraphx-for-data-preprocessing","title":"Utilize TigerGraphX for Data Preprocessing","text":"<p>Transform the structured Parquet files generated by GraphRAG into CSV files that TigerGraph can import.</p>"},{"location":"graphrag/msft_graphrag_1/#convert-parquet-to-csv","title":"Convert Parquet to CSV","text":"<p>Run the script below to convert Parquet files into TigerGraph-compatible CSV files. You can find the Python script here.</p> <pre><code>python3 data_import/convert_parquet_to_tg_csv.py \\\n--input_dir data/output \\\n--output_dir data/tg_csv\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#export-data-from-lancedb-to-csv","title":"Export Data from LanceDB to CSV","text":"<p>Use the script below to export data from LanceDB into CSV files that are compatible with TigerGraph. You can access the Python script here.</p> <pre><code>python3 data_import/export_lancedb_to_csv.py \\\n--input_dir data/output/lancedb \\\n--output_dir data/tg_csv\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#transfer-csv-files-to-tigergraph-server","title":"Transfer CSV Files to TigerGraph Server","text":"<p>Transfer the generated CSV files to your TigerGraph server. Use the following command, replacing <code>username</code> and <code>tigergraph-server</code> with your server credentials:</p> <pre><code>scp data/tg_csv/* username@tigergraph-server:/home/tigergraph/data/graphrag\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#next-steps","title":"Next Steps","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 2: Use Jupyter Notebook to create the schema and load data into TigerGraph.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_2/","title":"Part 2 - Graph Creation and Data Loading","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph\nresource_dir = \"../../applications/msft_graphrag/query/resources/\"\ngraph_schema = resource_dir + \"graph_schema.yaml\"\n</pre> from tigergraphx import Graph resource_dir = \"../../applications/msft_graphrag/query/resources/\" graph_schema = resource_dir + \"graph_schema.yaml\" In\u00a0[2]: Copied! <pre>connection = {\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n}\n</pre> connection = {     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", } In\u00a0[3]: Copied! <pre>G = Graph(\n    graph_schema=graph_schema,\n    tigergraph_connection_config=connection,\n    drop_existing_graph=False,\n)\n</pre> G = Graph(     graph_schema=graph_schema,     tigergraph_connection_config=connection,     drop_existing_graph=False, ) <pre>2025-01-05 23:22:37,193 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph GraphRAG...\n2025-01-05 23:23:30,577 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n</pre> In\u00a0[4]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>0\n</pre> <p>After that, we will load data into the graph using a pre-defined loading job configuration. The configuration is stored in a YAML file. Note that loading the data may take several seconds.</p> In\u00a0[5]: Copied! <pre>loading_job_config = resource_dir + \"loading_job_config.yaml\"\nG.load_data(loading_job_config)\n</pre> loading_job_config = resource_dir + \"loading_job_config.yaml\" G.load_data(loading_job_config) <p>Now, let's check the total number of nodes in the graph again. We should observe that some nodes have been successfully loaded into the graph.</p> In\u00a0[6]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>371\n</pre>"},{"location":"graphrag/msft_graphrag_2/#supporting-microsofts-graphrag-part-2-graph-creation-and-data-loading","title":"Supporting Microsoft\u2019s GraphRAG: Part 2 - Graph Creation and Data Loading\u00b6","text":"<p>In the previous section, we used Microsoft's GraphRAG to convert unstructured documents into Parquet files, and then used TigerGraphX to transform these files into CSV format.</p> <p>Now, let\u2019s use Jupyter Notebook to create the schema and load the CSV files into TigerGraph.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_2.ipynb.</p>"},{"location":"graphrag/msft_graphrag_2/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p>"},{"location":"graphrag/msft_graphrag_2/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>The graph schema can be defined using a YAML file, a JSON file, or a Python dictionary. In this example, we will initialize a graph using a schema defined in a YAML file. The schema structure is represented visually in the following image.</p> <p></p>"},{"location":"graphrag/msft_graphrag_2/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, you also need a connection configuration to establish communication with the TigerGraph server. You can connect using either a username/password, a secret, or a token. Below is an example of connecting to TigerGraph using a username and password.</p>"},{"location":"graphrag/msft_graphrag_2/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"graphrag/msft_graphrag_2/#load-data","title":"Load Data\u00b6","text":"<p>First, let's check the total number of nodes in the graph. As anticipated, the graph is currently empty.</p>"},{"location":"graphrag/msft_graphrag_2/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 3: Use Jupyter Notebook to explore graph data and perform Graph Analysis.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_3/","title":"Part 3 - Graph Analysis","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph\nconnection = {\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n}\nG = Graph.from_db(\"GraphRAG\", connection)\n</pre> from tigergraphx import Graph connection = {     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", } G = Graph.from_db(\"GraphRAG\", connection) <pre>2025-01-05 23:30:15,203 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph GraphRAG...\n2025-01-05 23:30:15,223 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n</pre> In\u00a0[2]: Copied! <pre>schema = G.get_schema()\nprint(schema[\"graph_name\"])\n</pre> schema = G.get_schema() print(schema[\"graph_name\"]) <pre>GraphRAG\n</pre> In\u00a0[3]: Copied! <pre>for node in schema[\"nodes\"].items():\n    print(node)\n</pre> for node in schema[\"nodes\"].items():     print(node) <pre>('Document', {'primary_key': 'id', 'attributes': {'title': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}, 'vector_attributes': {}})\n('TextUnit', {'primary_key': 'id', 'attributes': {'text': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'n_tokens': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}, 'vector_attributes': {}})\n('Entity', {'primary_key': 'id', 'attributes': {'human_readable_id': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'name': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'entity_type': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'description': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}, 'vector_attributes': {}})\n('Relationship', {'primary_key': 'id', 'attributes': {'human_readable_id': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'rank': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'weight': {'data_type': &lt;DataType.DOUBLE: 'DOUBLE'&gt;, 'default_value': None}, 'description': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}, 'vector_attributes': {}})\n('Community', {'primary_key': 'id', 'attributes': {'level': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'rank': {'data_type': &lt;DataType.DOUBLE: 'DOUBLE'&gt;, 'default_value': None}, 'rank_explanation': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'title': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'full_content': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'summary': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}, 'vector_attributes': {}})\n</pre> In\u00a0[4]: Copied! <pre>for edge in schema[\"edges\"].items():\n    print(edge)\n</pre> for edge in schema[\"edges\"].items():     print(edge) <pre>('document_contains_text_unit', {'is_directed_edge': False, 'from_node_type': 'Document', 'to_node_type': 'TextUnit', 'discriminator': set(), 'attributes': {}})\n('text_unit_contains_entity', {'is_directed_edge': False, 'from_node_type': 'TextUnit', 'to_node_type': 'Entity', 'discriminator': set(), 'attributes': {}})\n('text_unit_contains_relationship', {'is_directed_edge': False, 'from_node_type': 'TextUnit', 'to_node_type': 'Relationship', 'discriminator': set(), 'attributes': {}})\n('relationship_source', {'is_directed_edge': False, 'from_node_type': 'Relationship', 'to_node_type': 'Entity', 'discriminator': set(), 'attributes': {}})\n('relationship_target', {'is_directed_edge': False, 'from_node_type': 'Relationship', 'to_node_type': 'Entity', 'discriminator': set(), 'attributes': {}})\n('community_contains_entity', {'is_directed_edge': False, 'from_node_type': 'Community', 'to_node_type': 'Entity', 'discriminator': set(), 'attributes': {}})\n('community_contains_relationship', {'is_directed_edge': False, 'from_node_type': 'Community', 'to_node_type': 'Relationship', 'discriminator': set(), 'attributes': {}})\n</pre> In\u00a0[5]: Copied! <pre>G.number_of_nodes()\n</pre> G.number_of_nodes() Out[5]: <pre>371</pre> In\u00a0[6]: Copied! <pre>for node_type in schema[\"nodes\"]:\n    print(f\"{node_type}: {G.number_of_nodes(node_type)}\")\n</pre> for node_type in schema[\"nodes\"]:     print(f\"{node_type}: {G.number_of_nodes(node_type)}\") <pre>Document: 1\nTextUnit: 42\nEntity: 138\nRelationship: 168\nCommunity: 22\n</pre> In\u00a0[7]: Copied! <pre>G.number_of_edges()\n</pre> G.number_of_edges() Out[7]: <pre>1545</pre> In\u00a0[8]: Copied! <pre>for edge_type in schema[\"edges\"]:\n    print(f\"{edge_type}: {G.number_of_edges(edge_type)}\")\n</pre> for edge_type in schema[\"edges\"]:     print(f\"{edge_type}: {G.number_of_edges(edge_type)}\") <pre>document_contains_text_unit: 42\ntext_unit_contains_entity: 274\ntext_unit_contains_relationship: 238\nrelationship_source: 168\nrelationship_target: 168\ncommunity_contains_entity: 236\ncommunity_contains_relationship: 419\n</pre> In\u00a0[9]: Copied! <pre>G.get_nodes(node_type=\"Entity\", limit=2)\n</pre> G.get_nodes(node_type=\"Entity\", limit=2) Out[9]: v_id v_type human_readable_id entity_type name description id 0 473502492d0a419981fed4fbc1493832 Entity 69 PERSON THE THREE MISS FEZZIWIGS Daughters of Mr. and Mrs. Fezziwig, described ... 473502492d0a419981fed4fbc1493832 1 6fb90dc954fe40d5969f7532a66376e9 Entity 108 PERSON WANT Want is depicted as a girl, symbolizing povert... 6fb90dc954fe40d5969f7532a66376e9 In\u00a0[10]: Copied! <pre>G.get_nodes(node_type=\"Relationship\", limit=2)\n</pre> G.get_nodes(node_type=\"Relationship\", limit=2) Out[10]: v_id v_type human_readable_id rank weight description id 0 9953ed9db4c5418e8bf9fee18032c0da Relationship 63 9 20 Fezziwig and Mrs. Fezziwig share a close perso... 9953ed9db4c5418e8bf9fee18032c0da 1 e9953a1648364e878d835bc6bcc0d3ef Relationship 37 5 1 The activities and cheer that the Ghost of Chr... e9953a1648364e878d835bc6bcc0d3ef In\u00a0[11]: Copied! <pre>G.get_nodes(node_type=\"Community\", limit=2)\n</pre> G.get_nodes(node_type=\"Community\", limit=2) Out[11]: v_id v_type summary level full_content rank id rank_explanation title 0 12 Community This report delves into the interconnected rel... 1 # The Transformation of Ebenezer Scrooge: A Ch... 8.5 12 The high impact severity rating reflects the p... Community 12 1 7 Community This report explores the network surrounding P... 0 # Project Gutenberg and the Digital Disseminat... 8.5 7 The high impact severity rating reflects Proje... Community 7"},{"location":"graphrag/msft_graphrag_3/#supporting-microsofts-graphrag-part-3-graph-analysis","title":"Supporting Microsoft\u2019s GraphRAG: Part 3 - Graph Analysis\u00b6","text":"<p>In the previous section, we have created a graph in TigerGraph, and loaded the CSV data into it.</p> <p>Now, let\u2019s use Jupyter Notebook to explore the graph data and perform graph analysis.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_3.ipynb.</p>"},{"location":"graphrag/msft_graphrag_3/#get-the-graph-from-tigergraph","title":"Get the Graph from TigerGraph\u00b6","text":"<p>Since the graph has already been created in TigerGraph, redefining its schema is unnecessary. Instead, you can provide the graph name to retrieve it. TigerGraphX will verify if the graph exists in TigerGraph and, if it does, will return the corresponding graph.</p>"},{"location":"graphrag/msft_graphrag_3/#display-the-graph-schema","title":"Display the Graph Schema\u00b6","text":"<p>Let's retrieve the graph schema using the <code>get_schema</code> method. The output is a Python dictionary containing three keys: <code>\"graph_name\"</code>, <code>\"nodes\"</code>, and <code>\"edges\"</code>. We'll print each of them individually to explore the schema details.</p>"},{"location":"graphrag/msft_graphrag_3/#retrieve-the-graph-schema-and-display-the-graph-name","title":"Retrieve the Graph Schema and Display the Graph Name\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-the-node-tyeps","title":"Display the Node Tyeps\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-the-edge-types","title":"Display the Edge Types\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-node-and-edge-counts","title":"Display Node and Edge Counts\u00b6","text":"<p>Gain deeper insights into the graph by exploring details such as the total number of nodes and the count of nodes for each node type.</p>"},{"location":"graphrag/msft_graphrag_3/#display-the-total-number-of-nodes","title":"Display the Total Number of Nodes\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-the-count-of-nodes-for-each-node-type","title":"Display the Count of Nodes for Each Node Type\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-the-total-number-of-edges","title":"Display the Total Number of Edges\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#display-the-count-of-edges-for-each-edge-type","title":"Display the Count of Edges for Each Edge Type\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#retrieve-sample-nodes-from-the-graph","title":"Retrieve Sample Nodes from the Graph\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#whats-next","title":"What\u2019s Next?\u00b6","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 4: Perform queries using GSQL and Python-native TigerGraphX, with global and local context builders.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_4/","title":"Part 4 - Hybrid Retrieval and Integration with LLM","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph, TigerGraphConnectionConfig\nconnection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\nG = Graph.from_db(\"GraphRAG\", connection)\n</pre> from tigergraphx import Graph, TigerGraphConnectionConfig connection = TigerGraphConnectionConfig.ensure_config({     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", }) G = Graph.from_db(\"GraphRAG\", connection) <pre>2025-01-05 23:51:06,143 - tigergraphx.core.graph.base_graph - INFO - Creating schema for graph GraphRAG...\n2025-01-05 23:51:06,152 - tigergraphx.core.graph.base_graph - INFO - Schema created successfully.\n</pre> In\u00a0[2]: Copied! <pre>G.get_nodes(\n    node_type=\"Entity\",\n    return_attributes=[\"id\", \"name\", \"entity_type\", \"description\"],\n    limit=2,\n)\n</pre> G.get_nodes(     node_type=\"Entity\",     return_attributes=[\"id\", \"name\", \"entity_type\", \"description\"],     limit=2, ) Out[2]: id name entity_type description 0 473502492d0a419981fed4fbc1493832 THE THREE MISS FEZZIWIGS PERSON Daughters of Mr. and Mrs. Fezziwig, described ... 1 6fb90dc954fe40d5969f7532a66376e9 WANT PERSON Want is depicted as a girl, symbolizing povert... In\u00a0[3]: Copied! <pre>start_nodes = [\"473502492d0a419981fed4fbc1493832\", \"6fb90dc954fe40d5969f7532a66376e9\"]\nG.get_neighbors(\n    start_nodes=start_nodes,\n    start_node_type=\"Entity\",\n    edge_types=\"community_contains_entity\",\n    return_attributes=[\"id\", \"title\", \"full_content\"],\n)\n</pre> start_nodes = [\"473502492d0a419981fed4fbc1493832\", \"6fb90dc954fe40d5969f7532a66376e9\"] G.get_neighbors(     start_nodes=start_nodes,     start_node_type=\"Entity\",     edge_types=\"community_contains_entity\",     return_attributes=[\"id\", \"title\", \"full_content\"], ) Out[3]: id title full_content 0 9 Community 9 # The Transformation of Ebenezer Scrooge: A St... 1 0 Community 0 # The Transformation Journey of Ebenezer Scroo... 2 19 Community 19 # The Transformation of Ebenezer Scrooge: A Ch... 3 1 Community 1 # Fezziwig's Christmas Celebration Community\\n... In\u00a0[4]: Copied! <pre>import random\nrandom_floats: list[float] = [random.random() for _ in range(1536)]\nresults = G.search(\n    data=random_floats,\n    vector_attribute_name=\"emb_description\",\n    node_type=\"Entity\",\n    limit=1,\n)\nprint(results)\n</pre> import random random_floats: list[float] = [random.random() for _ in range(1536)] results = G.search(     data=random_floats,     vector_attribute_name=\"emb_description\",     node_type=\"Entity\",     limit=1, ) print(results) <pre>[{'id': '9b24fbfeb0e94dd889c10700718b048f', 'distance': 0.9512004, 'human_readable_id': 83, 'name': 'GROCER', 'entity_type': '', 'description': ''}]\n</pre> In\u00a0[5]: Copied! <pre>import tiktoken\nfrom typing import Optional, List\nfrom tigergraphx.graphrag import BaseContextBuilder\nfrom tigergraphx.core import Graph\nclass GlobalContextBuilder(BaseContextBuilder):\n    def __init__(\n        self,\n        graph: Graph,\n        token_encoder: Optional[tiktoken.Encoding] = None,\n    ):\n        \"\"\"Initialize LocalContextBuilder with graph config and token encoder.\"\"\"\n        super().__init__(\n            graph=graph,\n            single_batch=False,\n            token_encoder=token_encoder,\n        )\n    async def build_context(self) -&gt; str | List[str]:\n        \"\"\"Build local context.\"\"\"\n        context: List[str] = []\n        config = {\n            \"max_tokens\": 12000,\n            \"section_name\": \"Communities\",\n            \"return_attributes\": [\"id\", \"rank\", \"title\", \"full_content\"],\n            \"limit\": 1000,\n        }\n        df = self.graph.get_nodes(\n            node_type=\"Community\",\n            return_attributes=config[\"return_attributes\"],\n            limit=config[\"limit\"],\n        )\n        if df is not None:\n            text_context = self.batch_and_convert_to_text(\n                graph_data=df,\n                max_tokens=config[\"max_tokens\"],\n                single_batch=self.single_batch,\n                section_name=config[\"section_name\"],\n            )\n            context.extend(\n                text_context if isinstance(text_context, list) else [text_context]\n            )\n        return context\n</pre> import tiktoken from typing import Optional, List from tigergraphx.graphrag import BaseContextBuilder from tigergraphx.core import Graph class GlobalContextBuilder(BaseContextBuilder):     def __init__(         self,         graph: Graph,         token_encoder: Optional[tiktoken.Encoding] = None,     ):         \"\"\"Initialize LocalContextBuilder with graph config and token encoder.\"\"\"         super().__init__(             graph=graph,             single_batch=False,             token_encoder=token_encoder,         )     async def build_context(self) -&gt; str | List[str]:         \"\"\"Build local context.\"\"\"         context: List[str] = []         config = {             \"max_tokens\": 12000,             \"section_name\": \"Communities\",             \"return_attributes\": [\"id\", \"rank\", \"title\", \"full_content\"],             \"limit\": 1000,         }         df = self.graph.get_nodes(             node_type=\"Community\",             return_attributes=config[\"return_attributes\"],             limit=config[\"limit\"],         )         if df is not None:             text_context = self.batch_and_convert_to_text(                 graph_data=df,                 max_tokens=config[\"max_tokens\"],                 single_batch=self.single_batch,                 section_name=config[\"section_name\"],             )             context.extend(                 text_context if isinstance(text_context, list) else [text_context]             )         return context <p>Here\u2019s how you can utilize the custom global context builder:</p> In\u00a0[6]: Copied! <pre>global_context_builder = GlobalContextBuilder(G)\ncontext_list = await global_context_builder.build_context()\n# Print the first 1000 characters for easier visualization of long text\nprint(context_list[0][:1000])\n</pre> global_context_builder = GlobalContextBuilder(G) context_list = await global_context_builder.build_context() # Print the first 1000 characters for easier visualization of long text print(context_list[0][:1000]) <pre>-----Communities-----\nid|rank|title|full_content\n18|8.5|Community 18|# Project Gutenberg Ecosystem\\n\\nThe Project Gutenberg ecosystem is a collaborative network focused on the free distribution of electronic literature. Central to this community are the Project Gutenberg Literary Archive Foundation, Project Gutenberg\u2122, and its electronic works, supported by a structure of copyright management, royalty fees, and the pioneering efforts of Michael S. Hart. This network facilitates the global dissemination of literature in digital formats, ensuring accessibility and promoting literary heritage.\\n\\n## The foundational role of the Project Gutenberg Literary Archive Foundation\\n\\nThe Project Gutenberg Literary Archive Foundation is pivotal in the Project Gutenberg ecosystem, managing copyrights and the Project Gutenberg trademark. It receives donations and royalties, supporting the mission to preserve and provide free access to electronic works. This foundation ensures the sustainability of P\n</pre>"},{"location":"graphrag/msft_graphrag_4/#supporting-microsofts-graphrag-part-4-hybrid-retrieval-and-integration-with-llm","title":"Supporting Microsoft\u2019s GraphRAG: Part 4 - Hybrid Retrieval and Integration with LLM\u00b6","text":"<p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_4.ipynb.</p>"},{"location":"graphrag/msft_graphrag_4/#get-the-graph-from-tigergraph","title":"Get the Graph from TigerGraph\u00b6","text":""},{"location":"graphrag/msft_graphrag_4/#hybrid-retrieval","title":"Hybrid Retrieval\u00b6","text":"<p>TigerGraph offers two flexible ways to perform hybrid retrieval, allowing you to extract relevant graph and vector data efficiently for GraphRAG workflows.</p>"},{"location":"graphrag/msft_graphrag_4/#using-tigergraphx","title":"Using TigerGraphX\u00b6","text":"<p>TigerGraphX offers an intuitive, Python-native interface for hybrid retrieval, ideal for developers seeking simplicity and ease of use.</p> <p>Key Advantage: Minimal learning curve with high-level Python APIs, seamlessly integrated with existing workflows.</p> <p>Below are some illustrative examples.</p>"},{"location":"graphrag/msft_graphrag_4/#retrieve-nodes-with-specific-attributes","title":"Retrieve Nodes with Specific Attributes\u00b6","text":"<p>You can use the following code to fetch up to two nodes of type \"Entity\" and display their \"id,\" \"entity_type,\" and \"description\" attributes.</p>"},{"location":"graphrag/msft_graphrag_4/#retrieve-neighbors-with-specific-attributes","title":"Retrieve Neighbors with Specific Attributes\u00b6","text":"<p>The following code demonstrates how to fetch neighbors of specific nodes. In this example, the query retrieves neighbors connected to the given <code>start_nodes</code> of type <code>\"Entity\"</code> through the edge type <code>\"community_contains_entity\"</code>. The attributes <code>\"id\"</code>, <code>\"title\"</code>, and <code>\"full_content\"</code> of the neighbors are returned.</p>"},{"location":"graphrag/msft_graphrag_4/#retrieve-top-k-using-tigervectors-vector-search-capability","title":"Retrieve Top-K Using TigerVector's Vector Search Capability\u00b6","text":"<p>The following code generates a random query vector of 1536 float values and uses it to perform a vector search on a TigerGraph instance. The search finds the most similar \"Entity\" nodes based on the \"emb_description\" vector attribute and returns the top result.</p>"},{"location":"graphrag/msft_graphrag_4/#using-gsql","title":"Using GSQL\u00b6","text":"<p>For developers seeking fine-grained control or complex retrieval logic, GSQL offers unmatched flexibility. As TigerGraph's built-in query language, GSQL empowers you to perform advanced graph data analysis. For more details, see the official documentation.</p> <p>Key Advantage: Supports complex logic, customization, and direct interaction with TigerGraph\u2019s powerful query engine.</p> <ol> <li>Use an LLM to convert the query into an embedding.</li> <li>Write a GSQL query to retrieve the top-K similar objects and their neighbors, combining structured and vector-based retrieval:</li> </ol> <pre>CREATE OR REPLACE QUERY my_query (\n    LIST&lt;float&gt; query_vector,\n    int k\n) SYNTAX v3 {\n  Nodes = vectorSearch({Entity.emb_description}, query_vector, k);\n  PRINT Nodes;\n\n  Neighbors =\n    SELECT t\n    FROM (s:Nodes)-[e:community_contains_entity]-&gt;(t:Community);\n\n  print Neighbors[Neighbors.id, Neighbors.title, Neighbors.full_content];\n}\n</pre>"},{"location":"graphrag/msft_graphrag_4/#context-building-writing-custom-context-builders","title":"Context Building: Writing Custom Context Builders\u00b6","text":"<p>Context builders play a vital role in graph-powered RAG workflows. They transform retrieved graph data into structured, meaningful contexts for tasks such as interactions with LLMs).</p> <p>TigerGraphX simplifies this process by offering the flexible <code>BaseContextBuilder</code> class, which allows developers to define custom logic for context building.</p>"},{"location":"graphrag/msft_graphrag_4/#key-features-of-basecontextbuilder","title":"Key Features of <code>BaseContextBuilder</code>\u00b6","text":"<p>The <code>BaseContextBuilder</code> class in TigerGraphX provides a strong foundation for creating custom context builders, offering:</p> <ul> <li>Core Abstraction: A reusable framework for building context logic.</li> <li>Customizable Design: Extensibility for implementing both global and query-specific context generation.</li> </ul>"},{"location":"graphrag/msft_graphrag_4/#key-components","title":"Key Components\u00b6","text":"<ol> <li><p>Abstract Method - <code>build_context</code>: Subclasses must implement this method to define the logic for constructing context.</p> <pre>@abstractmethod\nasync def build_context(self, *args, **kwargs) -&gt; str | List[str]:\n    \"\"\"Abstract method to build context.\"\"\"\n    pass\n</pre> </li> <li><p>Batching and Retrieval Methods:</p> <ul> <li><code>batch_and_convert_to_text</code>: Formats graph data into token-aware text.</li> <li><code>retrieve_top_k_objects</code>: Efficiently retrieves top-K objects for query-based context.</li> </ul> </li> </ol>"},{"location":"graphrag/msft_graphrag_4/#example-global-context-builder","title":"Example: Global Context Builder\u00b6","text":""},{"location":"graphrag/msft_graphrag_4/#example-local-context-builder","title":"Example: Local Context Builder\u00b6","text":"<p>To understand the functionality of the <code>LocalContextBuilder</code> class, let's review the key code from its <code>build_context</code> method.</p> <p></p> <pre><code># Retrieve top-k objects\ntop_k_objects: List[str] = await self.retrieve_top_k_objects(query, k=k)\n...\n# Iterate over different neighbor types\nfor neighbor in neighbor_types:\n    df = self.graph.get_neighbors(...)\n    if df is not None:\n        text_context = self.batch_and_convert_to_text(...)\n        context.extend(\n            text_context if isinstance(text_context, list) else [text_context]\n        )\nreturn \"\\n\\n\".join(context)\n</code></pre> <p>For full implementations of different context builders, refer to the following links:</p> <ul> <li>LocalContextBuilder Code</li> </ul> <p>Here\u2019s how you can utilize the custom local context builder:</p> <pre>local_builder = LocalContextBuilder(graph=graph, search_engine=search_engine)\nlocal_context = await local_builder.build_context(query=\"What are the main topics discussed in the article?\")\n</pre>"},{"location":"graphrag/msft_graphrag_4/#integrate-with-llm","title":"Integrate with LLM\u00b6","text":"<p>After successfully building context from TigerGraph, the final step is integrating it with LLMs, including chat models and embedding models.</p> <p>We have provided an example implementation, which you can find here: Example Code.</p>"},{"location":"graphrag/msft_graphrag_4/#workflow-overview","title":"Workflow Overview\u00b6","text":"<p>The integration process follows the workflow illustrated below:</p> <p></p>"},{"location":"graphrag/msft_graphrag_4/#whats-next","title":"What\u2019s Next?\u00b6","text":"<ul> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"reference/features_overview/","title":"Features Overview","text":"<p>TigerGraphX is designed to simplify complex workflows involving graph databases, vector search, and large language models (LLMs). This page provides an overview of the key features of TigerGraphX and serves as a roadmap to the detailed API documentation for each functionality.</p>"},{"location":"reference/features_overview/#1-schema-management-graph-db","title":"1. Schema Management (Graph DB)","text":"<p>TigerGraphX provides intuitive, Python-native APIs for defining and managing graph schemas. This feature includes:</p> <ul> <li>Programmatic creation and modification of vertices and edges.</li> <li>Support for attributes, primary keys, and schema constraints.</li> <li>Compatibility with YAML and JSON schema definitions.</li> </ul>"},{"location":"reference/features_overview/#2-data-loading-management-graph-db","title":"2. Data Loading Management (Graph DB)","text":"<p>Efficiently load data into TigerGraph from a variety of sources. Key capabilities include:</p> <ul> <li>Support for Parquet and CSV files for high-efficiency workflows.</li> <li>Automated loading jobs to streamline the data import process.</li> <li>Data transformation utilities for pre-processing and compatibility.</li> </ul>"},{"location":"reference/features_overview/#3-graph-library-interface-graph-db-graph-query-language","title":"3. Graph Library Interface (Graph DB, Graph Query Language)","text":"<p>Perform common graph operations using Python-native APIs, including:</p> <ul> <li>CRUD operations for vertices and edges.</li> <li>Multi-hop traversals to analyze relationships in the graph.</li> <li>Graph reporting for insights and analysis.</li> </ul>"},{"location":"reference/features_overview/#4-graph-query-interface-graph-db-graph-query-language","title":"4. Graph Query Interface (Graph DB, Graph Query Language)","text":"<p>Execute advanced queries on your TigerGraph database with ease. This feature includes:</p> <ul> <li>Simplified query execution with Python-based methods.</li> <li>Query results formatted as Pandas DataFrames for seamless integration with analytics workflows.</li> </ul>"},{"location":"reference/features_overview/#5-vector-search-capabilities-vector-db","title":"5. Vector Search Capabilities (Vector DB)","text":"<p>Enhance AI-driven applications with vector embedding support. Key functionalities include:</p> <ul> <li>Storing and querying vector embeddings alongside graph data.</li> <li>Top-K similarity searches for retrieving the most relevant entities.</li> <li>Hybrid retrieval workflows combining graph traversal and vector search.</li> </ul>"},{"location":"reference/features_overview/#6-llm-integration-and-support-llm","title":"6. LLM Integration and Support (LLM)","text":"<p>Enable advanced applications by integrating graph data with large language models (LLMs). Key features:</p> <ul> <li>Token-aware context building for LLM workflows.</li> <li>Hybrid retrieval combining graph, semantic, and vector-based searches.</li> <li>Direct API integration with LLM platforms like OpenAI.</li> </ul>"},{"location":"reference/features_overview/#7-configuration-management-graph-db-vector-db-llm","title":"7. Configuration Management (Graph DB, Vector DB, LLM)","text":"<p>Simplify configuration for various integrations and workflows:</p> <ul> <li>Manage graph database settings programmatically.</li> <li>Configure vector search parameters for efficient retrieval.</li> <li>Customize LLM settings for seamless API interaction.</li> </ul>"},{"location":"reference/features_overview/#8-graphrag-support-graph-db-vector-db-llm","title":"8. GraphRAG Support (Graph DB, Vector DB, LLM)","text":"<p>TigerGraphX simplifies Graph-Retrieval Augmented Generation (GraphRAG) workflows. This feature includes:</p> <ul> <li>Schema definition and data preparation for GraphRAG.</li> <li>Hybrid retrieval methods optimized for GraphRAG use cases.</li> <li>Python-native APIs for context building and LLM integration.</li> </ul>"},{"location":"reference/features_overview/#next-steps","title":"Next Steps","text":"<p>To dive deeper into TigerGraphX\u2019s features, explore the detailed API documentation for each section. Start building powerful graph applications today!</p>"},{"location":"reference/01_core/graph/","title":"Graph","text":""},{"location":"reference/01_core/graph/#graph-class-overview","title":"Graph Class Overview","text":""},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.__init__","title":"<code>__init__(graph_schema, tigergraph_connection_config=None, drop_existing_graph=False)</code>","text":"<p>Initialize a Graph instance.</p> <p>Parameters:</p> <ul> <li> <code>graph_schema</code>               (<code>GraphSchema | Dict | str | Path</code>)           \u2013            <p>The schema of the graph.</p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig | Dict | str | Path]</code>, default:                   <code>None</code> )           \u2013            <p>Connection configuration for TigerGraph.</p> </li> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, drop existing graph before schema creation.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.from_db","title":"<code>from_db(graph_name, tigergraph_connection_config=None)</code>  <code>classmethod</code>","text":"<p>Retrieve an existing graph schema from TigerGraph and initialize a Graph.</p> <p>Parameters:</p> <ul> <li> <code>graph_name</code>               (<code>str</code>)           \u2013            <p>The name of the graph to retrieve.</p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig | Dict | str | Path]</code>, default:                   <code>None</code> )           \u2013            <p>Connection configuration for TigerGraph.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>An instance of Graph initialized from the database schema.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.nodes","title":"<code>nodes</code>  <code>property</code>","text":"<p>Return a NodeView instance.</p> <p>Returns:</p> <ul> <li> <code>NodeView</code>           \u2013            <p>The node view for the graph.</p> </li> </ul>"},{"location":"reference/01_core/graph/#schema-operations","title":"Schema Operations","text":"<p>The following methods handle schema operations:</p>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_schema","title":"<code>get_schema(format='dict')</code>","text":"<p>Get the schema of the graph.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>Literal['json', 'dict']</code>, default:                   <code>'dict'</code> )           \u2013            <p>Format of the schema.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | Dict</code>           \u2013            <p>The graph schema.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.create_schema","title":"<code>create_schema(drop_existing_graph=False)</code>","text":"<p>Create the graph schema.</p> <p>Parameters:</p> <ul> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, drop the graph before creation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if schema was created successfully.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.drop_graph","title":"<code>drop_graph()</code>","text":"<p>Drop the graph from TigerGraph.</p>"},{"location":"reference/01_core/graph/#data-loading-operations","title":"Data Loading Operations","text":"<p>The following methods handle data loading operations:</p>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.load_data","title":"<code>load_data(loading_job_config)</code>","text":"<p>Load data into the graph using the provided loading job configuration.</p> <p>Parameters:</p> <ul> <li> <code>loading_job_config</code>               (<code>LoadingJobConfig | Dict | str | Path</code>)           \u2013            <p>Loading job config.</p> </li> </ul>"},{"location":"reference/01_core/graph/#node-operations","title":"Node Operations","text":"<p>The following methods manage nodes:</p>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.add_node","title":"<code>add_node(node_id, node_type='', **attr)</code>","text":"<p>Add a node to the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node.</p> </li> <li> <code>**attr</code>           \u2013            <p>Additional attributes for the node.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.add_nodes_from","title":"<code>add_nodes_from(nodes_for_adding, node_type='', **attr)</code>","text":"<p>Add nodes from a list of IDs or tuples of ID and attributes.</p> <p>Parameters:</p> <ul> <li> <code>nodes_for_adding</code>               (<code>List[str] | List[Tuple[str, Dict[str, Any]]]</code>)           \u2013            <p>List of node IDs or (ID, attributes) tuples.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the nodes.</p> </li> <li> <code>**attr</code>           \u2013            <p>Common attributes for all nodes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[int]</code>           \u2013            <p>The number of nodes inserted (nodes that were updated are not counted).</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.remove_node","title":"<code>remove_node(node_id, node_type='')</code>","text":"<p>Remove a node from the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the node was removed, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.has_node","title":"<code>has_node(node_id, node_type='')</code>","text":"<p>Check if a node exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the node exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_node_data","title":"<code>get_node_data(node_id, node_type='')</code>","text":"<p>Get data for a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>The node data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_node_edges","title":"<code>get_node_edges(node_id, node_type='', edge_types=[])</code>","text":"<p>Get edges connected to a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node.</p> </li> <li> <code>edge_types</code>               (<code>List | str</code>, default:                   <code>[]</code> )           \u2013            <p>Types of edges to include.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Tuple]</code>           \u2013            <p>A list of edges represented as (from_id, to_id).</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.clear","title":"<code>clear()</code>","text":"<p>Clear all nodes from the graph.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if nodes were cleared.</p> </li> </ul>"},{"location":"reference/01_core/graph/#edge-operations","title":"Edge Operations","text":"<p>The following methods manage edges:</p>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.add_edge","title":"<code>add_edge(src_node_id, tgt_node_id, src_node_type='', edge_type='', tgt_node_type='', **attr)</code>","text":"<p>Add an edge to the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source node type.</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Edge type.</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Target node type.</p> </li> <li> <code>**attr</code>           \u2013            <p>Additional edge attributes.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.add_edges_from","title":"<code>add_edges_from(ebunch_to_add, src_node_type, edge_type, tgt_node_type, **attr)</code>","text":"<p>Add edges from a list of edge tuples.</p> <p>Parameters:</p> <ul> <li> <code>ebunch_to_add</code>               (<code>List[Tuple[str, str]] | List[Tuple[str, str, Dict[str, Any]]]</code>)           \u2013            <p>List of edges to add.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>)           \u2013            <p>Source node type.</p> </li> <li> <code>edge_type</code>               (<code>str</code>)           \u2013            <p>Edge type.</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>)           \u2013            <p>Target node type.</p> </li> <li> <code>**attr</code>           \u2013            <p>Common attributes for all edges.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[int]</code>           \u2013            <p>The number of edges inserted (edges that were updated are not counted).</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.has_edge","title":"<code>has_edge(src_node_id, tgt_node_id, src_node_type='', edge_type='', tgt_node_type='')</code>","text":"<p>Check if an edge exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str | int</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str | int</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source node type.</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Edge type.</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Target node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the edge exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_edge_data","title":"<code>get_edge_data(src_node_id, tgt_node_id, src_node_type='', edge_type='', tgt_node_type='')</code>","text":"<p>Get data for a specific edge.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source node type.</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Edge type.</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Target node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>The edge data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#statistics-operations","title":"Statistics Operations","text":"<p>The following methods handle statistics operations:</p>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_edge_data","title":"<code>get_edge_data(src_node_id, tgt_node_id, src_node_type='', edge_type='', tgt_node_type='')</code>","text":"<p>Get data for a specific edge.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source node type.</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Edge type.</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Target node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>The edge data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#query-operations","title":"Query Operations","text":"<p>The following methods perform query operations:</p>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.run_query","title":"<code>run_query(query_name, params={})</code>","text":"<p>Run a pre-installed query on the graph.</p> <p>Parameters:</p> <ul> <li> <code>query_name</code>               (<code>str</code>)           \u2013            <p>Name of the query.</p> </li> <li> <code>params</code>               (<code>Dict</code>, default:                   <code>{}</code> )           \u2013            <p>Parameters for the query.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The query result or None if an error occurred.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_nodes","title":"<code>get_nodes(node_type='', all_node_types=False, filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Retrieve nodes from the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Node type to retrieve.</p> </li> <li> <code>all_node_types</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, ignore filtering by node type.</p> </li> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of nodes to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>A DataFrame of nodes or None.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_nodes_from_spec","title":"<code>get_nodes_from_spec(spec)</code>","text":"<p>Retrieve nodes using a NodeSpec object.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>NodeSpec</code>)           \u2013            <p>Specification for node retrieval.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>A DataFrame of nodes or None.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_neighbors","title":"<code>get_neighbors(start_nodes, start_node_type='', edge_types=None, target_node_types=None, filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Get neighbors of specified nodes.</p> <p>Parameters:</p> <ul> <li> <code>start_nodes</code>               (<code>str | List[str]</code>)           \u2013            <p>Starting node or nodes.</p> </li> <li> <code>start_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Type of starting nodes.</p> </li> <li> <code>edge_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Edge types to consider.</p> </li> <li> <code>target_node_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Types of target nodes.</p> </li> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of neighbors.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>A DataFrame of neighbors or None.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.get_neighbors_from_spec","title":"<code>get_neighbors_from_spec(spec)</code>","text":"<p>Retrieve neighbors using a NeighborSpec object.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>NeighborSpec</code>)           \u2013            <p>Specification for neighbor retrieval.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>A DataFrame of neighbors or None.</p> </li> </ul>"},{"location":"reference/01_core/graph/#vector-operations","title":"Vector Operations","text":"<p>The following methods handle vector operations:</p>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.upsert","title":"<code>upsert(data, node_type='')</code>","text":"<p>Upsert nodes with vector data into the graph.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Dict | List[Dict]</code>)           \u2013            <p>Record(s) to upsert.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The node type for the upsert operation.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The result of the upsert operation or None if an error occurs.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.fetch_node","title":"<code>fetch_node(node_id, vector_attribute_name, node_type='')</code>","text":"<p>Fetch the embedding vector for a single node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The node's identifier.</p> </li> <li> <code>vector_attribute_name</code>               (<code>str</code>)           \u2013            <p>The vector attribute name.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List[float]]</code>           \u2013            <p>The embedding vector or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.fetch_nodes","title":"<code>fetch_nodes(node_ids, vector_attribute_name, node_type='')</code>","text":"<p>Fetch embedding vectors for multiple nodes.</p> <p>Parameters:</p> <ul> <li> <code>node_ids</code>               (<code>List[str]</code>)           \u2013            <p>List of node identifiers.</p> </li> <li> <code>vector_attribute_name</code>               (<code>str</code>)           \u2013            <p>The vector attribute name.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, List[float]]</code>           \u2013            <p>Mapping of node IDs to embedding vectors.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.search","title":"<code>search(data, vector_attribute_name, node_type='', limit=10, return_attributes=None, candidate_ids=None)</code>","text":"<p>Search for similar nodes based on a query vector.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>List[float]</code>)           \u2013            <p>Query vector.</p> </li> <li> <code>vector_attribute_name</code>               (<code>str</code>)           \u2013            <p>The vector attribute name.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The node type to search.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of nearest neighbors to return.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return.</p> </li> <li> <code>candidate_ids</code>               (<code>Optional[Set[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Limit search to these node IDs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Dict]</code>           \u2013            <p>List of similar nodes and their details.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.search_multi_vector_attributes","title":"<code>search_multi_vector_attributes(data, vector_attribute_names, node_types=None, limit=10, return_attributes_list=None)</code>","text":"<p>Search for similar nodes using multiple vector attributes.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>List[float]</code>)           \u2013            <p>Query vector.</p> </li> <li> <code>vector_attribute_names</code>               (<code>List[str]</code>)           \u2013            <p>List of vector attribute names.</p> </li> <li> <code>node_types</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>List of node types corresponding to the attributes.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of nearest neighbors to return.</p> </li> <li> <code>return_attributes_list</code>               (<code>Optional[List[List[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return per node type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Dict]</code>           \u2013            <p>List of similar nodes and their details.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.Graph.search_top_k_similar_nodes","title":"<code>search_top_k_similar_nodes(node_id, vector_attribute_name, node_type='', limit=5, return_attributes=None)</code>","text":"<p>Retrieve the top-k nodes similar to a given node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The source node's identifier.</p> </li> <li> <code>vector_attribute_name</code>               (<code>str</code>)           \u2013            <p>The embedding attribute name.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of nodes to search.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Number of similar nodes to return.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Dict]</code>           \u2013            <p>List of similar nodes.</p> </li> </ul>"},{"location":"reference/01_core/nodeview/","title":"NodeView","text":""},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView","title":"<code>NodeView</code>","text":""},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve data associated with a node.</p> <p>The interpretation of <code>key</code> depends on the graph's node type configuration:</p> <ul> <li>Single Node Type: Pass the node's identifier as <code>node_id</code>.</li> <li>Multiple Node Types: Pass a tuple in the form <code>(node_type, node_id)</code>.</li> </ul>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if a node exists.</p>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over all nodes. For homogeneous: return node_id. For heterogeneous: return (node_type, node_id).</p>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of nodes.</p>"},{"location":"reference/02_vector_search/embedding/","title":"Embedding","text":""},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.BaseEmbedding","title":"<code>BaseEmbedding</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for text embedding models.</p>"},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.BaseEmbedding.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the base embedding model.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseEmbeddingConfig</code>)           \u2013            <p>Configuration for the embedding model.</p> </li> </ul>"},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.BaseEmbedding.generate_embedding","title":"<code>generate_embedding(text)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Asynchronously generate an embedding for the given text.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>Input text to generate an embedding.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>A list of floats representing the text embedding.</p> </li> </ul>"},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding","title":"<code>OpenAIEmbedding</code>","text":"<p>               Bases: <code>BaseEmbedding</code>, <code>RetryMixin</code></p> <p>OpenAI Embedding model wrapper with async embedding generation and robust retries.</p>"},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding.__init__","title":"<code>__init__(llm_manager, config)</code>","text":"<p>Initialize the OpenAI Embedding wrapper.</p> <p>Parameters:</p> <ul> <li> <code>llm_manager</code>               (<code>OpenAIManager</code>)           \u2013            <p>Manager for OpenAI LLM interactions.</p> </li> <li> <code>config</code>               (<code>OpenAIEmbeddingConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for the embedding model.</p> </li> </ul>"},{"location":"reference/02_vector_search/embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding.generate_embedding","title":"<code>generate_embedding(text)</code>  <code>async</code>","text":"<p>Generate embedding asynchronously with retry for robustness.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The input text to generate embeddings for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>The normalized embedding vector.</p> </li> </ul>"},{"location":"reference/02_vector_search/search_engine/","title":"Search Engine","text":""},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.BaseSearchEngine","title":"<code>BaseSearchEngine</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for a search engine that performs text-to-vector searches in a vector store.</p>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.BaseSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the search engine with an embedding model and a vector database.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>BaseEmbedding</code>)           \u2013            <p>The model used to generate text embeddings.</p> </li> <li> <code>vector_db</code>               (<code>BaseVectorDB</code>)           \u2013            <p>The vector database for storing and querying embeddings.</p> </li> </ul>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.BaseSearchEngine.search","title":"<code>search(text, k=10, **kwargs)</code>  <code>async</code>","text":"<p>Convert text to embedding and search in the vector database.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The input text to search.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of top results to return.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments for the vector database query.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>A list of IDs corresponding to the search results.</p> </li> </ul>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.TigerVectorSearchEngine","title":"<code>TigerVectorSearchEngine</code>","text":"<p>               Bases: <code>BaseSearchEngine</code></p> <p>Search engine that performs text embedding and similarity search using OpenAI and TigerVector.</p>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.TigerVectorSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the TigerVectorSearchEngine.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>OpenAIEmbedding</code>)           \u2013            <p>The embedding model used for text-to-vector conversion.</p> </li> <li> <code>vector_db</code>               (<code>TigerVectorManager</code>)           \u2013            <p>The vector database for similarity search.</p> </li> </ul>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.NanoVectorDBSearchEngine","title":"<code>NanoVectorDBSearchEngine</code>","text":"<p>               Bases: <code>BaseSearchEngine</code></p> <p>Search engine that performs text embedding and similarity search using OpenAI and NanoVectorDB.</p>"},{"location":"reference/02_vector_search/search_engine/#tigergraphx.vector_search.search.NanoVectorDBSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the NanoVectorDBSearchEngine.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>OpenAIEmbedding</code>)           \u2013            <p>The embedding model used for text-to-vector conversion.</p> </li> <li> <code>vector_db</code>               (<code>NanoVectorDBManager</code>)           \u2013            <p>The vector database for similarity search.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/","title":"Vector DB","text":""},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB","title":"<code>BaseVectorDB</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for managing vector database connections.</p>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the vector database connection.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseVectorDBConfig</code>)           \u2013            <p>Configuration for the vector DB connection.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.insert_data","title":"<code>insert_data(data)</code>  <code>abstractmethod</code>","text":"<p>Insert data into the vector database.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>The data to insert.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.query","title":"<code>query(query_embedding, k=10)</code>  <code>abstractmethod</code>","text":"<p>Perform a similarity search and return matching IDs.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>The vector to search with.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of nearest neighbors to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List of result IDs.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.TigerVectorManager","title":"<code>TigerVectorManager</code>","text":"<p>               Bases: <code>BaseVectorDB</code></p> <p>Manages vector database operations for TigerGraph.</p>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.TigerVectorManager.__init__","title":"<code>__init__(config, graph)</code>","text":"<p>Initialize TigerVectorManager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>TigerVectorConfig | Dict | str | Path</code>)           \u2013            <p>Config for the vector database connection, given as a config  object, dictionary, string, or path to a configuration file.</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>Graph instance for managing nodes.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.TigerVectorManager.insert_data","title":"<code>insert_data(data)</code>","text":"<p>Insert data into TigerGraph.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame containing data to be inserted.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.TigerVectorManager.query","title":"<code>query(query_embedding, k=10)</code>","text":"<p>Perform k-NN search on the vector database.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>The query embedding vector.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of nearest neighbors to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List of identifiers from the search results.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.NanoVectorDBManager","title":"<code>NanoVectorDBManager</code>","text":"<p>               Bases: <code>BaseVectorDB</code></p> <p>A wrapper class for NanoVectorDB that implements BaseVectorDB.</p>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the NanoVectorDBManager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>NanoVectorDBConfig</code>)           \u2013            <p>Configuration for NanoVectorDB.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.insert_data","title":"<code>insert_data(data)</code>","text":"<p>Insert data into NanoVectorDB.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame with data to insert.</p> </li> </ul>"},{"location":"reference/02_vector_search/vector_db/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.query","title":"<code>query(query_embedding, k=10)</code>","text":"<p>Perform a similarity search and return the result IDs.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>Embedding vector for search.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of top results to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List of IDs from the search results.</p> </li> </ul>"},{"location":"reference/03_llm/chat/","title":"Chat","text":""},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.BaseChat","title":"<code>BaseChat</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for chat models.</p>"},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.BaseChat.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the chat model with the given configuration.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseChatConfig</code>)           \u2013            <p>Configuration for the chat model.</p> </li> </ul>"},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.BaseChat.chat","title":"<code>chat(messages)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Asynchronously process the messages and return the generated response.</p> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>List[Any]</code>)           \u2013            <p>A list of messages to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The generated response.</p> </li> </ul>"},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.OpenAIChat","title":"<code>OpenAIChat</code>","text":"<p>               Bases: <code>BaseChat</code>, <code>RetryMixin</code></p> <p>Implementation of BaseChat for OpenAI models.</p>"},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.OpenAIChat.__init__","title":"<code>__init__(llm_manager, config)</code>","text":"<p>Initialize the OpenAIChat with the provided LLM manager and configuration.</p> <p>Parameters:</p> <ul> <li> <code>llm_manager</code>               (<code>OpenAIManager</code>)           \u2013            <p>Manager for OpenAI LLM interactions.</p> </li> <li> <code>config</code>               (<code>OpenAIChatConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for OpenAI chat.</p> </li> </ul>"},{"location":"reference/03_llm/chat/#tigergraphx.llm.chat.OpenAIChat.chat","title":"<code>chat(messages)</code>  <code>async</code>","text":"<p>Asynchronously process the messages and return the generated response.</p> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>List[ChatCompletionMessageParam]</code>)           \u2013            <p>List of messages for chat completion.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The generated response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RetryError</code>             \u2013            <p>If retry attempts are exhausted.</p> </li> <li> <code>Exception</code>             \u2013            <p>For any unexpected errors during processing.</p> </li> </ul>"},{"location":"reference/03_llm/llm_manager/","title":"LLM Manager","text":""},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.BaseLLMManager","title":"<code>BaseLLMManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for LLM implementations.</p>"},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.BaseLLMManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the base LLM manager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseLLMConfig</code>)           \u2013            <p>Configuration for the LLM.</p> </li> </ul>"},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.BaseLLMManager.get_llm","title":"<code>get_llm()</code>  <code>abstractmethod</code>","text":"<p>Retrieve the initialized LLM instance.</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The initialized LLM instance.</p> </li> </ul>"},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.OpenAIManager","title":"<code>OpenAIManager</code>","text":"<p>               Bases: <code>BaseLLMManager</code></p> <p>Manages an asynchronous OpenAI instance for LLM operations.</p>"},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.OpenAIManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize OpenAIManager with OpenAI settings.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>OpenAIConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for OpenAI settings.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the API key is not provided in the configuration.</p> </li> </ul>"},{"location":"reference/03_llm/llm_manager/#tigergraphx.llm.OpenAIManager.get_llm","title":"<code>get_llm()</code>","text":"<p>Retrieve the initialized async OpenAI instance.</p> <p>Returns:</p> <ul> <li> <code>AsyncOpenAI</code>           \u2013            <p>The initialized OpenAI instance.</p> </li> </ul>"},{"location":"reference/04_config/base_config/","title":"BaseConfig","text":""},{"location":"reference/04_config/base_config/#tigergraphx.config.BaseConfig","title":"<code>BaseConfig</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Base configuration class that extends Pydantic's BaseSettings. Provides utility methods to load configurations from various sources.</p>"},{"location":"reference/04_config/base_config/#tigergraphx.config.BaseConfig.ensure_config","title":"<code>ensure_config(config)</code>  <code>classmethod</code>","text":"<p>Ensure the config is an instance of the current config class.</p> <p>If the input is a dictionary, string, or path to a YAML/JSON file, it is loaded and converted into an instance of the class.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>T | Path | str | Dict</code>)           \u2013            <p>The input configuration, which can be an instance of the config class, a dictionary, a file path, or a string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>An instance of the current configuration class.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the provided file path does not exist.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the file type is unsupported.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If the input type is not supported.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/loading_job_config/","title":"Loading Job Configuration","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig","title":"<code>LoadingJobConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for a loading job consisting of multiple files.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.loading_job_name","title":"<code>loading_job_name = Field(description='The name of the loading job.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.files","title":"<code>files = Field(description='A list of files included in the loading job.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.validate_file_aliases","title":"<code>validate_file_aliases()</code>","text":"<p>Ensure that all file_alias values are unique.</p> <p>Returns:</p> <ul> <li> <code>LoadingJobConfig</code>           \u2013            <p>The validated loading job configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If duplicate file_alias values are found.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig","title":"<code>FileConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for a single file used in a loading job.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.file_alias","title":"<code>file_alias = Field(description='An alias for the file, used as a reference.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.file_path","title":"<code>file_path = Field(default=None, description='The path to the file on disk.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.csv_parsing_options","title":"<code>csv_parsing_options = Field(default_factory=CsvParsingOptions, description='Options for parsing the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.node_mappings","title":"<code>node_mappings = Field(default=[], description='Node mappings defined for this file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.edge_mappings","title":"<code>edge_mappings = Field(default=[], description='Edge mappings defined for this file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.validate_mappings","title":"<code>validate_mappings()</code>","text":"<p>Ensure that at least one mapping (node or edge) exists.</p> <p>Returns:</p> <ul> <li> <code>FileConfig</code>           \u2013            <p>The validated file configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no node or edge mappings are provided.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions","title":"<code>CsvParsingOptions</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration options for CSV parsing.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.separator","title":"<code>separator = Field(default=',', description='The separator used in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.header","title":"<code>header = Field(default=True, description='Whether the CSV file contains a header row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.EOL","title":"<code>EOL = Field(default='\\\\n', description='The end-of-line character in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.quote","title":"<code>quote = Field(default=QuoteType.DOUBLE, description='The type of quote used in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig","title":"<code>NodeMappingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for mapping node attributes from a file to the target schema.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig.target_name","title":"<code>target_name = Field(description='The name of the target node type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig.attribute_column_mappings","title":"<code>attribute_column_mappings = Field(default={}, description='Mapping file columns to node attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig","title":"<code>EdgeMappingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for mapping edge attributes from a file to the target schema.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.target_name","title":"<code>target_name = Field(description='The target edge type name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.source_node_column","title":"<code>source_node_column = Field(description='The column representing the source node in the file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.target_node_column","title":"<code>target_node_column = Field(description='The column representing the target node in the file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.attribute_column_mappings","title":"<code>attribute_column_mappings = Field(default={}, description='Mappings between file columns and edge attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/","title":"Schema Configuration","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema","title":"<code>GraphSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph, including nodes and edges.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.graph_name","title":"<code>graph_name = Field(description='The name of the graph.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.nodes","title":"<code>nodes = Field(description='A dictionary of node type names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.edges","title":"<code>edges = Field(description='A dictionary of edge type names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.graph_schema.GraphSchema.validate_edge_references","title":"<code>validate_edge_references()</code>","text":"<p>Ensure all edges reference existing nodes in the graph schema.</p> <p>Returns:</p> <ul> <li> <code>GraphSchema</code>           \u2013            <p>The validated graph schema.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If any edge references undefined node types.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema","title":"<code>NodeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph node type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.primary_key","title":"<code>primary_key = Field(description='The primary key for the node type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.attributes","title":"<code>attributes = Field(default_factory=dict, description='A dictionary of attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.vector_attributes","title":"<code>vector_attributes = Field(default_factory=dict, description='A dictionary of vector attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.parse_attributes","title":"<code>parse_attributes(values)</code>","text":"<p>Parse shorthand attributes into full AttributeSchema.</p> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Input values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Parsed values with attributes as AttributeSchema.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.node_schema.NodeSchema.validate_primary_key_and_attributes","title":"<code>validate_primary_key_and_attributes()</code>","text":"<p>Validate that the primary key is present in attributes.</p> <p>Returns:</p> <ul> <li> <code>NodeSchema</code>           \u2013            <p>The validated node schema.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the primary key is not defined in attributes.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema","title":"<code>EdgeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph edge type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.is_directed_edge","title":"<code>is_directed_edge = Field(default=False, description='Whether the edge is directed.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.from_node_type","title":"<code>from_node_type = Field(description='The type of the source node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.to_node_type","title":"<code>to_node_type = Field(description='The type of the target node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.discriminator","title":"<code>discriminator = Field(default_factory=set, description='An attribute or set of attributes that uniquely identifies an edge in a graph, distinguishing it from other edges with the same source and target.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.attributes","title":"<code>attributes = Field(default_factory=dict, description='A dictionary of attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.parse_attributes","title":"<code>parse_attributes(values)</code>","text":"<p>Parse shorthand attributes into full AttributeSchema.</p> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Input values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Parsed values with attributes as AttributeSchema.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.edge_schema.EdgeSchema.validate_discriminator_and_attributes","title":"<code>validate_discriminator_and_attributes()</code>","text":"<p>Validate that every discriminator is present in attributes.</p> <p>Returns:</p> <ul> <li> <code>EdgeSchema</code>           \u2013            <p>The validated edge schema.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If any discriminator is not defined in attributes.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema","title":"<code>AttributeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph attribute.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.data_type","title":"<code>data_type = Field(description='The data type of the attribute.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.default_value","title":"<code>default_value = Field(default=None, description='The default value for the attribute.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.PYTHON_TYPES","title":"<code>PYTHON_TYPES = {DataType.INT: int, DataType.UINT: int, DataType.FLOAT: (float, int), DataType.DOUBLE: (float, int), DataType.BOOL: bool, DataType.STRING: str, DataType.DATETIME: str}</code>  <code>class-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.attribute_schema.AttributeSchema.validate_default_value","title":"<code>validate_default_value()</code>","text":"<p>Validate that the default value matches the expected data type.</p> <p>Returns:</p> <ul> <li> <code>AttributeSchema</code>           \u2013            <p>The validated AttributeSchema.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the default value does not match the expected data type.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema","title":"<code>VectorAttributeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a vector attribute.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.dimension","title":"<code>dimension = Field(ge=1, default=1536, description='The dimension of the vector attribute. Must be at least 1.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.index_type","title":"<code>index_type = Field(default='HNSW', description='The index type for the vector attribute. Currently only \"HNSW\" is supported.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.data_type","title":"<code>data_type = Field(default='FLOAT', description='The data type of the attribute. Currently only \"FLOAT\" is supported. Future types may include \"DOUBLE\", \"HALF\", or \"BYTE\".')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.vector_attribute_schema.VectorAttributeSchema.metric","title":"<code>metric = Field(default='COSINE', description='The metric used for distance calculations. Can be \"COSINE\", \"IP\" (inner product), or \"L2\".')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType","title":"<code>DataType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported data types.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.INT","title":"<code>INT = 'INT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents an integer type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.UINT","title":"<code>UINT = 'UINT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents an unsigned integer type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.FLOAT","title":"<code>FLOAT = 'FLOAT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents a floating-point type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.DOUBLE","title":"<code>DOUBLE = 'DOUBLE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents a double-precision floating-point type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.BOOL","title":"<code>BOOL = 'BOOL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents a boolean type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.STRING","title":"<code>STRING = 'STRING'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents a string type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema.data_type.DataType.DATETIME","title":"<code>DATETIME = 'DATETIME'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents a datetime type.</p>"},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/","title":"TigerGraphConnectionConfig","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig","title":"<code>TigerGraphConnectionConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for connecting to a TigerGraph instance.</p> <p>This class supports:</p> <ol> <li>User/password authentication</li> <li>Secret-based authentication</li> <li>Token-based authentication</li> </ol>"},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.host","title":"<code>host = Field(default=HttpUrl('http://127.0.0.1'), description='The host URL for the TigerGraph connection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.restpp_port","title":"<code>restpp_port = Field(default='14240', description='The port for REST++ API.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.gsql_port","title":"<code>gsql_port = Field(default='14240', description='The port for GSQL.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.username","title":"<code>username = Field(default='tigergraph', description='The username for TigerGraph authentication. Use only for user/password authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.password","title":"<code>password = Field(default='tigergraph', description='The password for TigerGraph authentication. Use only for user/password authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.secret","title":"<code>secret = Field(default=None, description='The secret for TigerGraph authentication. Use only for secret-based authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.token","title":"<code>token = Field(default=None, description='The API token for TigerGraph authentication. Use only for token-based authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.check_exclusive_authentication","title":"<code>check_exclusive_authentication(values)</code>","text":"<p>Ensure that exactly one authentication method is provided:</p> <ul> <li>username/password together, or</li> <li>secret, or</li> <li>token. If all fields are empty, username/password will default.</li> </ul> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input values for validation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>The validated values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than one authentication method is provided.</p> </li> </ul>"},{"location":"reference/04_config/02_query/neighbor_spec/","title":"NeighborSpec","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec","title":"<code>NeighborSpec</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Specification for selecting neighbors in a graph query.</p>"},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.start_nodes","title":"<code>start_nodes = Field(..., description='List of starting node IDs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.start_node_type","title":"<code>start_node_type = Field(..., description='The type of the start node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.edge_types","title":"<code>edge_types = Field(None, description='List of allowed edge types for traversal.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.target_node_types","title":"<code>target_node_types = Field(None, description='List of allowed target node types.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.filter_expression","title":"<code>filter_expression = Field(None, description='A string defining complex filtering logic.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.return_attributes","title":"<code>return_attributes = Field(None, description='List of attributes to include in the results.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.limit","title":"<code>limit = Field(None, description='Maximum number of results to return.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/","title":"NodeSpec","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec","title":"<code>NodeSpec</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Specification for selecting nodes in a graph query.</p>"},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.node_type","title":"<code>node_type = Field(None, description='The type of nodes to select.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.all_node_types","title":"<code>all_node_types = Field(False, description='If True, nodes of all types will be returned, and the value of `node_type` will be ignored.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.filter_expression","title":"<code>filter_expression = Field(None, description='A string defining filtering logic for the node selection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.return_attributes","title":"<code>return_attributes = Field(None, description='List of attributes to include in the output.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.limit","title":"<code>limit = Field(None, description='Maximum number of nodes to select.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/","title":"Chat Settings","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.BaseChatConfig","title":"<code>BaseChatConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for chat models.</p>"},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.BaseChatConfig.type","title":"<code>type = Field(description='Mandatory base type; derived classes can override or set a default.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig","title":"<code>OpenAIChatConfig</code>","text":"<p>               Bases: <code>BaseChatConfig</code></p> <p>Configuration class for OpenAI Chat models.</p>"},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.type","title":"<code>type = Field(default='OpenAI', description='Default type for OpenAIChatConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.model","title":"<code>model = Field(default='gpt-4o-mini', description='Default OpenAI model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.max_retries","title":"<code>max_retries = Field(default=10, description='Maximum number of retries for API calls.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/","title":"Embedding Settings","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.BaseEmbeddingConfig","title":"<code>BaseEmbeddingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for embedding models.</p>"},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.BaseEmbeddingConfig.type","title":"<code>type = Field(description='Mandatory base type; derived classes can override or set a default.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig","title":"<code>OpenAIEmbeddingConfig</code>","text":"<p>               Bases: <code>BaseEmbeddingConfig</code></p> <p>Configuration class for OpenAI Embedding models.</p>"},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.type","title":"<code>type = Field(default='OpenAI', description='Default type for OpenAIEmbeddingConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.model","title":"<code>model = Field(default='text-embedding-3-small', description='Default OpenAI embedding model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.max_tokens","title":"<code>max_tokens = Field(default=8191, description='Maximum number of tokens supported.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.max_retries","title":"<code>max_retries = Field(default=10, description='Maximum number of retries for API calls.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.encoding_name","title":"<code>encoding_name = Field(default='cl100k_base', description='Token encoding name used by the model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/","title":"LLM Settings","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.BaseLLMConfig","title":"<code>BaseLLMConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for LLM.</p>"},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.BaseLLMConfig.type","title":"<code>type = Field(description='Mandatory type field for identifying the LLM type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig","title":"<code>OpenAIConfig</code>","text":"<p>               Bases: <code>BaseLLMConfig</code></p> <p>Configuration class for OpenAI.</p>"},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.type","title":"<code>type = Field(default='OpenAI', description='Default type for OpenAIConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.api_key","title":"<code>api_key = Field(alias='OPENAI_API_KEY', description='API key for authentication with OpenAI.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.base_url","title":"<code>base_url = Field(default=None, description='Custom base URL for OpenAI API.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.organization","title":"<code>organization = Field(default=None, description='OpenAI organization ID (if applicable).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.max_retries","title":"<code>max_retries = Field(default=10, description='Maximum number of retries for failed API requests.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.request_timeout","title":"<code>request_timeout = Field(default=180.0, description='Request timeout in seconds.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/","title":"Settings","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Application settings, including configurations for vector databases, LLMs, embeddings, and chat models.</p>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.vector_db","title":"<code>vector_db = Field(description='Configuration for the vector database.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.llm","title":"<code>llm = Field(description='Configuration for the language model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.embedding","title":"<code>embedding = Field(description='Configuration for the embedding model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.chat","title":"<code>chat = Field(description='Configuration for the chat model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_vector_db","title":"<code>validate_vector_db(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the vector_db field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the vector database.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseVectorDBConfig</code> (              <code>BaseVectorDBConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of vector database is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_llm","title":"<code>validate_llm(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the llm field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the language model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseLLMConfig</code> (              <code>BaseLLMConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of language model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_embedding","title":"<code>validate_embedding(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the embedding field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the embedding model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseEmbeddingConfig</code> (              <code>BaseEmbeddingConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of embedding model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_chat","title":"<code>validate_chat(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the chat field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the chat model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseChatConfig</code> (              <code>BaseChatConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of chat model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/vector_db_settings/","title":"Vector DB Settings","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.BaseVectorDBConfig","title":"<code>BaseVectorDBConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for vector databases.</p>"},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.BaseVectorDBConfig.type","title":"<code>type = Field(description='Mandatory type field to identify the database type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig","title":"<code>NanoVectorDBConfig</code>","text":"<p>               Bases: <code>BaseVectorDBConfig</code></p> <p>Configuration class for NanoVectorDB.</p>"},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.type","title":"<code>type = Field(default='NanoVectorDB', description='Default type for NanoVectorDBConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.storage_file","title":"<code>storage_file = Field(default='nano-vectordb.json', description='Path to the storage file for NanoVectorDB.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.embedding_dim","title":"<code>embedding_dim = Field(default=1536, description='Default embedding dimension for NanoVectorDB.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/05_graphrag/base_context_builder/","title":"BaseContextBuilder","text":""},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder","title":"<code>BaseContextBuilder</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for building context using graph data and a search engine.</p> <p>Attributes:</p> <ul> <li> <code>graph</code>           \u2013            <p>The graph object.</p> </li> <li> <code>single_batch</code>           \u2013            <p>Whether to process data in a single batch.</p> </li> <li> <code>search_engine</code>           \u2013            <p>The search engine for retrieving top-k objects.</p> </li> <li> <code>token_encoder</code>           \u2013            <p>Token encoder for text tokenization.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.__init__","title":"<code>__init__(graph, single_batch, search_engine=None, token_encoder=None)</code>","text":"<p>Initialize the BaseContextBuilder.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>The graph object.</p> </li> <li> <code>single_batch</code>               (<code>bool</code>)           \u2013            <p>Whether to process data in a single batch.</p> </li> <li> <code>search_engine</code>               (<code>Optional[BaseSearchEngine]</code>, default:                   <code>None</code> )           \u2013            <p>The search engine for similarity searches.</p> </li> <li> <code>token_encoder</code>               (<code>Optional[Encoding]</code>, default:                   <code>None</code> )           \u2013            <p>Token encoder for text tokenization. Defaults to \"cl100k_base\".</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.build_context","title":"<code>build_context(*args, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to build context.</p> <p>Returns:</p> <ul> <li> <code>str | List[str]</code>           \u2013            <p>The generated context as a string or list of strings.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.batch_and_convert_to_text","title":"<code>batch_and_convert_to_text(graph_data, section_name, single_batch=False, max_tokens=12000)</code>","text":"<p>Convert graph data to a formatted string or list of strings in batches based on token count.</p> <p>Parameters:</p> <ul> <li> <code>graph_data</code>               (<code>DataFrame</code>)           \u2013            <p>The graph data to convert.</p> </li> <li> <code>section_name</code>               (<code>str</code>)           \u2013            <p>The section name for the header.</p> </li> <li> <code>single_batch</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to process data in a single batch. Defaults to False.</p> </li> <li> <code>max_tokens</code>               (<code>int</code>, default:                   <code>12000</code> )           \u2013            <p>Maximum number of tokens per batch. Defaults to 12000.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | List[str]</code>           \u2013            <p>The formatted graph data as a string or list of strings.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.retrieve_top_k_objects","title":"<code>retrieve_top_k_objects(query, k=10, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the top-k objects most similar to the query.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>str</code>)           \u2013            <p>The query string.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of top results to retrieve. Defaults to 10.</p> </li> <li> <code>**kwargs</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters for the search engine.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>A list of the top-k results.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>k</code> is less than or equal to 0 or if the search engine is not initialized.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/","title":"ParquetProcessor","text":""},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor","title":"<code>ParquetProcessor</code>","text":"<p>A class to process Parquet files and generate CSV files with custom transformations.</p>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.__init__","title":"<code>__init__(input_dir, output_dir)</code>","text":"<p>Initialize the ParquetProcessor with input and output directories.</p> <p>Parameters:</p> <ul> <li> <code>input_dir</code>               (<code>str | Path</code>)           \u2013            <p>Directory containing the input Parquet files.</p> </li> <li> <code>output_dir</code>               (<code>str | Path</code>)           \u2013            <p>Directory to save the output CSV files.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.save_dataframe_to_csv","title":"<code>save_dataframe_to_csv(df, csv_file_name)</code>","text":"<p>Save a DataFrame or Series to a CSV file with specific formatting.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame | Series</code>)           \u2013            <p>The DataFrame or Series to save.</p> </li> <li> <code>csv_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.convert_parquet_to_csv","title":"<code>convert_parquet_to_csv(parquet_file_name, columns, csv_file_name)</code>","text":"<p>Convert a Parquet file to a CSV file with specific columns.</p> <p>Parameters:</p> <ul> <li> <code>parquet_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the input Parquet file.</p> </li> <li> <code>columns</code>               (<code>List[str]</code>)           \u2013            <p>List of columns to include in the output CSV.</p> </li> <li> <code>csv_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.create_relationship_file","title":"<code>create_relationship_file(df, element_list_name, element_name, collection_name, collection_new_name, output_name)</code>","text":"<p>Generate a CSV file for relationship mapping based on input DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>Input DataFrame containing relationship data.</p> </li> <li> <code>element_list_name</code>               (<code>str</code>)           \u2013            <p>Name of the column containing element lists.</p> </li> <li> <code>element_name</code>               (<code>str</code>)           \u2013            <p>Name of the element to map.</p> </li> <li> <code>collection_name</code>               (<code>str</code>)           \u2013            <p>Name of the collection column.</p> </li> <li> <code>collection_new_name</code>               (<code>str</code>)           \u2013            <p>New name for the collection in the output.</p> </li> <li> <code>output_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.process_parquet_files","title":"<code>process_parquet_files(configs)</code>","text":"<p>Process a list of Parquet file configurations and convert them to CSV.</p> <p>Parameters:</p> <ul> <li> <code>configs</code>               (<code>List[Dict[str, Any]]</code>)           \u2013            <p>List of configuration dictionaries for processing Parquet files.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.process_relationship_files","title":"<code>process_relationship_files(configs)</code>","text":"<p>Process a list of relationship file configurations and generate CSV files.</p> <p>Parameters:</p> <ul> <li> <code>configs</code>               (<code>List[Dict[str, Any]]</code>)           \u2013            <p>List of configuration dictionaries for generating relationship files.</p> </li> </ul>"},{"location":"reference/07_utils/retry_mixin/","title":"RetryMixin","text":""},{"location":"reference/07_utils/retry_mixin/#tigergraphx.utils.RetryMixin","title":"<code>RetryMixin</code>","text":"<p>Mixin for initializing a retry mechanism with configurable parameters.</p>"},{"location":"reference/07_utils/retry_mixin/#tigergraphx.utils.RetryMixin.initialize_retryer","title":"<code>initialize_retryer(max_retries, max_wait)</code>","text":"<p>Initialize the retry mechanism with exponential backoff and jitter.</p> <p>Parameters:</p> <ul> <li> <code>max_retries</code>               (<code>int</code>)           \u2013            <p>Maximum number of retry attempts.</p> </li> <li> <code>max_wait</code>               (<code>int</code>)           \u2013            <p>Maximum wait time between retries in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncRetrying</code> (              <code>AsyncRetrying</code> )          \u2013            <p>Configured retrying instance with specified parameters.</p> </li> </ul>"}]}